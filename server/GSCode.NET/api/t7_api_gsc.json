{
	"languageId": "gsc",
	"gameId": "t7",
	"revision": 1,
	"api": [
		{
			"name": "ActivateClientExploder",
			"description": "Activates a client side exploderThis is sent as a reliable command, and will not work with killcam or demos.",
			"calledOn": null,
			"parameters": [
				{
					"name": "exploder id",
					"description": "id of exploder to activate",
					"mandatory": true
				}
			],
			"example": "ActivateClientExploder( 101 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActivateClientRadiantExploder",
			"description": "Activates a client side radiant exploder",
			"calledOn": null,
			"parameters": [
				{
					"name": "exploder id",
					"description": "string id of exploder to activate",
					"mandatory": true
				}
			],
			"example": "ActivateClientRadiantExploder( \"light_switch\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActorIKEnabled",
			"description": "Determines whether this actor can use IK functions. Returns true if IK is available, otherwise false.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if (guy ActorIKEnabled()) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddBonusCardStat",
			"description": "Sets the indicated stat for that bonus card",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bonuscard",
					"description": "Bonus Card define from _bonuscards.gsh",
					"mandatory": true
				},
				{
					"name": "statname",
					"description": "The name of the stat you wish to set",
					"mandatory": true
				},
				{
					"name": "statincrease",
					"description": "The amount you would like to increase the stat",
					"mandatory": true
				},
				{
					"name": "currentclassnum",
					"description": "The loadout the player is using",
					"mandatory": true
				}
			],
			"example": "self AddBonusCardStat( BONUSCARD_OVERKILL, \"kills\", 1, self.class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddDemoBookmark",
			"description": "adds the information to the demo bookmarking system",
			"calledOn": null,
			"parameters": [
				{
					"name": "type",
					"description": "the type of bookmark",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "the time of recording the bookmark",
					"mandatory": true
				},
				{
					"name": "client1",
					"description": "the client related to the bookmark",
					"mandatory": true
				},
				{
					"name": "client2",
					"description": "other client which is associated with the bookmark",
					"mandatory": true
				},
				{},
				{
					"name": "entityNumber",
					"description": "The entity number",
					"mandatory": true
				},
				{
					"name": "eType",
					"description": "Entity type",
					"mandatory": true
				},
				{
					"name": "birthTime",
					"description": "Birth Time",
					"mandatory": true
				},
				{
					"name": "overrideEntityCamera",
					"description": "Whether to override Entity Camera",
					"mandatory": true
				},
				{}
			],
			"example": "AddDemoBookmark( bookmark_string, gettime(), self GetEntityNumber(), 255, 0, inflictorEntNum, inflictorEntType, inflictorBirthTime, false, self.grenade_multiattack_ent GetEntityNumber() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddEntityInfluencer",
			"description": "Adds a new influencer of <name> attached to <entity>",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "valid spawn influencer preset name.",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "Attached to entity.  Goes away when entity is deleted. Unless a time is set.",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "teams that this influencer will affect",
					"mandatory": true
				}
			],
			"example": "influencer_id = AddEntityInfluencer( name, player, allies_mask )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddInfluencer",
			"description": "Adds a new influencer of <name> at <origin>",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "valid spawn influencer preset name.",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "center point of the influencer",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "teams that this influencer will affect",
					"mandatory": true
				}
			],
			"example": "influencer_id = AddInfluencer( name, origin, allies_mask )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddOrientedInfluencer",
			"description": "Adds a new influencer of <name> at <origin> and <angles>",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "valid spawn influencer preset name.",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "center point of the influencer",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "angles of entity",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "teams that this influencer will affect",
					"mandatory": true
				}
			],
			"example": "influencer_id = AddOrientedInfluencer( name, origin, angles, allies_mask )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddSpawnPoints",
			"description": "Adds spawnpoints to the spawn system",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The team",
					"mandatory": true
				},
				{}
			],
			"example": "AddSpawnPoints( \"allies\", \"mp_tdm_spawn\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddTestClient",
			"description": "Adds a test client to the map and returns a reference to that client.",
			"calledOn": null,
			"parameters": [],
			"example": "ent[i] = AddTestClient()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddToInterestPool",
			"description": "Add a script event to the sentient's interest pool.",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "Amount the event adds to the pool. (integer)",
					"mandatory": true
				},
				{
					"name": "priority",
					"description": "How important is the event. (integer)",
					"mandatory": true
				},
				{
					"name": "lifespan",
					"description": "Time the event stays in the pool. (float)",
					"mandatory": true
				},
				{
					"name": "point of interest",
					"description": "Position the AI will investigate. (vector3)",
					"mandatory": true
				},
				{
					"name": "originator",
					"description": "Entity that caused the event.",
					"mandatory": true
				},
				{
					"name": "unique",
					"description": "Only one of this type can exist in the pool. (integer)",
					"mandatory": false
				}
			],
			"example": "point = self AddToInterestPool( 500, 10, 5, ai.origin, ai )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AimAtEntityIK",
			"description": "Set this actor to aim at the specified entity. Call this function without any entity specified to turn it off.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "otherguy",
					"description": "the other guy to aim at",
					"mandatory": false
				}
			],
			"example": "guy AimAtEntityIK( otherguy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AimAtPosIK",
			"description": "Set this actor to aim at the specified position. Call this function without any position specified to turn it off.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "pos",
					"description": "the position to aim at",
					"mandatory": false
				}
			],
			"example": "guy AimAtPosIK( pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllClientsPrint",
			"description": "Cause all clients to print the localized version of this string.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "the string to print",
					"mandatory": true
				}
			],
			"example": "AllClientsPrint( \"Game Complete\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowedStances",
			"description": "Sets the list of the actor's allowed stances.",
			"calledOn": "actor_or_player",
			"parameters": [
				{
					"name": "stance",
					"description": "(string) A stance, can be 'prone', 'crouch', 'stand'. Any number of stances may be added.",
					"mandatory": true
				}
			],
			"example": "self AllowedStances( \"crouch\", \"prone\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowTacticalInsertion",
			"description": "If false, disallows tactical insertions in the bounding area of this entity. Allows tactical insertions otherwise",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "allow",
					"description": "true or false",
					"mandatory": true
				}
			],
			"example": "my_trigger AllowTacticalInsertion( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllWeaponAttachmentsUnlocked",
			"description": "Are all the weapon attachments unlocked for this weapon?",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon",
					"mandatory": true
				}
			],
			"example": "player AllWeaponAttachmentsUnlocked( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnimHasNotetrack",
			"description": "queries the given animation for a note track",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "an animation",
					"mandatory": true
				},
				{
					"name": "note track",
					"description": "a constant string with the name of the note track",
					"mandatory": true
				}
			],
			"example": "if ( IsDefined( facialanim ) && AnimHasNotetrack( facialanim, \"dialogue\" ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnimMappingSearch",
			"description": "Searches animation mapping table to return a animation name when given a animation mapping alias name.",
			"calledOn": "actor",
			"parameters": [
				{}
			],
			"example": "self AnimMappingSearch(\"anim_arrive_cover_left_crouch\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnimRelative",
			"description": "Runs an animscript on an entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "notify",
					"description": "The notify to send",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The starting position of the anim script",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The starting angle of the anim script",
					"mandatory": true
				},
				{
					"name": "animation",
					"description": "The animation",
					"mandatory": true
				},
				{
					"name": "mode",
					"description": "Valid modes are \"normal\" and \"deathplant\"",
					"mandatory": false
				},
				{
					"name": "root",
					"description": "The root animation",
					"mandatory": false
				}
			],
			"example": "driver AnimRelative( \"germantruck_driver_closedoor\", org , angles, driver.closedooranim )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnimScripted",
			"description": "Runs an animscript on an entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "notify",
					"description": "The notify to send",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The starting position of the anim script",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The starting angle of the anim script",
					"mandatory": true
				},
				{
					"name": "animation",
					"description": "The animation",
					"mandatory": true
				},
				{
					"name": "mode",
					"description": "Valid modes are \"normal\" and \"deathplant\"",
					"mandatory": false
				},
				{
					"name": "root",
					"description": "The root animation",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "The playback rate of animation",
					"mandatory": false
				},
				{
					"name": "blend",
					"description": "The blend time for the animation",
					"mandatory": false
				},
				{
					"name": "lerp",
					"description": "The lerp time for an aligned animation",
					"mandatory": false
				},
				{
					"name": "animation time",
					"description": "The starting animation time in 0-1 range",
					"mandatory": false
				},
				{
					"name": "is_scene_animation",
					"description": "Should be true for player scene animations or scripted animations where the player has no control, can be ignored for non-players",
					"mandatory": false
				},
				{
					"name": "showPlayerWeaponInFirstPerson",
					"description": "determines if the first person player should have his weapon during cinematics",
					"mandatory": false
				}
			],
			"example": "driver AnimScripted( \"germantruck_driver_closedoor\", org , angles, driver.closedooranim )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Announcement",
			"description": "Sends an announcement to all clients.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The announcement.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "How long, in seconds, to display the announcement.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ApplyBallisticTarget",
			"description": "Launch a vehicle with just enough force at a target.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "targetPos",
					"description": "The position to launch the vehicle towards",
					"mandatory": true
				}
			],
			"example": "dropRaps ApplyBallisticTarget( (50,50,10) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AreAllMissionsAtScore",
			"description": "Returns true if all missions are at the score specified",
			"calledOn": "player",
			"parameters": [
				{
					"name": "score",
					"description": "A score that all missions must be at to return true (integer)",
					"mandatory": true
				}
			],
			"example": "is_score_achieved = self AreAllMissionsAtScore( 10000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "arenagetcurrentseason",
			"description": "Returns the current arena season",
			"calledOn": null,
			"parameters": [],
			"example": "ArenaGetCurrentSeason()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArenaGetSlot",
			"description": "Returns the current arena slot",
			"calledOn": null,
			"parameters": [],
			"example": "ArenaGetSlot()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AreTexturesLoaded",
			"description": "Check to see if start-of-level textures are loaded - if they're not, the streamer forces a black screen.",
			"calledOn": null,
			"parameters": [],
			"example": "while( !areTexturesLoaded() ) { wait(0.05); }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArraySort",
			"description": "Returns a sorted array of entities by closest or farthest distance from <origin>",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to sort",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "the origin from which to compare",
					"mandatory": true
				},
				{
					"name": "closest",
					"description": "if set to true the array will be sorted by distance closest to <origin>, if false by distance farthest from <origin>",
					"mandatory": false
				},
				{
					"name": "max",
					"description": "if set then only the first <max> count of entities will be returned",
					"mandatory": false
				},
				{
					"name": "range",
					"description": "if set then only the entities within <range> will be considered",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArraySortClosest",
			"description": "Returns a sorted array of entities by closest from <origin>",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to sort",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "the origin from which to compare",
					"mandatory": true
				},
				{
					"name": "<maxReturnCount",
					"description": "if set then only the first <max> count of entities will be returned",
					"mandatory": false
				},
				{
					"name": "minDist",
					"description": "if set then only the entities further than <minDist> will be considered",
					"mandatory": false
				},
				{
					"name": "maxDist",
					"description": "if set then only the entities closer then <maxDist will be considered",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArtilleryIconLocation",
			"description": "Set the artillery icon location",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position of icon",
					"mandatory": true
				},
				{
					"name": "teamNum",
					"description": "Team number",
					"mandatory": true
				},
				{
					"name": "isActive",
					"description": "Whether the icon is active or not",
					"mandatory": true
				},
				{
					"name": "isMortar",
					"description": "Whether the artillery is a mortar",
					"mandatory": false
				},
				{
					"name": "clientNum",
					"description": "The client number",
					"mandatory": false
				}
			],
			"example": "ArtilleryIconLocation( self.origin, 1, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ASMSetAnimationRate",
			"description": "change the delta animation rate for the entity using ASM.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "rate",
					"description": "(float)",
					"mandatory": true
				}
			],
			"example": "self ASMSetAnimationRate( 0.3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Attach",
			"description": "Attach a model to an entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "modelname",
					"description": "The model name to attach (string).",
					"mandatory": true
				},
				{
					"name": "tagname",
					"description": "The tag to attach the model to (string).",
					"mandatory": false
				},
				{
					"name": "ignoreCollision",
					"description": "flag to ignore collision. Defaults to false (integer).",
					"mandatory": false
				}
			],
			"example": "self Attach( \"panzerflak_ammo\", \"tag_weapon_left\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AttachShieldModel",
			"description": "Attach a shield model to a player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "modelname",
					"description": "The model name to attach (string).",
					"mandatory": true
				},
				{
					"name": "tagname",
					"description": "The tag to attach the model to (string).",
					"mandatory": false
				},
				{
					"name": "ignoreCollision",
					"description": "flag to ignore collision. Defaults to false (integer).",
					"mandatory": false
				}
			],
			"example": "self AttachShieldModel( \"weapon_riot_shield\", \"tag_weapon_left\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BadPlace_Box",
			"description": "Creates a bad place box. AI will flee this position if they can, and will not go into it if they can avoid it.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "The name of the bad place. If name is not \"\", the bad place can be moved or deleted by using the unique name.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "If duration > 0, the bad place will automatically delete itself after this time. If duration <= 0, the bad place must have a name and will last until manually deleted.",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The origin of the box.",
					"mandatory": true
				},
				{
					"name": "halfSize",
					"description": "The halfSize of the box.",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.",
					"mandatory": true
				}
			],
			"example": "BadPlace_Box( \"moody\", -1, level.moodyfall_mn, level.moodyfall_halfSize, \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BadPlace_Cylinder",
			"description": "Creates a bad place cylinder. AI will flee this position if they can, and will not go into it if they can avoid it.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "The name of the bad place. If name is not \"\", the bad place can be moved or deleted by using the unique name.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "If duration > 0, the bad place will automatically delete itself after this time. If duration <= 0, the bad place must have a name and will last until manually deleted.",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The origin of the cylinder.",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the cylinder.",
					"mandatory": true
				},
				{
					"name": "height",
					"description": "The height of the cylinder.",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.",
					"mandatory": true
				}
			],
			"example": "BadPlace_Cylinder( \"moody\", -1, level.moodyfall_mn, level.moodyfall_radius, \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BadPlace_Delete",
			"description": "Deletes a bad place. It is okay to delete a bad place name that doesn't exist. It is not okay to delete the special name \"\".",
			"calledOn": null,
			"parameters": [
				{
					"name": "bad place identifier",
					"description": "The bad place to delete",
					"mandatory": true
				}
			],
			"example": "BadPlace_Delete( \"bpFlak1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BallSetTarget",
			"description": "Sets the target of the ball to the given entity, and resets if no entity is specified.",
			"calledOn": "ball",
			"parameters": [
				{
					"name": "target",
					"description": "The target of the missile",
					"mandatory": true
				},
				{
					"name": "targetOffset",
					"description": "Offset to the target location (vector3)",
					"mandatory": false
				}
			],
			"example": "self BallSetTarget( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Ban",
			"description": "Bans the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "clientnum",
					"description": "The client number of the player to ban.",
					"mandatory": true
				}
			],
			"example": "Ban( 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeamTrace",
			"description": "Performs a bullet trace between two points and returns an array of information about the trace result.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start_pos",
					"description": "(point) The start position for the trace.",
					"mandatory": true
				},
				{
					"name": "end_pos",
					"description": "(point) The end position for the trace.",
					"mandatory": true
				},
				{
					"name": "hit_characters",
					"description": "(bool) Tell the trace to hit characters or not.",
					"mandatory": true
				},
				{
					"name": "ignore_ent",
					"description": "(entity) Entity to ingore for trace.",
					"mandatory": true
				},
				{
					"name": "ignore_water",
					"description": "(bool) Ignore water - defaults to false.",
					"mandatory": false
				},
				{
					"name": "ignore_glass",
					"description": "(bool) Ignore glass - defaults to false.",
					"mandatory": false
				},
				{
					"name": "ignore_ent2",
					"description": "(entity) Second entity to ingore for trace.",
					"mandatory": false
				}
			],
			"example": "a_trace = BeamTrace( org1, org2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BloodImpact",
			"description": "Sets the blood impact type on the character",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "value",
					"description": "Has to be one of: \"none\", \"hero\" or \"normal\"",
					"mandatory": true
				}
			],
			"example": "guy BloodImpact ( \"none\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Bobbing",
			"description": "Causes a script entity to bob around its origin, along a given vector dir",
			"calledOn": null,
			"parameters": [
				{
					"name": "direction vector",
					"description": "The direction of the bobbing",
					"mandatory": true
				},
				{
					"name": "amplitude",
					"description": "The amount of the bobbing in units",
					"mandatory": true
				},
				{
					"name": "period",
					"description": "The period of the bobbing in seconds",
					"mandatory": true
				},
				{
					"name": "phase",
					"description": "The phase offset of the bobbing",
					"mandatory": false
				}
			],
			"example": "self Bobbing( directionVir, 0.3, 0.4, 0.0f )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BonusCardActiveCount",
			"description": "Returns how many bonus cards are active, cannot be called on a larry",
			"calledOn": "player",
			"parameters": [
				{
					"name": "classnum",
					"description": "The current class num of the player",
					"mandatory": true
				}
			],
			"example": "cardCount = self BonusCardActiveCount( self.class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BoundsWouldTelefrag",
			"description": "Returns true if the passed in bounding box would telefrag a player if another player was spawned there.",
			"calledOn": null,
			"parameters": [
				{
					"name": "mins",
					"description": "Mins of bounding box",
					"mandatory": true
				},
				{
					"name": "maxs",
					"description": "Maxs of bounding box",
					"mandatory": true
				}
			],
			"example": "if ( BoundsWouldTelefrag( vehicle GetAbsMins(), vehicle GetAbsmaxs() ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BulletSpread",
			"description": "uses spread to return a new end position",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The bullet starting point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The bullet ending point",
					"mandatory": true
				},
				{
					"name": "spread",
					"description": "Amount of spread",
					"mandatory": true
				}
			],
			"example": "endpos = BulletSpread( self.origin, target.origin, 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BulletTrace",
			"description": "Performs a bullet trace between two points and returns an array of information about the trace result.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start_pos",
					"description": "(point) The start position for the trace.",
					"mandatory": true
				},
				{
					"name": "end_pos",
					"description": "(point) The end position for the trace.",
					"mandatory": true
				},
				{
					"name": "hit_characters",
					"description": "(bool) Tell the trace to hit characters or not.",
					"mandatory": true
				},
				{
					"name": "ignore_ent",
					"description": "(entity) Entity to ingore for trace.",
					"mandatory": true
				},
				{
					"name": "ignore_water",
					"description": "(bool) Ignore water - defaults to false.",
					"mandatory": false
				},
				{
					"name": "ignore_glass",
					"description": "(bool) Ignore glass - defaults to false.",
					"mandatory": false
				},
				{
					"name": "ignore_ent2",
					"description": "(entity) Second entity to ingore for trace.",
					"mandatory": false
				}
			],
			"example": "a_trace = BulletTrace( org1, org2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BulletTracePassed",
			"description": "Allows script to do a bullet point trace with ( MASK_SHOT & ~CONTENTS_SKY ) returns true if the trace does not hit anything",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The bullet start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The bullet end point",
					"mandatory": true
				},
				{
					"name": "hit characters",
					"description": "An entity to ignore",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore",
					"mandatory": true
				},
				{
					"name": "ignore entity 2",
					"description": "An entity to ignore",
					"mandatory": false
				},
				{
					"name": "fx vis",
					"description": "check against fx visibility also",
					"mandatory": false
				},
				{
					"name": "ignore water",
					"description": "mask contents_water",
					"mandatory": false
				}
			],
			"example": "passed = BulletTracePassed( grenade.origin, self.origin + (0,0,TROPHY_TRACE_Z), false, self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CamAnimScripted",
			"description": "Plays the camera script on a player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player to play animation on",
					"mandatory": true
				},
				{
					"name": "cam_anim",
					"description": "The animation to play",
					"mandatory": true
				},
				{
					"name": "start_time",
					"description": "The start time of the animation",
					"mandatory": true
				},
				{
					"name": "align_origin",
					"description": "The origin to align to",
					"mandatory": true
				},
				{
					"name": "align_angles",
					"description": "The angles to align to",
					"mandatory": true
				},
				{
					"name": "lerp_duration",
					"description": "The lerp duration",
					"mandatory": false
				},
				{
					"name": "camera_name",
					"description": "The camera name",
					"mandatory": false
				},
				{
					"name": "ignoreProcessingInitialNoteTracks",
					"description": "Ignores processing the initial notetracks if the camera time starts earlier",
					"mandatory": false
				}
			],
			"example": "CamAnimScripted( player, \"proto_melee_cam\", gettime(), origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanClaimNode",
			"description": "Returns true if the node is unclaimed, false otherwise.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "pathnode to check",
					"mandatory": true
				},
				{}
			],
			"example": "if ( CanClaimNode( cover, team ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanPath",
			"description": "Check if a path can be found between these positions.",
			"calledOn": null,
			"parameters": [
				{},
				{}
			],
			"example": "if ( self CanPath( self.origin, targetpos ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ChangeAdvertisedStatus",
			"description": "Changes the advertised status",
			"calledOn": null,
			"parameters": [
				{
					"name": "onOff",
					"description": "(boolean)",
					"mandatory": true
				}
			],
			"example": "changeAdvertisedStatus( onOff )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CheckIfSongUnlocked",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play (string)",
					"mandatory": true
				}
			],
			"example": "self CheckIfSongUnlocked( \"frag_out\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CheckNavMeshDirection",
			"description": "Run a trace on NavMesh to get the furthest position a character can move in that direction",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "start of the trace",
					"mandatory": true
				},
				{
					"name": "dir",
					"description": "direction to trace",
					"mandatory": true
				},
				{
					"name": "dist",
					"description": "distance to trace",
					"mandatory": true
				},
				{
					"name": "characterRadius",
					"description": "the radius of the capsule used in trace. default to 0.",
					"mandatory": false
				},
				{
					"name": "materialFlags",
					"description": "the flags marking whether a face type can be used",
					"mandatory": false
				}
			],
			"example": "pos = CheckNavMeshDirection( (10,20,30), ( 1, 1, 0 ), 25 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearAnim",
			"description": "Sets an animation's goal weight (and the goal weights of all of its descendents) to zero over the specified time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to clear",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The blending time for the clear",
					"mandatory": true
				}
			],
			"example": "self ClearAnim( %root, 0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearAnimLimited",
			"description": "Sets an animation's goal weight to zero over the specified time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to clear",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The blending time for the clear",
					"mandatory": true
				}
			],
			"example": "self ClearAnimLimited( %root, 0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPlayerCorpses",
			"description": "Removes all player corpses from the level",
			"calledOn": null,
			"parameters": [],
			"example": "ClearPlayerCorpses( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPlayerGravity",
			"description": "Clears the gravity override for the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "player ClearPlayerGravity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearSpawnPoints",
			"description": "Clears all spawnpoints out of the system",
			"calledOn": null,
			"parameters": [
				{
					"name": "list",
					"description": "which list of spawnpoints to clear",
					"mandatory": false
				}
			],
			"example": "ClearSpawnPoints()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearSpawnPointsBaseWeight",
			"description": "Clears the objective base weights set in the spawn points",
			"calledOn": null,
			"parameters": [
				{
					"name": "team mask",
					"description": "teams that this command will affect",
					"mandatory": true
				}
			],
			"example": "ClearSpawnPointsBaseWeight( team_mask )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearStowedWeapon",
			"description": "Clears the stowed weapon for the player",
			"calledOn": "entity",
			"parameters": [],
			"example": "self ClearStowedWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearTargetEntity",
			"description": "Clears the current target for this vehicle or turret.",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret ClearTargetEntity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearTopScorers",
			"description": "Clears the top scorer for the end game screen.",
			"calledOn": null,
			"parameters": [],
			"example": "ClearTopScorers()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientAnnouncement",
			"description": "Sends an announcement to a single client.",
			"calledOn": null,
			"parameters": [
				{
					"name": "clientnum",
					"description": "The client number that the announcement is sent to.",
					"mandatory": true
				},
				{
					"name": "string",
					"description": "The announcement.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "How long, in seconds, to display the announcement.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientClaimTrigger",
			"description": "Claim a single user trigger.",
			"calledOn": "client",
			"parameters": [
				{
					"name": "trigger",
					"description": "A trigger entity.",
					"mandatory": true
				}
			],
			"example": "other ClientClaimTrigger( self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientPrint",
			"description": "Print a localized version of this string for a given client",
			"calledOn": null,
			"parameters": [
				{
					"name": "client",
					"description": "A client entity.",
					"mandatory": true
				},
				{
					"name": "string",
					"description": "A message to print.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientReleaseTrigger",
			"description": "Release a single user trigger.",
			"calledOn": "client",
			"parameters": [
				{
					"name": "trigger",
					"description": "A trigger entity.",
					"mandatory": true
				}
			],
			"example": "other ClientReleaseTrigger( self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientSysRegister",
			"description": "Declares a system who's state will be communicated over to the client script system when it changes.  Takes a unique name, and returns the id of the system.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "The unique name of the system to be registered",
					"mandatory": true
				}
			],
			"example": "index = ClientSysRegister(\"FakeFire\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClientSysSetState",
			"description": "Sets the state of a pre registered client system for all clients.  The state will be communicated to the client script system.",
			"calledOn": null,
			"parameters": [
				{
					"name": "id",
					"description": "The integer id of the client system.  Returned from call to ClientSysRegister.",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "Arbitrary string state.  Will be sent to the client script system.",
					"mandatory": true
				}
			],
			"example": "ClientSysSetState(level._ClientSys[\"FakeFire\"], \"Event1Phase1\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CloneAndRemoveEntity",
			"description": "Creates a new entity at the position/orientation/pose of the original, and kills the original",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "entity field",
					"mandatory": true
				}
			],
			"example": "CloneAndRemoveEntity( ent )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeGetClientField",
			"description": "Gets the value for a given client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity to search the name in",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "val = CodeGetClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeGetPlayerStateClientField",
			"description": "Gets the value for a given player state client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "A player",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "val = CodeGetPlayerStateClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeGetUIModelClientField",
			"description": "Gets the value for a given player uimodel client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "A player",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "val = CodeGetUIModelClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeGetWorldClientField",
			"description": "Gets the value for a given client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "val = CodeGetWorldClientField(\"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeIncrementClientField",
			"description": "Increments the value for a given client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "CodeIncrementClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeIncrementPlayerStateClientField",
			"description": "Increments the value for a given player state client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "A player",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "CodeIncrementPlayerStateClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeIncrementUIModelClientField",
			"description": "Increments the value for a given client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "CodeIncrementUIModelClientField(ent, \"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeIncrementWorldClientField",
			"description": "Increments the value for a given world client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				}
			],
			"example": "CodeIncrementWorldClientField(\"my_field\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeSetClientField",
			"description": "Sets the value for a given client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "Value to transmit.",
					"mandatory": true
				}
			],
			"example": "CodeSetClientField(ent, \"my_field\", 1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeSetPlayerStateClientField",
			"description": "Sets the value for a given player state client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "A player",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "Value to transmit.",
					"mandatory": true
				}
			],
			"example": "CodeSetPlayerStateClientField(ent, \"my_field\", 1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeSetUIModelClientField",
			"description": "Sets the value for a given player uimodel client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "A player",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "Value to transmit.",
					"mandatory": true
				}
			],
			"example": "CodeSetUIModelClientField(ent, \"my_field\", 1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CodeSetWorldClientField",
			"description": "Sets the value for a given world client field.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "Value to transmit.",
					"mandatory": true
				}
			],
			"example": "CodeSetWorldClientField(\"my_field\", 1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollisionTestPointsInBox",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollisionTestPointsInCone",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollisionTestPointsInCylinder",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollisionTestPointsInPill",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollisionTestPointsInSphere",
			"description": "Returns an array of collision result structures",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ConnectPaths",
			"description": "Connects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to connect paths.",
			"calledOn": "entity",
			"parameters": [],
			"example": "vehicle ConnectPaths()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ConsumableDecrement",
			"description": "Decrement a specified consumable for the player by the specified amount",
			"calledOn": "player",
			"parameters": [],
			"example": "self ConsumableDecrement( \"blackjack\", \"awarded\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ConsumableGet",
			"description": "Returns the value of the specified consumable for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "self ConsumableGet( \"blackjack\", \"awarded\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ConsumableIncrement",
			"description": "Increment a specified consumable for the player by the specified amount",
			"calledOn": "player",
			"parameters": [],
			"example": "self ConsumableIncrement( \"blackjack\", \"awarded\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ConsumableSet",
			"description": "Set a specified consumable for the player to the specified amount",
			"calledOn": "player",
			"parameters": [],
			"example": "self ConsumableSet( \"blackjack\", \"awarded\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CountPlayers",
			"description": "Returns a count of the current players, even if they are still connecting to the game.",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "- if specifed, returns lists of players on different teams, in team based game modes.  Valid values \"allies\", \"axis\", \"neutral\" & \"all\"",
					"mandatory": false
				}
			],
			"example": "count = CountPlayers()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CreateDynEntAndLaunch",
			"description": "Creates and launches a dynent.",
			"calledOn": null,
			"parameters": [
				{},
				{
					"name": "pos",
					"description": "position to spawn at.",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "angles to spawn at.",
					"mandatory": true
				},
				{
					"name": "hitpos",
					"description": "the hit position",
					"mandatory": true
				},
				{
					"name": "force",
					"description": "The force of the launch",
					"mandatory": true
				},
				{
					"name": "fx",
					"description": "particle effects to play on this dynent",
					"mandatory": false
				}
			],
			"example": "CreateDynEntAndLaunch( spawn_models[i], origin, angles, origin, velocity, anim._effect[\"animscript_gibtrail_fx\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CreateStreamerHint",
			"description": "Allows scripter to create a streamer hint entity viewpoint to the player's viewpoint.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Location at which to spawn the streamer hint.",
					"mandatory": true
				},
				{
					"name": "factor",
					"description": "The relative importance of this entity's viewpoint to the main viewpoint.",
					"mandatory": true
				},
				{
					"name": "lightingState",
					"description": "The lighting state to stream",
					"mandatory": false
				}
			],
			"example": "streamHintEnt = createStreamerHint( level.player.origin, 0.333 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CurrentSessionMode",
			"description": "Returns the current session mode index",
			"calledOn": null,
			"parameters": [],
			"example": "sessionMode = CurrentSessionMode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CylinderDamage",
			"description": "cylinder_dir_vector should contains the direction and the length of the cylinder relative to the base origin",
			"calledOn": null,
			"parameters": [
				{
					"name": "cylinder_vec",
					"description": "contains the direction and the length of the cylinder relative to the base origin",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "Origin of damage",
					"mandatory": true
				},
				{
					"name": "near_radius",
					"description": "Radius of the damage at the near end",
					"mandatory": true
				},
				{
					"name": "far_radius",
					"description": "Radius of the damage at the far end",
					"mandatory": true
				},
				{
					"name": "max_damage",
					"description": "Max damage, this is the damage at the origin",
					"mandatory": true
				},
				{
					"name": "min_damage",
					"description": "Max damage, this is the damage at the edge of the radius",
					"mandatory": true
				},
				{
					"name": "attacker",
					"description": "Attacker the dealt the damage",
					"mandatory": false
				},
				{
					"name": "means_of_death",
					"description": "Means of death of the damage",
					"mandatory": false
				},
				{
					"name": "weapon",
					"description": "Weapon used to damage",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DamageConeTrace",
			"description": "Determines how much the entity can be seen from the given position. Performs multiple traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "damage position",
					"description": "The point the sight starts at",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore when doing the traces",
					"mandatory": false
				},
				{
					"name": "damage angles",
					"description": "The forward direction of the cone, whose base is at the <damage position>.  Must be normalized.",
					"mandatory": false
				},
				{
					"name": "cone angle",
					"description": "Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.",
					"mandatory": false
				}
			],
			"example": "turretDamageFraction = entity damageConeTrace( turret.origin + (0,0,40), turret )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DeactivateClientExploder",
			"description": "Deactivates a client side exploder",
			"calledOn": null,
			"parameters": [
				{
					"name": "exploder id",
					"description": "id of exploder to deactivate",
					"mandatory": true
				}
			],
			"example": "DeactivateClientExploder( 101 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DeactivateClientRadiantExploder",
			"description": "Deactivates a client side radiant exploder",
			"calledOn": null,
			"parameters": [
				{
					"name": "exploder id",
					"description": "string id of exploder to deactivate",
					"mandatory": true
				}
			],
			"example": "DeactivateClientRadiantExploder( \"light_switch\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Delete",
			"description": "Removes an entity from the game in the same manner as a trigger_kill",
			"calledOn": "entity",
			"parameters": [],
			"example": "self Delete()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DeletePathNode",
			"description": "Delete a dynamically created path node or cover node",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to delete",
					"mandatory": true
				}
			],
			"example": "DeletePathNode( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DeployRiotShield",
			"description": "Gets the index in a particular class",
			"calledOn": null,
			"parameters": [
				{},
				{}
			],
			"example": "DeployRiotShield( owner, shield )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DepthInWater",
			"description": "Returns the depth (in inches) that the entity is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.",
			"calledOn": "entity",
			"parameters": [],
			"example": "depth = get_players()[0] DepthInWater()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DepthOfPlayerInWater",
			"description": "Returns the depth (in inches) that the player is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.  More effecient than depthinwater but will only work for players",
			"calledOn": "player",
			"parameters": [],
			"example": "depth = get_players()[0] DepthOfPlayerInWater()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Detach",
			"description": "detaches an attached model from an entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "modelname",
					"description": "The model name to detach (string)",
					"mandatory": true
				},
				{
					"name": "tagname",
					"description": "The tag to detach the model from (string)",
					"mandatory": false
				}
			],
			"example": "self Detach( \"explosivepack\", \"tag_weapon_right\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DetachAll",
			"description": "detaches all attached models from an entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self DetachAll()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DetachShieldModel",
			"description": "Detaches an attached shield model from a player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "modelname",
					"description": "The model name to detach (string)",
					"mandatory": true
				},
				{
					"name": "tagname",
					"description": "The tag to detach the model from (string)",
					"mandatory": false
				}
			],
			"example": "self DetachShieldModel( \"weapon_riot_shield\", \"tag_weapon_left\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Detonate",
			"description": "Detonate the entity and set the owner to the player which is specified.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "player",
					"description": "The player who owns the entity",
					"mandatory": false
				}
			],
			"example": "self Detonate( attacker )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DirectionalHitIndicator",
			"description": "Create a directional hit indicator",
			"calledOn": null,
			"parameters": [
				{
					"name": "victims0",
					"description": "A bit array of entities 0-31 that got hit",
					"mandatory": true
				},
				{
					"name": "victims1",
					"description": "A bit array of entities 32-63 that got hit",
					"mandatory": false
				}
			],
			"example": "attacker DirectionalHitIndicator( victimArray0, victimArray1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableAimAssist",
			"description": "Disables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.",
			"calledOn": "entity",
			"parameters": [],
			"example": "player DisableAimAssist()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableDestructiblePieces",
			"description": "Disables all destructible pieces that have this label set in the destructible gdt",
			"calledOn": null,
			"parameters": [
				{
					"name": "label",
					"description": "the name of the field listed in the destructible gdt to disable",
					"mandatory": true
				}
			],
			"example": "DisableDestructiblePieces( \"heavy_armor\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableGrenadeSuicide",
			"description": "Stops cooked grenades from killing the player.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableGrenadeTouchDamage",
			"description": "Resets the grenade touch damage flag of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self DisableGrenadeTouchDamage()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableOffhandSpecial",
			"description": "Disable the ability to activate a player's special offhand weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableOffhandSpecial()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableSpawnPointList",
			"description": "disables spawn point list for a the team_mask",
			"calledOn": null,
			"parameters": [
				{
					"name": "list",
					"description": "list to disable",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "teams that this command will affect",
					"mandatory": true
				}
			],
			"example": "DisableSpawnPointList()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisconnectPaths",
			"description": "Disconnects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to disconnect paths.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "detailLevel",
					"description": "how detailed the cut part matches the entity. 0 or omitted: box, 1: convex hull fitting rough shape, 2: [SUPER EXPENSIVE] use collision shape directly",
					"mandatory": false
				},
				{
					"name": "moveAllowed",
					"description": "sets whether the silhouette moves with the entity (defaults to true)",
					"mandatory": false
				}
			],
			"example": "level.ArmoredCar DisconnectPaths()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DoDamage",
			"description": "Does damage to this entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "health",
					"description": "The amount of damage to do",
					"mandatory": true
				},
				{
					"name": "source position",
					"description": "The position that the damage comes from",
					"mandatory": true
				},
				{
					"name": "attacker",
					"description": "The entity that dealt the damage (such as an AI or player)",
					"mandatory": false
				},
				{
					"name": "inflictor",
					"description": "The entity that the damage came from (such as a grenade or turret)",
					"mandatory": false
				},
				{
					"name": "hitloc",
					"description": "The location of the damage, default is none; one of: { 'none', 'torso_upper', 'torso_lower', 'helmet', 'head', 'neck', 'left_arm_upper', 'left_arm_lower', 'left_hand', 'right_arm_upper', 'right_arm_lower', 'right_hand', 'left_leg_upper', 'left_leg_lower', 'left_foot', 'right_leg_upper', 'right_leg_lower', 'right_foot' }",
					"mandatory": false
				},
				{
					"name": "mod",
					"description": ". The means of death string. Otherwise, the means of death will be 'MOD_UNKNOWN'.",
					"mandatory": false
				},
				{
					"name": "dflags",
					"description": ". Damage flags.",
					"mandatory": false
				},
				{
					"name": "weapon",
					"description": ". Weapon used.",
					"mandatory": false
				},
				{
					"name": "infdestructible_piece_indexlictor",
					"description": "The destructible piece index from the destructible def gdt\"",
					"mandatory": false
				},
				{
					"name": "forcePain",
					"description": "true/false; If true, actor->painDeath.iPainTime will be reset to zero\"",
					"mandatory": false
				}
			],
			"example": "player DoDamage(25, gasEffectArea.origin, player.lastPoisonedBy, grenade_obj, 0, \"MOD_EXPLOSIVE\", 0, GetWeapon(\"tabun_gas_mp\"), -1, false)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DoesWeaponReplaceSpawnWeapon",
			"description": "Returns true if the new weapon is an alt mode of the spawn weapon. Only certain alt variations are valid (not-gl)",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "if ( DoesWeaponReplaceSpawnWeapon( self.spawnWeapon, newWeapon ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DontInterpolate",
			"description": "pop the entity's position instantaneously to where it moves this time step, rather than smoothly moving there from the previous position",
			"calledOn": "entity",
			"parameters": [],
			"example": "entity DontInterpolate()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DoubleXPTimerFired",
			"description": "Used to decrement consumable double xp promotions",
			"calledOn": "player",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DrawNode",
			"description": "Draws a node",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "pathnode",
					"mandatory": true
				}
			],
			"example": "DrawNode( self.node)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DropNodEToFloor",
			"description": "Drop the node to the floor.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "node to drop",
					"mandatory": true
				}
			],
			"example": "DropNodeToFloor( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EACPathSet",
			"description": "Sets the value of a eac path drone.",
			"calledOn": null,
			"parameters": [
				{
					"name": "vec3",
					"description": "The value.",
					"mandatory": true
				}
			],
			"example": "SetEACPATH( origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Earthquake",
			"description": "Create an earthquake",
			"calledOn": null,
			"parameters": [
				{
					"name": "scale",
					"description": "scale of the earthquake. Must be greater than 0.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "The duration of the earthquake. Must be greater than 0.",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the earthquake. Must be greater than 0.",
					"mandatory": true
				},
				{
					"name": "target",
					"description": "Target is given if earthquake is to be shown to particular client",
					"mandatory": false
				}
			],
			"example": "Earthquake( 0.22, 7, player.origin, 150 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableAimAssist",
			"description": "Enables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.",
			"calledOn": "entity",
			"parameters": [],
			"example": "player EnableAimAssist()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableAllDestructiblePieces",
			"description": "Enables all destructible pieces that were previously disabled",
			"calledOn": null,
			"parameters": [],
			"example": "EnableAllDestructiblePieces()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableGrenadeSuicide",
			"description": "Enables cooked grenades killing the player.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableGrenadeTouchDamage",
			"description": "Sets the grenade touch damage flag of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self EnableGrenadeTouchDamage()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableInfluencer",
			"description": "Enables or disables the given influencer",
			"calledOn": null,
			"parameters": [
				{
					"name": "influencer id",
					"description": "The influencer to enable/disable",
					"mandatory": true
				},
				{
					"name": "enable",
					"description": "True to enable. False to disable",
					"mandatory": true
				}
			],
			"example": "EnableInfluencer( influencer_id, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableLinkTo",
			"description": "enables linkto for an entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self.bombtrigger EnableLinkTo()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableNavMeshTrigger",
			"description": "Enables/disables a given navmesh trigger",
			"calledOn": null,
			"parameters": [
				{
					"name": "targetname",
					"description": "The targetname of the trigger entity.",
					"mandatory": true
				},
				{
					"name": "enable",
					"description": "Whether to enable disable the given volume for pathfinding.",
					"mandatory": true
				}
			],
			"example": "EnableNavMeshTrigger( \"some_trigger\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableObstacle",
			"description": "Enables or disables the hkai obstacle associated with a given entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "enable",
					"description": "Whether to enable or disable the obstacle",
					"mandatory": true
				}
			],
			"example": "ent EnableObstacle( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableOffhandSpecial",
			"description": "Enable the ability to activate a player's special offhand weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableOffhandSpecial()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableSpawnPointList",
			"description": "enables spawn point list for a the team_mask",
			"calledOn": null,
			"parameters": [
				{
					"name": "list",
					"description": "list to enable",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "teams that this command will affect",
					"mandatory": true
				}
			],
			"example": "EnableSpawnPointList()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EndCamAnimScripted",
			"description": "Ends the camera script on a player.",
			"calledOn": "player",
			"parameters": [
				{}
			],
			"example": "EndCamAnimScripted( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EndExtraCamAnimScripted",
			"description": "Ends the extracam camera script on a player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player",
					"description": "The player to play animation on",
					"mandatory": true
				},
				{
					"name": "extra_cam_index",
					"description": "The extra camera index",
					"mandatory": true
				}
			],
			"example": "EndExtraCamAnimScripted( player, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ExitLevel",
			"description": "exits the current level",
			"calledOn": null,
			"parameters": [
				{
					"name": "save persistent",
					"description": "if true then player info is retained",
					"mandatory": false
				}
			],
			"example": "ExitLevel( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ExperimentsGetVariant",
			"description": "Gets the variant for a user for an experiment",
			"calledOn": null,
			"parameters": [],
			"example": "variant = player ExperimentsGetVariant( experimentName )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ExtraCamAnimScripted",
			"description": "Plays the camera script on an extracam player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player to play animation on",
					"mandatory": true
				},
				{
					"name": "extra_cam_index",
					"description": "The extra camera index",
					"mandatory": true
				},
				{
					"name": "cam_anim",
					"description": "The animation to play",
					"mandatory": true
				},
				{
					"name": "start_time",
					"description": "The start time of the animation",
					"mandatory": true
				},
				{
					"name": "align_origin",
					"description": "The origin to align to",
					"mandatory": true
				},
				{
					"name": "align_angles",
					"description": "The angles to align to",
					"mandatory": true
				},
				{
					"name": "lerp_duration",
					"description": "The lerp duration",
					"mandatory": false
				},
				{
					"name": "camera_name",
					"description": "The camera name",
					"mandatory": false
				},
				{
					"name": "ignoreProcessingInitialNoteTracks",
					"description": "Ignores processing the initial notetracks if the camera time starts earlier",
					"mandatory": false
				}
			],
			"example": "ExtraCamAnimScripted( player, 0, \"proto_melee_cam\", gettime(), origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FakeFire",
			"description": "Simulates gun fire.  Sound and radar blip.",
			"calledOn": null,
			"parameters": [
				{
					"name": "owner",
					"description": "The player who fakes fire",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "the origin of the fake fire",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon used",
					"mandatory": true
				},
				{
					"name": "shot count",
					"description": "Number of shots fired",
					"mandatory": true
				}
			],
			"example": "decoy FakeFire( player, position, \"turret_mp\", 20 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindAnimByName",
			"description": "Find specified animation( using animation name ) in a specified animtree( using atr name).",
			"calledOn": null,
			"parameters": [
				{
					"name": "tree",
					"description": "Anim tree name",
					"mandatory": true
				},
				{
					"name": "anim",
					"description": "Name of anim",
					"mandatory": true
				}
			],
			"example": "animnamehash = FindAnimByName(\"generic_human\", \"chicken_dance\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindPath",
			"description": "Check if a path can be found between these positions.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": ".",
					"mandatory": true
				},
				{
					"name": "end",
					"description": ".",
					"mandatory": true
				}
			],
			"example": "if ( self FindPath( self.origin, potentialpos ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FlashbackFinish",
			"description": "Finishes the flashback",
			"calledOn": null,
			"parameters": [],
			"example": "self FlashbackFinish()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FlashbackStart",
			"description": "Starts the flashback and returns the new origin",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon in the player loadout.",
					"mandatory": true
				}
			],
			"example": "newpos = self FlashbackStart( <weapon> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForcePainOn",
			"description": "toggles pain.forcePain to true;  next damage reaction guarenteed",
			"calledOn": "entity",
			"parameters": [],
			"example": "ai ForcePainOn()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FXBlockSight",
			"description": "Uses a general entity and a radius to set a line of sight blocker on the server for some AI. Destroyed when the entity is freed.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "the entity to use for the origin for tje line of sight blocker",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "the radius of the 'smoke screen' blocker",
					"mandatory": true
				}
			],
			"example": "FXBlockSight( fxent, 64 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetActivate",
			"description": "turns gadget on in slot.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to activate. (integer)",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The gadget weapon",
					"mandatory": true
				}
			],
			"example": "self GadgetActivate( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetCharging",
			"description": "Sets the gadget charging state.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot. (integer)",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "undefined to get current state, true to set or false to unset. (boolean)",
					"mandatory": false
				}
			],
			"example": "self GadgetCharging( slot, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetDeactivate",
			"description": "turns gadget off in slot.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to deactivate. (integer)",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The gadget weapon",
					"mandatory": true
				},
				{
					"name": "penalty",
					"description": "The power penalty type",
					"mandatory": false
				}
			],
			"example": "self GadgetDeactivate( slot, weapon, GADGET_OFF_PENALTY_SHUT_OFF )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetFlickering",
			"description": "Tests a gadget is flickering and can optionally set flickering.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to test or apply flickering state. (integer)",
					"mandatory": true
				},
				{
					"name": "flicker",
					"description": "Set gadget to flickering state if true (boolean)",
					"mandatory": false
				},
				{
					"name": "length",
					"description": "Set gadget flickering length (integer)",
					"mandatory": false
				}
			],
			"example": "self GadgetFlickering( slot, true, 200 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetGetSlot",
			"description": "Get gadget slot for weapon.",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon in the player loadout.",
					"mandatory": true
				}
			],
			"example": "self GadgetGetSlot( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetIsActive",
			"description": "Returns true if the gadget is active.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to test. (integer)",
					"mandatory": true
				}
			],
			"example": "self GadgetIsActive( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetIsPrimed",
			"description": "Returns true if the gadget is primed.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to test. (integer)",
					"mandatory": true
				}
			],
			"example": "self GadgetIsPrimed( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetIsReady",
			"description": "Returns true if the gadget is ready.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to test. (integer)",
					"mandatory": true
				}
			],
			"example": "self GadgetIsReady( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetPowerChange",
			"description": "Applies a power change to the gadget power.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot apply the power change. (integer)",
					"mandatory": true
				},
				{
					"name": "change",
					"description": "The amount to change the power by. (float)",
					"mandatory": true
				}
			],
			"example": "self GadgetPowerChange( slot, -20 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetPowerGet",
			"description": "Gets the power remaining for gadget.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot (integer)",
					"mandatory": true
				}
			],
			"example": "power = self GadgetPowerGet( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetPowerReset",
			"description": "Applies a power reset.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot apply the power reset. (integer)",
					"mandatory": true
				}
			],
			"example": "self GadgetPowerReset( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetPowerSet",
			"description": "Sets the power override to value. Works always.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot apply the power change. (integer)",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The amount to set power to. (float)",
					"mandatory": true
				}
			],
			"example": "self GadgetPowerSet( slot, 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetSetActivateTime",
			"description": "Set the activation time of this gadget.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot. (integer)",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The activation time. (integer)",
					"mandatory": true
				}
			],
			"example": "self GadgetSetActivateTime( slot, time )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetSetEntity",
			"description": "Set the entity used by this gadget.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot.",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "The entity used by the gadget.",
					"mandatory": true
				}
			],
			"example": "self GadgetSetEntity( slot, ent )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetStateChange",
			"description": "changes the gadget state in a slot.",
			"calledOn": null,
			"parameters": [
				{
					"name": "slot",
					"description": "The gadget slot to activate. (integer)",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The gadget weapon",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "The state to change it to",
					"mandatory": true
				}
			],
			"example": "self GadgetStateChange( slot )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GadgetTargetResult",
			"calledOn": null,
			"parameters": [
				{
					"name": "hit_miss",
					"description": "hit or miss",
					"mandatory": true
				}
			],
			"example": "GadgetTargetResult(true)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GameModeIsMode",
			"description": "Returns true/false if the current game mode is the given mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "gamemode",
					"description": "(int)",
					"mandatory": true
				}
			],
			"example": "if ( GameModeIsMode( level.GAMEMODE_WAGER_MATCH ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GeneratePointsAroundCenter",
			"description": "generate uniformly distributed points around a center in 2D (XY) plane",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Position to start the search around.",
					"mandatory": true
				},
				{
					"name": "maxSearchRadius",
					"description": "the maximum radius away from origin.",
					"mandatory": true
				},
				{
					"name": "innerSpacing",
					"description": "the distance between points at the minRadius.",
					"mandatory": true
				},
				{
					"name": "minRadius",
					"description": "the minimum radius away from origin. should be between 0 and maxRadius (both inclusive).",
					"mandatory": false
				},
				{
					"name": "outerSpacing",
					"description": "if defined, the distance between points will be Lerped from <innerSpacing> to [outerSpacing], to create a gradual distribution from minRadius to maxRadius.",
					"mandatory": false
				},
				{
					"name": "distributionBias",
					"description": "(vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.",
					"mandatory": false
				}
			],
			"example": "array = GeneratePointsAroundCenter( enemy.origin, 500, 80, 100, 40, (-0.3,0,0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GenerateScriptEvent",
			"description": "Creates a script event at the actor's origin, with default radius",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "origin",
					"description": "Source position of the event.",
					"mandatory": false
				},
				{
					"name": "radius",
					"description": "Size of the event.",
					"mandatory": false
				},
				{
					"name": "name",
					"description": "Name of the event.",
					"mandatory": false
				}
			],
			"example": "self GenerateScriptEvent()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAbsMaxs",
			"description": "Get absolute maximum bounds of the entity in world space.",
			"calledOn": "entity",
			"parameters": [],
			"example": "absMaxs = wallModel GetAbsMaxs()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAbsMins",
			"description": "Get absolute minimum bounds of the entity in world space.",
			"calledOn": "entity",
			"parameters": [],
			"example": "absMins = wallModel GetAbsMins()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorArray",
			"description": "Returns an array of the human AI",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "aiarray = GetActorArray( \"ralph\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorSpawnerArray",
			"description": "Returns an array of all of the actor spawners in a level.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "spawners = GetSpawnerArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorSpawnerTeamArray",
			"description": "Returns an array of all of the spawners in a level",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', or 'neutral'",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of additional team names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "enemies = GetActorSpawnerTeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorTeamArray",
			"description": "Returns an array of the human AI",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', or 'neutral'",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of additional team names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "aiarray = GetActorTeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorTeamCountRadius",
			"description": "Returns number of human actor AI within a sphere on a given set of teams",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Center of sphere",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "Radius of sphere",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of team names may be added, either 'axis', 'allies', or 'neutral' (no team implies all teams)",
					"mandatory": false
				}
			],
			"example": "nearbyOthersCount = GetActorTeamCountRadius( self.origin, 500, \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetActorWeaponOptions",
			"description": "Return's the actors current weapon options, ex: weapon camo option.",
			"calledOn": "entity",
			"parameters": [],
			"example": "self GetActorWeaponOptions()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAIArchetypeArray",
			"description": "Returns an array of the AI for the given archetype and optionally given team",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.",
					"mandatory": false
				}
			],
			"example": "aiarray = GetAIArchetypeArray( \"human\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAIArray",
			"description": "Returns an array of the human AI",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "aiarray = GetAIArray( \"my_ai\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAICount",
			"description": "Returns the current ai count.",
			"calledOn": null,
			"parameters": [],
			"example": "aicount = GetAICount()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAILimit",
			"description": "Returns the max ai count set by script.",
			"calledOn": null,
			"parameters": [],
			"example": "ailimit = GetAILimit()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAimAngles",
			"description": "Returns an array with the angles of the aimTag and the relative aiming delta angles from this orientation.",
			"calledOn": "entity",
			"parameters": [
				{},
				{},
				{},
				{},
				{},
				{},
				{}
			],
			"example": "aim_angles = ent GetAimAngles( shootPos, \"tag_aim\", (0, 30, 0), (15, 10, 0), (60, 60, 0), (5, 5, 0), 11 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAISpeciesArray",
			"description": "Returns an array of the AI",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.",
					"mandatory": false
				},
				{
					"name": "species",
					"description": "species of AI to get, 'human', 'dog', 'robot' or 'all'. Defaults to 'human'.",
					"mandatory": false
				}
			],
			"example": "aiarray = GetAISpeciesArray( \"axis\", \"all\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAITeamArray",
			"description": "Returns an array of the human AI and vehicle AI",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', or 'neutral'",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of additional team names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "aiarray = GetAITeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAITriggerFlags",
			"description": "Returns the spawn flags that will allow AI to activate triggers",
			"calledOn": null,
			"parameters": [],
			"example": "spawn(\"trigger_radius\", (0,0,0), GetAITriggerFlags())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAllCharacterBodies",
			"description": "Returns all character indices, even disabled ones, for the current session mode (or specified session mode)",
			"calledOn": null,
			"parameters": [
				{
					"name": "sessionMode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroIndices = GetAllCharacterBodies()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAllCharacterHeads",
			"description": "Returns all character indices, even disabled ones, for the current session mode (or specified session mode)",
			"calledOn": null,
			"parameters": [
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroIndices = GetAllCharacterHeads()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAllNodes",
			"description": "Gets all of the nodes in a level",
			"calledOn": null,
			"parameters": [],
			"example": "nodes = GetAllNodes()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAmmoCount",
			"description": "Returns the count of ammo left",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon for which we need ammo count",
					"mandatory": true
				}
			],
			"example": "n_ammo = self GetAmmoCount( w_weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAngleDelta",
			"description": "Get the angle delta of the animation",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation name",
					"description": "Name of the animation",
					"mandatory": true
				},
				{
					"name": "start time",
					"description": "Start time of the animation",
					"mandatory": false
				},
				{
					"name": "end time",
					"description": "End time of the animation",
					"mandatory": false
				}
			],
			"example": "angleDelta = getAngleDelta( arrivalAnim, 0, normalizedLength )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAngleFromBits",
			"description": "Gets the angle (0 - 360) from the (compressed) bits",
			"calledOn": null,
			"parameters": [],
			"example": "yaw = GetAngleFromBits( bits, 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAngles",
			"description": "Get the rotation of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "angles = self GetAngles()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnimForCharacter",
			"description": "Returns the name of the animation to use for the character pose in the frontend",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "frontendVignetteAnim = GetAnimForCharacter( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnimFrameCount",
			"description": "Get total number of frames for the given animation.",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "a primitive animation: calling this function on a non-primitive animation will fail",
					"mandatory": true
				}
			],
			"example": "FrameNum = GetAnimFrameCount(climbAnim)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnimLength",
			"description": "Gets the length of an animation",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "a primitive animation: calling this function on a non-primitive animation will fail",
					"mandatory": true
				}
			],
			"example": "cycleTime = GetAnimLength( climbAnim )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnimTagOrigin",
			"description": "Returns the local tag position within the animation at the specified normalized time, has no consideration to bone hierarchy.",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation name",
					"description": "Name of the animation.",
					"mandatory": true
				},
				{
					"name": "normalized time",
					"description": "0.0 to 1.0 time within the animation.",
					"mandatory": true
				},
				{
					"name": "tag name",
					"description": "Name of the tag to look up within the animation.",
					"mandatory": true
				}
			],
			"example": "tagPosition = GetAnimTagOrigin( arrivalAnim, 0, \"tag_sync\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnimTime",
			"description": "Get the normalized animation time for the given animation.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "animation to manipulate",
					"mandatory": true
				}
			],
			"example": "if ( (self GetAnimTime( %walk_and_run_loops ) ) < 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAnyNodeArray",
			"description": "Gets an array of nodes within given radius",
			"calledOn": null,
			"parameters": [
				{
					"name": "pos",
					"description": "search origin",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "radius to search within",
					"mandatory": true
				}
			],
			"example": "node = GetCoverNodeArray( self.origin, 256 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetArchetypeFromClassname",
			"description": "Given classname, returns archetype name if its an AITYPE or VEHICLE.",
			"calledOn": null,
			"parameters": [],
			"example": "GetArchetypeFromClassname(\"spawner_enemy_54i_human_sniper_sniperrifle\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAssignedTeam",
			"description": "returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player",
					"mandatory": true
				}
			],
			"example": "team = GetAssignedTeam( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAssignedTeamName",
			"description": "returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player",
					"mandatory": true
				}
			],
			"example": "team = GetAssignedTeam( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAtrLoaded",
			"description": "return an array of anim tree name loaded onto the server.",
			"calledOn": null,
			"parameters": [],
			"example": "trees = GetAtrLoaded()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachIgnoreCollision",
			"description": "Returns the ignore collision flag of the attached model at the given attachment slot",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "modelindex",
					"description": "The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)",
					"mandatory": true
				}
			],
			"example": "model_ignore_collision = self GetAttachIgnoreCollision( index )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachmentCosmeticVariantForWeapon",
			"description": "Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				},
				{
					"name": "loadoutSlot",
					"description": "Loadout Slot (primary or secondary)",
					"mandatory": true
				}
			],
			"example": "acvi = self GetAttachmentCosmeticVariantForWeapon( class_num, \"primary\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachmentCosmeticVariantIndexes",
			"description": "Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponname",
					"description": "the name of the base weapon to return",
					"mandatory": true
				},
				{
					"name": "attachmentname_1",
					"description": "the name of the first attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_1",
					"description": "the index of the cosmetic variant to use for the first attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_2",
					"description": "the name of the second attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_2",
					"description": "the index of the cosmetic variant to use for the second attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_3",
					"description": "the name of the third attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_3",
					"description": "the index of the cosmetic variant to use for the third attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_4",
					"description": "the name of the fourth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_4",
					"description": "the index of the cosmetic variant to use for the fourth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_5",
					"description": "the name of the fifth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_5",
					"description": "the index of the cosmetic variant to use for the fifth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_6",
					"description": "the name of the sixth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_6",
					"description": "the index of the cosmetic variant to use for the sixth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_7",
					"description": "the name of the seventh attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_7",
					"description": "the index of the cosmetic variant to use for the seventh attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_8",
					"description": "the name of the eighth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_8",
					"description": "the index of the cosmetic variant to use for the eighth attachment",
					"mandatory": false
				}
			],
			"example": "GetAttachmentCosmeticVariantIndexes( \"mp7_mp\", \"acog\", 2, \"grip\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachmentNames",
			"description": "Returns array containing the names for each type of attachment.",
			"calledOn": null,
			"parameters": [],
			"example": "attachmentNames = GetAttachmentNames()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachModelName",
			"description": "Returns the name of the attached model at the given attachment slot",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "modelindex",
					"description": "The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)",
					"mandatory": true
				}
			],
			"example": "model_name = self GetAttachModelName( index )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachSize",
			"description": "Returns the number of attached models for this entity.",
			"calledOn": "entity",
			"parameters": [],
			"example": "size = self GetAttachSize()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachTagName",
			"description": "Returns the tagname of the attached model at the given attachment slot",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "modelindex",
					"description": "The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)",
					"mandatory": true
				}
			],
			"example": "tag_name = self GetAttachTagName( index )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBaseWeaponItemIndex",
			"description": "Returns the base weapon item index from the statstable",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponName",
					"description": "full weapon name e.g. m16_acog_mp.",
					"mandatory": true
				}
			],
			"example": "baseWeaponName = GetBaseWeaponItemIndex( \"m16_acog_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBestInfluencepos",
			"description": "returns the influence map position for ai, this is custom logic to return the closest posistion between the passed in thresholds",
			"calledOn": "ai",
			"parameters": [
				{
					"name": "index",
					"description": "which influence map to use",
					"mandatory": true
				},
				{
					"name": "low",
					"description": "the low threshold value to check against",
					"mandatory": true
				},
				{
					"name": "high",
					"description": "the high threshold value to check against",
					"mandatory": true
				}
			],
			"example": "dir = self GetBestInfluencePos( index, low, high)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBestSpawnPoint",
			"description": "Returns a sorted array of spawnpoints in order from best to worst for the given team",
			"calledOn": null,
			"parameters": [
				{
					"name": "point team",
					"description": "Team that we need the points for",
					"mandatory": true
				},
				{
					"name": "influencer team",
					"description": "Influencer teams to compare the points against",
					"mandatory": true
				},
				{
					"name": "vis team",
					"description": "Team mask to use for enemy vis tests",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "Player that we want the points for.  The first parameter will still be used for the team.",
					"mandatory": false
				},
				{
					"name": "predictedSpawn",
					"description": "true if this is a predicted spawn request (used by texture streaming).",
					"mandatory": false
				},
				{
					"name": "array of lists",
					"description": "if provided, the spawn point will be chosen from one of these lists. If a list is disabled already for a given team, it will not be considered.",
					"mandatory": false
				}
			],
			"example": "GetSortedSpawnPoints()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBitsForAngle",
			"description": "Gets the compressed bits for an angle with <num bits> granularity",
			"calledOn": null,
			"parameters": [],
			"example": "bits = GetBitsForAngle( angle, 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBrushModelCenter",
			"description": "Get the center of the Brush Model entity",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The brush model entity",
					"mandatory": true
				}
			],
			"example": "center = GetBrushModelCenter( self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBuildKitAttachmentCosmeticVariantIndexes",
			"description": "Get attachment cosmetic variant indexes for the weapon from the player's build kit",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon object",
					"mandatory": true
				},
				{
					"name": "upgraded",
					"description": "bool whether this should be the upgraded version. If so extclip and fmj will be added",
					"mandatory": false
				}
			],
			"example": "acvi = self GetBuildKitAttachmentCosmeticVariantIndexes( ar_standard )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBuildKitWeapon",
			"description": "Get weapon object (including attachments) for the weapon from the player's build kit",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon object",
					"mandatory": true
				},
				{
					"name": "upgraded",
					"description": "bool whether this should be the upgraded version. If so extclip and fmj will be added",
					"mandatory": false
				}
			],
			"example": "weapon = self GetBuildKitWeapon( ar_standard )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBuildKitWeaponOptions",
			"description": "Get weapon options for the weapon from the player's build kit",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon object",
					"mandatory": true
				},
				{
					"name": "camo_index",
					"description": "camo index to override the one from the build kit, typically a packapunch camo index",
					"mandatory": false
				}
			],
			"example": "weapon_options = self GetBuildKitWeaponOptions( ar_standard, packapunch_camo_index )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCamAnimTime",
			"description": "Gets the duration of an xcam in milliseconds.",
			"calledOn": null,
			"parameters": [
				{
					"name": "cam_anim",
					"description": "The animation to play",
					"mandatory": true
				}
			],
			"example": "GetCamAnimTime( \"proto_melee_cam\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCentroid",
			"description": "Gets the centroid of an entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "centroid = self GetCentroid()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterAssetName",
			"description": "Returns the asset name for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroName = GetCharacterAssetName( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyModelColorCount",
			"description": "Returns the body model count for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "bodyStyleIndex",
					"description": "The index of the body style in the character",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyModelCount",
			"description": "Returns the body model count for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionMode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyStyleIndex",
			"description": "Returns the index of the body style designated by the given display name",
			"calledOn": null,
			"parameters": [
				{
					"name": "gender",
					"description": "Whether or not to use the male bodytype",
					"mandatory": true
				},
				{
					"name": "bodyStyleDisplayName",
					"description": "The name of the body style",
					"mandatory": true
				}
			],
			"example": "bodyStyleIndex = GetCharacterBodyStyleIndex( true, \"Technomancer\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterDisplayName",
			"description": "Returns the display name for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroName = GetCharacterDisplayName( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterFields",
			"description": "Returns info for the character pose playerbodytype",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroFields = GetCharacterFields( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHeadRenderOptions",
			"description": "Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()",
			"calledOn": null,
			"parameters": [
				{
					"name": "headIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				}
			],
			"example": "helmetRenderOptions = GetCharacterHeadRenderOptions( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHelmetHidesHead",
			"description": "Returns whether or not the characters head should be hidden based on the helmet",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "helmetIndex",
					"description": "The index of the helmet belonging to that character",
					"mandatory": true
				},
				{
					"name": "sessionMode",
					"description": "The session mode ( mp cp zm )",
					"mandatory": true
				}
			],
			"example": "hideHead = GetCharacterHelmetHidesHead( 0, 0, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHelmetModelColorCount",
			"description": "Returns the helmet model count for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "helmetStyleIndex",
					"description": "The index of the helmet style in the character",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHelmetModelCount",
			"description": "Returns the helmet model count for a character for the current session mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHelmetRenderOptions",
			"description": "Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "helmetIndex",
					"description": "The index of the helmet belonging to that character",
					"mandatory": true
				},
				{
					"name": "colorIndex1",
					"description": "The index of accent color 1",
					"mandatory": true
				},
				{
					"name": "colorIndex2",
					"description": "The index of accent color 2",
					"mandatory": true
				},
				{
					"name": "colorIndex3",
					"description": "The index of accent color 3",
					"mandatory": true
				}
			],
			"example": "helmetRenderOptions = GetCharacterHelmetRenderOptions( 0, 1, 1, 2, 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterModeRenderOptions",
			"description": "Calculates the packed mode render option - to be passed to SetBodyRenderOptions()",
			"calledOn": null,
			"parameters": [
				{
					"name": "session_mode",
					"description": "Session Mode enum index",
					"mandatory": true
				}
			],
			"example": "modeRenderOptions = GetCharacterModeRenderOptions( SESSIONMODE_MULTIPLAYER )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetClassIndexFromName",
			"description": "Gets the index in a particular class",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "GScr_GetClassIndexFromName( \"CLASS_SMG\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetClientFieldVersion",
			"description": "Returns the version of the specifiec client field, in the specified client field set - or 0 if the field isn't registered.",
			"calledOn": null,
			"parameters": [],
			"example": "if(GetClientFieldVersion( \"world\", \"fog_volume_active\" ))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetClosestPointOnNavMesh",
			"description": "Get a point on NavMesh that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found. If distFromBoundary is defined, the point found on NavMesh will then be moved again to get it away from boundary",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position to start the search around.",
					"mandatory": true
				},
				{
					"name": "searchRadius",
					"description": "Radius to search within. If not provided, a default value proximately equal to player size will be used.",
					"mandatory": false
				},
				{
					"name": "distFromBoundary",
					"description": "Distance to keep away from NavMesh boundary. This distance can NOT be guaranteed. If not provided, it will be treated as 15 (AI default radius).",
					"mandatory": false
				},
				{
					"name": "materialFlags",
					"description": "the flags marking whether a face type can be used",
					"mandatory": false
				}
			],
			"example": "posOnNavMesh = GetClosestPointOnNavMesh( (10,20,30), 25, 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetClosestPointOnNavVolume",
			"description": "Get a point on nav volume that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found.",
			"calledOn": "flying_ai",
			"parameters": [
				{
					"name": "position",
					"description": "Position to start the search around.",
					"mandatory": true
				},
				{
					"name": "searchRadius",
					"description": "Radius to search within. If not provided, a default value proximately equal to player size will be used.",
					"mandatory": false
				}
			],
			"example": "posOnNavVolume = self GetClosestPointOnNavVolume( (10,20,30), 25 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetContractName",
			"description": "Gets the name of the specified contract",
			"calledOn": null,
			"parameters": [
				{
					"name": "contractIndex",
					"description": "Contract ID",
					"mandatory": true
				}
			],
			"example": "contractName = GetContractName( contractIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetContractRequiredCount",
			"description": "Gets the required count for the specified contract",
			"calledOn": null,
			"parameters": [
				{
					"name": "contractIndex",
					"description": "Contract ID",
					"mandatory": true
				}
			],
			"example": "contractName = GetContractRequiredCount( contractIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetContractRequirements",
			"description": "Returns an array of contract requirements. Each requirement takes up two indices, 'reqType' and 'reqData'.",
			"calledOn": null,
			"parameters": [
				{
					"name": "contractIndex",
					"description": "The index of the contract",
					"mandatory": true
				}
			],
			"example": "mapNames = GetContractRequirements( contractIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetContractResetConditions",
			"description": "Gets the reset conditions of the specified contract",
			"calledOn": null,
			"parameters": [
				{
					"name": "contractIndex",
					"description": "Contract ID",
					"mandatory": true
				}
			],
			"example": "resetConditions = GetContractResetConditions( contractIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetControllerType",
			"description": "returns the controller type of the player",
			"calledOn": null,
			"parameters": [],
			"example": "player GetControllerType()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCorpseAnim",
			"description": "Get the animation that the corpse will play",
			"calledOn": "player",
			"parameters": [],
			"example": "deathAnim = self GetCorpseAnim()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCorpseArray",
			"description": "Returns an array of all of the items in a level.",
			"calledOn": null,
			"parameters": [],
			"example": "origins = GetCorpseArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCounterTotal",
			"description": "Gets the counter count for the given counter",
			"calledOn": null,
			"parameters": [
				{
					"name": "counterType",
					"description": "The counter type",
					"mandatory": true
				}
			],
			"example": "count = GetCounterTotal( \"global_comebacks\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCoverNodeArray",
			"description": "Gets an array of cover nodes within given radius",
			"calledOn": null,
			"parameters": [
				{
					"name": "pos",
					"description": "search origin",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "radius to search within",
					"mandatory": true
				}
			],
			"example": "node = GetCoverNodeArray( self.origin, 256 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCrateHeadObjective",
			"description": "Returns the equipment head objective as described in the grenadeweapon gdt.",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "crateObjective = GetCrateHeadObjective( uav )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentEventId",
			"description": "Gets the id from the current event.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "eventId = self GetCurrentEventId()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentEventName",
			"description": "Gets the name of the current event.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "eventId = self GetCurrentEventName()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentEventOriginator",
			"description": "Gets the originator from the current event if any",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "target = self GetCurrentEventOriginator()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentEventType",
			"description": "Gets the type from the current event.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "type = self GetCurrentEventType()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentEventTypeName",
			"description": "Gets the type string name from the current event.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "type = self GetCurrentEventTypeName()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentGunRank",
			"description": "Get the gun current rank",
			"calledOn": "player",
			"parameters": [
				{
					"name": "index",
					"description": "the index of the gun to get",
					"mandatory": true
				}
			],
			"example": "rank - GetCurrentGunRank(0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCustomTeamName",
			"description": "Get the team name",
			"calledOn": null,
			"parameters": [
				{
					"name": "teamid",
					"description": "TeamID",
					"mandatory": true
				}
			],
			"example": "name = GetCustomTeamName( teamid )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCyberComAbilityName",
			"description": "Gets the cybercom ability name given the flag, type",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag",
					"description": "flag field",
					"mandatory": true
				}
			],
			"example": "GetCyberComAbilityName(  flag, type )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCyberComWeapon",
			"description": "Gets the cybercom gadget weapon given the flag, type, and if upgraded",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag",
					"description": "flag field",
					"mandatory": true
				},
				{
					"name": "type",
					"description": "type of weapon",
					"mandatory": true
				},
				{
					"name": "upgraded",
					"description": "true if the weapon is upgraded",
					"mandatory": true
				}
			],
			"example": "GetCyberComWeapon(  flag, type, upgraded )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDamageableEntArray",
			"description": "Returns the entities that can be damaged. Can optionally take an origin, radius, and a flag to check 3D.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "origin to check against",
					"mandatory": false
				},
				{
					"name": "radius",
					"description": "max distance to origin",
					"mandatory": false
				},
				{
					"name": "checkZ",
					"description": "if true then check distance in 3d",
					"mandatory": false
				}
			],
			"example": "entities = GetDamageableEntArray( maxDist, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDebugEye",
			"description": "Gets the debug position of the eye for an AI or Player",
			"calledOn": "player or actor",
			"parameters": [],
			"example": "eyePos = player GetDebugEye()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDecorations",
			"description": "Gets an array of booleans that represents all the decorations the player has earned",
			"calledOn": "player",
			"parameters": [
				{
					"name": " only_decorations_earned ",
					"description": "Only get the decorations that the player has earned",
					"mandatory": false
				}
			],
			"example": "medals = e_player GetDecorationsEarned()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDefaultClassSlot",
			"description": "Gets the item in a particular default class slot",
			"calledOn": null,
			"parameters": [
				{
					"name": "classname",
					"description": "the classname of the item",
					"mandatory": true
				},
				{
					"name": "slotname",
					"description": "The slot to check",
					"mandatory": true
				}
			],
			"example": "GetDefaultClassSlot( \"cqb\", \"primary\" ); // Returns primary weapon reference",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDroppedWeapons",
			"description": "Returns an array containing all the dropped weapons in the level",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEnemies",
			"description": "Returns an array of enemies.",
			"calledOn": "entity",
			"parameters": [],
			"example": "enemies = self GetEnemies()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEnt",
			"description": "Looks up entities by key and name",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": true
				},
				{
					"name": "ignore spawners",
					"description": "if true then you won't get a spawner back",
					"mandatory": false
				}
			],
			"example": "spawner = GetEnt( \"doorguy1\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntArray",
			"description": "Looks up entities by key and name and a return an array of the matched entities",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": false
				},
				{
					"name": "ignore spawners",
					"description": "if true then you won't get a spawner back",
					"mandatory": false
				}
			],
			"example": "spawners = GetEntArray( \"doorguy1\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntArrayFromArray",
			"description": "Searches given array entities by key and name and a return an array of the matched entities",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array of entities",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": true
				}
			],
			"example": "spawners = GetEntArrayFromArray( array, \"doorguy1\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntByNum",
			"description": "Gets an entity from its entity number",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity number",
					"description": "(integer) The number of the entity to get",
					"mandatory": true
				}
			],
			"example": "entity = GetEntByNum( entnum )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getEnterButton",
			"description": "Gets the enter button.",
			"calledOn": null,
			"parameters": [],
			"example": "getEnterButton()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntityAnimRate",
			"description": "get the entity animation rate - ZOMBIES ONLY",
			"calledOn": "entity",
			"parameters": [],
			"example": "rate = self GetEntityAnimRate()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntityNumber",
			"description": "Get the entity number of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "hitEntNum = hitEnt getEntityNumber()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntityType",
			"description": "Get the type of entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "inflictorEntType = grenade getEntityType()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntNavMaterial",
			"description": "get NavMesh material at where the entity stands",
			"calledOn": null,
			"parameters": [
				{
					"name": "ai_or_vehicle",
					"description": "An AI character or an AI vehicle",
					"mandatory": true
				}
			],
			"example": "material = GetEntNavMaterial( ai_actor )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEntNum",
			"description": "Get the entity number for this entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self GetEntNum()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEquipmentHeadObjective",
			"description": "Returns the equipment head objective as described in the grenadeweapon gdt.",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "headObjective = GetEquipmentHeadObjective( bouncingbettty )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEventPointOfInterest",
			"description": "Gets the point of interest from the current event.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "point = self GetEventPointOfInterest()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEye",
			"description": "Get the eye position of the entity.",
			"calledOn": "entity",
			"parameters": [],
			"example": "eye_pos = self GetEye()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEyeApprox",
			"description": "Get the eye position of the entity with some added offset.",
			"calledOn": "entity",
			"parameters": [],
			"example": "approx_eye_pos = self GetEyeGetEyeApprox()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFirstTouchFraction",
			"description": "Returns the trace fraction of a capsule trace against the other entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "other entity",
					"description": "Entity to check against",
					"mandatory": true
				},
				{
					"name": "start",
					"description": "Starting point of the trace",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "Ending point of the trace",
					"mandatory": true
				}
			],
			"example": "fraction = GetFirstTouchFraction( player, trigger, old_origin, current_origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFlowGraphDef",
			"description": "returns a struct representing the flow graph definition asset",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "The name of the flow graph asset",
					"mandatory": true
				}
			],
			"example": "flowGraphDef = GetFlowGraphDef( \"my_flow_graph\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFogSettings",
			"description": "Get the current fog settings as an array.",
			"calledOn": null,
			"parameters": [],
			"example": "fogsettings = getfogsettings()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFreeActorCount",
			"description": "Get number of free actors.",
			"calledOn": null,
			"parameters": [],
			"example": "GetFreeActorCount()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFreerunTrackIndex",
			"description": "Returns the unique id for this mission",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.index = GetFreerunTrackIndex( \"mp_Freerun_01\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGameTypeEnumFromName",
			"description": "Returns the enum value corresponding to the current game type from global leaderboard gametype entries.",
			"calledOn": null,
			"parameters": [
				{
					"name": "gameTypeName",
					"description": "game type name e.g. \"tdm\".",
					"mandatory": true
				},
				{
					"name": "isHardcore",
					"description": "True if the hardcore mode is on",
					"mandatory": true
				}
			],
			"example": "gameTypeEnum = GetGameTypeEnumFromName( \"tdm\", false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGametypeSetting",
			"description": "Gets the value of a gametype setting.",
			"calledOn": null,
			"parameters": [
				{
					"name": "setting",
					"description": "The setting name as a string.",
					"mandatory": true
				}
			],
			"example": "GetGametypeSetting( \"scoreLimit\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGrappleTargetArray",
			"description": "Returns an array of all of the grapple targets",
			"calledOn": null,
			"parameters": [],
			"example": "enemies = GetGrappleTargetArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGroundEnt",
			"description": "Gets the entity beneath the calling entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "ground_ent = self GetGroundEnt()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInfluenceAt",
			"description": "Returns the influence value at the origin position on the influence map, undefined if no value can be found.",
			"calledOn": null,
			"parameters": [
				{
					"name": "influenceMapIndex",
					"description": "Index of the influence map",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The location to check for influence value",
					"mandatory": true
				}
			],
			"example": "GetInfluenceAt(influenceMapIndex, origin)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInfluenceFacePos",
			"description": "Returns the faces pos on the influence map",
			"calledOn": null,
			"parameters": [],
			"example": "pos = GetInfluenceFacePos( faceIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInfluenceNumFaces",
			"description": "Returns the number faces on the influence",
			"calledOn": null,
			"parameters": [],
			"example": "numFaces = GetInfluenceNumFaces()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInfluencerPreset",
			"description": "Adds a new influencer of <name> at <origin> and <angles>",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "valid spawn influencer preset name.",
					"mandatory": true
				}
			],
			"example": "preset_array = GetInfluencerPreset( name )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInfluencerTimeoutRemaining",
			"description": "Gets the remaining influencer timeout in milliseconds.  Returns a negative number if no timeout.",
			"calledOn": null,
			"parameters": [
				{
					"name": "influencer id",
					"description": "The influencer id",
					"mandatory": true
				}
			],
			"example": "GetInfluencerTimeout( influencer_id )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInterestPoolAwareness",
			"description": "Gets the current interest pool awareness level regardless of actual awareness level.",
			"calledOn": "ai",
			"parameters": [],
			"example": "interestAwareness = self GetInterestPoolAwareness()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInterestPoolValue",
			"description": "Gets the sentient's interest pool value.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "value = self GetInterestPoolValue()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetItemArray",
			"description": "Returns an array of all of the items in a level.",
			"calledOn": null,
			"parameters": [],
			"example": "origins = GetItemArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetItemAttachment",
			"description": "Gets the attachment for a particular item",
			"calledOn": null,
			"parameters": [
				{
					"name": "itemIndex",
					"description": "The item index",
					"mandatory": true
				},
				{
					"name": "attachmentNum",
					"description": "The attachment number for the index",
					"mandatory": true
				}
			],
			"example": "GetItemAttachment( 10, 1 ); // returns attachment 1 for item 10",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetItemAttachmentAllocationCost",
			"description": "Gets the allocation cost of an attachment for a particular item",
			"calledOn": null,
			"parameters": [
				{
					"name": "itemIndex",
					"description": "The item index",
					"mandatory": true
				},
				{
					"name": "attachmentNum",
					"description": "The attachment number for the index",
					"mandatory": true
				}
			],
			"example": "GetItemAttachmentAllocationCost( 10, 1 ); // returns allocation cost of attachment 1 for item 10",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetItemGroupFromItemIndex",
			"description": "Returns the ref for a specified item index",
			"calledOn": null,
			"parameters": [
				{
					"name": "itemIndex",
					"description": "Item index",
					"mandatory": true
				}
			],
			"example": "ref = GetItemGroupFromItemIndex( itemIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLastOutWaterTime",
			"description": "Returns the last time the player was not completely submerged",
			"calledOn": "player",
			"parameters": [],
			"example": "time = player GetLastOutWaterTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightColor",
			"description": "Gets the current color of the light, as an RGB vector.",
			"calledOn": "light",
			"parameters": [],
			"example": "color = self GetLightColor()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightExponent",
			"description": "Gets the current exponent of the light.",
			"calledOn": "light",
			"parameters": [],
			"example": "exponent = self GetLightExponent()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightFovOuter",
			"description": "Gets the current outer fov of a spot light.",
			"calledOn": "light",
			"parameters": [],
			"example": "fov = self GetLightFovOuter()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightIntensity",
			"description": "Gets the current intensity of the light.",
			"calledOn": "light",
			"parameters": [],
			"example": "intensity = self GetLightIntensity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightRadius",
			"description": "Gets the current radius of the light.",
			"calledOn": "light",
			"parameters": [],
			"example": "radius = self GetLightRadius()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLinkedEnt",
			"description": "Get the entity that the calling entity is linked to",
			"calledOn": "entity",
			"parameters": [],
			"example": "linked_ent = self GetLinkedEnt()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutAllocation",
			"description": "Get how many allocation points are spent in the custom class",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				}
			],
			"example": "allocationSpent = self GetLoadoutAllocation( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutGunSmithVariantIndex",
			"description": "Get the GunSmith Variant index of the primary weapon, pass 1 as an option to get the secondary",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				},
				{
					"name": "getSecondary",
					"description": "defaults to false, if set will get you the variant index of the secondary",
					"mandatory": false
				}
			],
			"example": "gunSmithPrimaryIndex = self GetLoadoutGunSmithVariantIndex( 0, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutItem",
			"description": "Get the index of the item in the custom class",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				},
				{
					"name": "loadoutSlot",
					"description": "Loadout Slot",
					"mandatory": true
				}
			],
			"example": "primary = self GetLoadoutItem( 0, primary )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutItemRef",
			"description": "Get the reference of the item in the custom class",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				},
				{
					"name": "loadoutSlot",
					"description": "Loadout Slot",
					"mandatory": true
				}
			],
			"example": "primary = self GetLoadoutItemRef( 0, primary )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutPerks",
			"description": "Get the list of specialties in the custom class",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				}
			],
			"example": "primary = self GetLoadoutPerks( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLoadoutWeapon",
			"description": "Get the full weapon name (including attachments) of the item in the custom class",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				},
				{
					"name": "loadoutSlot",
					"description": "Loadout Slot (primary or secondary)",
					"mandatory": true
				}
			],
			"example": "primary = self GetLoadoutWeapon( 0, primary )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLobbyClientCount",
			"description": "Returns the number of connected or connecting clients",
			"calledOn": null,
			"parameters": [],
			"example": "clientCount = GetClientCount()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMapAtIndex",
			"description": "Get the name of the map at the given index in a mode's maptable.  Returns undefined if the given index doesn't index the given maptable",
			"calledOn": null,
			"parameters": [
				{
					"name": "index",
					"description": "the index of the map you're looking for.",
					"mandatory": true
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "GetMapAtIndex( \"cp_mi_sing_blackstation\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMapFields",
			"description": "Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "fields = GetMapFields( GetNextMap(\"cp_mi_sing_blackstation\") )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMapIntroMovie",
			"description": "Get the intro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "world.nextIntroMovie = GetMapIntroMovie( GetNextMap(\"cp_mi_sing_blackstation\") )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMapOrder",
			"description": "Get the index of the current map in the maptable.  Returns -1 if currentmap wasn't found",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "if( GetMapOrder( \"cp_mi_sing_blackstation\" ) > GetMapOrder( world.highestMapCompletion ) { world.highestMapCompletion = \"cp_mi_sing_blackstation\"; }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMapOutroMovie",
			"description": "Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "world.nextOutroMovie = GetMapIntroMovie( GetNextMap(\"cp_mi_sing_blackstation\") )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMaxs",
			"description": "Get maximum bounds of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "maxs = wallModel GetMaxs()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMaxVehicles",
			"description": "Return the maximum number of vehicles that can be instantiated simultaneously.  This is platform-specific.",
			"calledOn": null,
			"parameters": [],
			"example": "vehicleSlotsFree = GetMaxVehicles() - level.vehicles_list.size",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMeleeChainCount",
			"description": "Gets the number of melee kills achieved by the player within their current streak.",
			"calledOn": "entity",
			"parameters": [],
			"example": "entity GetMeleeChainCount( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getmicrosecondsraw",
			"description": "Gets raw system microseconds; used for profiling, only gives lower 32 bits as script doesn't support uint64_t properly right now",
			"calledOn": null,
			"parameters": [],
			"example": "start_time = GetMicrosecondsRaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMillisecondsRaw",
			"description": "Gets raw system milliseconds; use for profiling long routines as it is only an integer",
			"calledOn": null,
			"parameters": [],
			"example": "start_time = GetMillisecondsRaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMins",
			"description": "Get minimum bounds of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "mins = wallModel GetMins()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMissileOwner",
			"description": "Returns the entity that owns this missile",
			"calledOn": "missile",
			"parameters": [],
			"example": "javelinOwner = GetMissileOwner( thisMissile )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMissionName",
			"description": "Returns the name of the mission this map is part of",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.mission = GetMissionName( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMissionUniqueID",
			"description": "Returns the unique id for this mission",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.unique_id = GetMissionUniqueID( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMissionVersion",
			"description": "Returns the unique id for this mission",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.unique_id = GetMissionVersion( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMoveDelta",
			"description": "Gets the move delta for the animation",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation name",
					"description": "Name of the animation",
					"mandatory": true
				},
				{
					"name": "start time",
					"description": "Normalized start time of the animation",
					"mandatory": false
				},
				{
					"name": "end time",
					"description": "Normalized end time of the animation",
					"mandatory": false
				},
				{
					"name": "entity",
					"description": "The entity should be passed if the animation name is a string to look up the animation from the entity's anim tree",
					"mandatory": false
				}
			],
			"example": "localDeltaVector = GetMoveDelta( animation, 0, 1, entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMoverEnt",
			"description": "Gets the moving entity the player is sitting on .",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player GetMoverEnt())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMoveSpeedScale",
			"description": "Gets the speed scale multiplier for the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "speed_modifier = self GetMoveSpeedScale()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNavMeshFaceNormal",
			"description": "Returns the face normal vector of the closest navmesh point to the passed in position, within the search radius.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position to start the search around.",
					"mandatory": true
				},
				{
					"name": "searchRadius",
					"description": "Radius to search within.",
					"mandatory": true
				}
			],
			"example": "navmeshNormal = GetNavMeshFaceNormal( (10,20,30), 25 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNavMeshTriggersForPoint",
			"description": "Returns a list of the names of navmesh triggers that a given point resides in",
			"calledOn": null,
			"parameters": [
				{
					"name": "pos",
					"description": "The test position.",
					"mandatory": true
				}
			],
			"example": "targetNames = GetNavMeshTriggersForPoint( pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNearestNode",
			"description": "Returns the node nearest to this origin or undefined if no close node exists.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "location to search for the nearest node",
					"mandatory": true
				}
			],
			"example": "node = GetNearestNode( guy.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNearestPathPoint",
			"description": "Returns the nearest point on the navmesh for the given origin and radius or undefined if no point can be found.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The point from which to search from",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The maximum radius in which to search",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNextMap",
			"description": "Get the name of the next map in the maptable.  Returns \"\" if this is the last map, undefined if currentmap wasn't found",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				},
				{
					"name": "dlcindex",
					"description": "dlc1..N if DLC.  If ommitted, use \"base\".",
					"mandatory": false
				},
				{
					"name": "sessionmodeabbrev",
					"description": "cp,mp,zm.  If ommitted, use current game mode abbreviation",
					"mandatory": false
				}
			],
			"example": "GetNextMap( \"cp_mi_sing_blackstation\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNextTraversalNodeOnPath",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "the  index for the starting node",
					"mandatory": true
				}
			],
			"example": "GetNextTraversalNodeOnPath(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNode",
			"description": "Gets a node with the given name, key pair",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": true
				}
			],
			"example": "node = GetNode( self.target, \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeArray",
			"description": "Gets an array of nodes that have the given name, key pair",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": true
				}
			],
			"example": "node = GetNodeArray( self.target, \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeArraySorted",
			"description": "Gets an array of nodes that have the given name, key pair, within given radius, sorts them",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "key that name goes with",
					"mandatory": true
				},
				{
					"name": "pos",
					"description": "search origin",
					"mandatory": true
				},
				{
					"name": "r",
					"description": "the radius to sort in",
					"mandatory": true
				}
			],
			"example": "nodes = GetNodeArraySorted(self.target, \"targetname\", self.origin, 256 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeEdge",
			"description": "Returns an array of points which corresponds to the node volume's traversal edge. The traversal edge is represented as a piecewise linear function.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "node volume",
					"mandatory": true
				}
			],
			"example": "points = GetNodeEdge( myNode )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeIndexOnPath",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to get the other node for",
					"mandatory": true
				}
			],
			"example": "GetNodeIndexOnPath(node)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeOwner",
			"description": "Get the owner of the node.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "which node to get the owner of.",
					"mandatory": true
				}
			],
			"example": "node_owner = GetNodeOwner( node ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeRegion",
			"description": "Returns the region of the give node, if there is one. Returns undefined otherwise.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node1",
					"description": "pathnode to check",
					"mandatory": true
				}
			],
			"example": "if ( GetNodeRegion( myNode ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodesInRadius",
			"description": "Gets all of the nodes (max of 256) within a cylinder, in unsorted order",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "location to search for nodes at",
					"mandatory": true
				},
				{
					"name": "max radius",
					"description": "maximum distance of nodes to return",
					"mandatory": true
				},
				{
					"name": "min radius",
					"description": "maximum distance of nodes to return",
					"mandatory": true
				},
				{
					"name": "max height",
					"description": "maximum height difference to origin. Defaults to 512",
					"mandatory": false
				},
				{
					"name": "node type",
					"description": "node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes",
					"mandatory": false
				},
				{
					"name": "max nodes",
					"description": "the maximum number of nodes to return up to 256",
					"mandatory": false
				},
				{
					"name": "region index",
					"description": "the region index the nodes should belong to",
					"mandatory": false
				}
			],
			"example": "nodes = GetNodesInRadius( guy.origin, 512, 0, 128, \"Path\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodesInRadiusSorted",
			"description": "Gets all of the nodes (max of 256) within a cylinder, sorted by closest to <origin>",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "location to search for nodes at",
					"mandatory": true
				},
				{
					"name": "max radius",
					"description": "maximum distance of nodes to return",
					"mandatory": true
				},
				{
					"name": "min radius",
					"description": "maximum distance of nodes to return",
					"mandatory": true
				},
				{
					"name": "max height",
					"description": "maximum height difference to origin. Defaults to 512",
					"mandatory": false
				},
				{
					"name": "node type",
					"description": "node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes",
					"mandatory": false
				},
				{
					"name": "max nodes",
					"description": "the maximum number of nodes to return up to 256",
					"mandatory": false
				}
			],
			"example": "nodes = GetNodesInRadiusSorted( guy.origin, 512, 0, 128, \"Path\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNormalHealth",
			"description": "Get health in a normalized range of 0 to 1",
			"calledOn": "entity",
			"parameters": [],
			"example": "normal_health = self GetNormalHealth()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNorthYaw",
			"description": "Get North Yaw",
			"calledOn": null,
			"parameters": [],
			"example": "northvector = (cos(getnorthyaw()), sin(getnorthyaw()), 0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNotetracksInDelta",
			"description": "Get a list of notetracks and times within a specific time delta of a specific time in an animation",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "the animation for which notetrack information is needed",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time in the animation around which notetrack information is needed in the range 0-1",
					"mandatory": true
				},
				{
					"name": "time_delta",
					"description": "The amount of time around the time provided to check for notetracks in seconds defaults to 0.15",
					"mandatory": false
				}
			],
			"example": "notetrackArray = GetNotetracksInDelta( anim, 0.4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNotetrackTimes",
			"description": "Gets an array of the times during an animation that the given notetrack occurs. The times returned are fractional (0 to 1).",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "an animation",
					"mandatory": true
				},
				{
					"name": "note track",
					"description": "a constant string with the name of the note track",
					"mandatory": true
				}
			],
			"example": "exitAlignTimes = GetNotetrackTimes( exitAnim, \"exit_align\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumberOfCollectiblesForLevel",
			"description": "Returns the number of collectibles for the given level",
			"calledOn": null,
			"parameters": [],
			"example": "collectibleCount = GetNumberOfCollectiblesForLevel( GetRootMapName() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumChallengesComplete",
			"description": "Returns the number of challenges completed in a given mission",
			"calledOn": "player",
			"parameters": [
				{
					"name": "mission_name",
					"description": "(string) The name of the mission to check completed challenges in",
					"mandatory": true
				}
			],
			"example": "is_default = self GetNumChallengesComplete( \"angola\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumConnectedPlayers",
			"description": "Returns the number of players that are connected to our game.  Ignores bots by default.",
			"calledOn": null,
			"parameters": [
				{
					"name": "include bots",
					"description": "The optional check to include test clients (bots). (bool)",
					"mandatory": false
				}
			],
			"example": "num_players_and_bots = GetNumConnectedPlayers( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumExpectedPlayers",
			"description": "Returns the number of players that we're expecting to join our game.",
			"calledOn": null,
			"parameters": [],
			"example": "num_players = GetNumExpectedPlayers()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumParts",
			"description": "Return number of bones in the model",
			"calledOn": null,
			"parameters": [
				{
					"name": "model",
					"description": "The model to get parts for",
					"mandatory": true
				}
			],
			"example": "numParts = GetNumParts( model )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumZBarrierPieces",
			"description": "Returns number of pieces in specified zbarrier ent.",
			"calledOn": "entity",
			"parameters": [],
			"example": "numPieces = ent GetNumZBarrierPieces())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetOrigin",
			"description": "Get the origin of the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "origin = self GetOrigin()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetOtherNodeInNegotiationPair",
			"description": "Returns the other node of the passed in negotiation node. Returns the begin node if end is passed and vice versa.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to get the other node for",
					"mandatory": true
				}
			],
			"example": "end_node = GetOtherNodeInNegotiationPair( begin_node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPartName",
			"description": "Get the bone name for the model and index",
			"calledOn": null,
			"parameters": [
				{
					"name": "model",
					"description": "The model to get parts for",
					"mandatory": true
				},
				{
					"name": "index",
					"description": "The bone index",
					"mandatory": true
				}
			],
			"example": "boneName = GetPartName( model, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathfindingRadius",
			"description": "Returns the radius used for pathfinding operations.",
			"calledOn": "entity",
			"parameters": [],
			"example": "radius = ent GetPathfindingRadius()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathMetric",
			"description": "Get path metric for the path from the ai to origin",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "origin",
					"description": "the goal for the path",
					"mandatory": true
				}
			],
			"example": "path_metric = level.ai_for_pathing GetPathMetric( dropPos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerGravity",
			"description": "Gets the gravity or gravity override value for the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "player GetPlayerGravity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayers",
			"description": "Returns an array of the currently connected players.  Used internally to the script call get_players().",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "- if specifed, returns lists of players on different teams, in team based game modes.  Valid values \"allies\", \"axis\", \"neutral\" & \"all\"",
					"mandatory": false
				}
			],
			"example": "players = GetPlayers()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSelectedGestureName",
			"description": "Get the equipped gesture animation name",
			"calledOn": "player",
			"parameters": [
				{
					"name": "gestureType",
					"description": "The type of gesture to get",
					"mandatory": true
				}
			],
			"example": "gesture = player GetPlayerSelectedGestureName( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSelectedTauntName",
			"description": "Get the equipped taunt animation name",
			"calledOn": "player",
			"parameters": [
				{
					"name": "tauntType",
					"description": "The type of taunt to get",
					"mandatory": true
				}
			],
			"example": "taunt = player GetPlayerSelectedTauntName( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSpawnId",
			"description": "Returns the current spawn id for the player (used for debugging purposes only)",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player that we are spawning in",
					"mandatory": true
				}
			],
			"example": "spawnId = GetPlayerSpawnId( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSpeed",
			"description": "Gets the speed value for the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "player GetPlayerSpeed()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPointInBounds",
			"description": "Returns a point within an entity's bounds.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "ratio_ForwardBack",
					"description": "1.0 is full forward, -1.0 is full backwards.",
					"mandatory": true
				},
				{
					"name": "ratio_LeftRight",
					"description": "1.0 is full left, -1.0 is full right.",
					"mandatory": true
				},
				{
					"name": "ratio_UpDown",
					"description": "1.0 is full up, -1.0 is full down.",
					"mandatory": true
				}
			],
			"example": "targetForwardPnt = helo GetPointInBounds( 1.0, 0.0, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRandomCompatibleAttachmentsForWeapon",
			"description": "Returns an array of compatible attachments. If num desired attachments are specified then that many attachments will be returned if possible",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon name.",
					"mandatory": true
				},
				{
					"name": "num desired attachments",
					"description": "Max number of compatible attachments desired. If the number is more than available attachments for the weapon, it will just not return that many.",
					"mandatory": false
				}
			],
			"example": "GetRandomCompatibleAttachmentsForWeapon( weaponObject, 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRandomPointOnNavVolume",
			"description": "Get a random point on nav volume. Returns the position if found one, or undefined if not found.",
			"calledOn": "flying_ai",
			"parameters": [],
			"example": "random = self GetRandomPointOnNavVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRefFromItemIndex",
			"description": "Returns the ref for a specified item index",
			"calledOn": null,
			"parameters": [
				{
					"name": "itemIndex",
					"description": "Item index",
					"mandatory": true
				}
			],
			"example": "ref = GetRefFromItemIndex( itemIndex )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetReflectionLocs",
			"description": "Gets array of the locations of all of the reflection_probes in the level",
			"calledOn": null,
			"parameters": [],
			"example": "reflection_locs = GetReflectionLocs()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetReflectionOrigin",
			"description": "Given a position, returns the position of the reflection probe in use there",
			"calledOn": null,
			"parameters": [],
			"example": "probe_pos = GetReflectionOrigin( camera_pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRetrievableWeapons",
			"description": "Returns an array of weapons that need watchers so they can be retrieved by the player.",
			"calledOn": null,
			"parameters": [],
			"example": "retrievableWeapons = GetRetrievableWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRootMapName",
			"description": "Returns the root map of a mission",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.rootMap = GetRootMapName( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetRoundsPlayed",
			"description": "Get rounds played in match state",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "The number of rounds played",
					"mandatory": true
				}
			],
			"example": "GetRoundsPlayed( game[\"roundsplayed\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptBundle",
			"description": "Returns the script bundle struct.",
			"calledOn": null,
			"parameters": [],
			"example": "settings = GetScriptBundle( \"doorsettings\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptBundleList",
			"description": "Returns the script bundle list array.",
			"calledOn": null,
			"parameters": [],
			"example": "settings = GetScriptBundleList( \"doorsettings\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptBundleNames",
			"description": "Returns all the names of the script bundles of the specified type in an array.",
			"calledOn": null,
			"parameters": [],
			"example": "settings = GetScriptBundleNames( \"scene\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptBundles",
			"description": "Returns a list of script bundles based on the type.",
			"calledOn": null,
			"parameters": [],
			"example": "settings = GetScriptBundles( \"scenes\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptMoverArray",
			"description": "Returns an array of all of the script_origins in a level.",
			"calledOn": null,
			"parameters": [],
			"example": "origins = GetScriptMoverArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetShootAtPos",
			"description": "Gets the position an attacker would shoot at to hit this entity.For AI or player this is the eye position.For other entities it's the tag_eye if there is one else the center of the entity bounding box.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "attacker",
					"description": "The entity that will be shooting",
					"mandatory": false
				}
			],
			"example": "targetPos = self.enemy GetShootAtPos(self)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSkiptoName",
			"description": "Get the skip to name with the given index",
			"calledOn": null,
			"parameters": [
				{}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSkipTos",
			"description": "Get all skip tos for the level",
			"calledOn": null,
			"parameters": [],
			"example": "skiptos = GetSkipTos()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSnapshotIndexArray",
			"description": "Returns an array of the indices of current snapshots for all connected clients.",
			"calledOn": null,
			"parameters": [],
			"example": "snapindices = GetSnapshotIndexArray( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpawnerArray",
			"description": "Returns an array of all of the spawners in a level.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "spawners = GetSpawnerArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpawnerTeamArray",
			"description": "Returns an array of all of the spawners in a level",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', or 'neutral'",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of additional team names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "enemies = GetSpawnerTeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpawnStructForCharacter",
			"description": "Returns the targetname of the script_struct to use for the character pose in the frontend",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "frontendVignetteAnim = GetSpawnStructForCharacter( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpecialistIndex",
			"description": "Returns the specialist index for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "specialistIndex = player GetSpecialistIndex()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStance",
			"description": "Gets the stance of the player. It only works for the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "stance = player GetStance()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStartAngles",
			"description": "Get the starting angles for an animation, in world coordinates, given its current position, and angles",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The current origin of the animation in world coordinates",
					"mandatory": true
				},
				{
					"name": "angle",
					"description": "The current angle set of the animation in world coordinates",
					"mandatory": true
				},
				{
					"name": "animation",
					"description": "The currently running animation",
					"mandatory": true
				},
				{
					"name": "animation time",
					"description": "The animation time in 0-1 range",
					"mandatory": false
				}
			],
			"example": "org1 = GetStartAngles( climborg, climbang, buddyanim1, [0.5] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStartOrigin",
			"description": "Get the starting origin for an animation, in world coordinates, given its current position, and angles",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The current origin of the animation in world coordinates",
					"mandatory": true
				},
				{
					"name": "angle",
					"description": "The current angle set of the animation in world coordinates",
					"mandatory": true
				},
				{
					"name": "animation",
					"description": "The currently running animation",
					"mandatory": true
				},
				{
					"name": "animation time",
					"description": "The starting animation time in 0-1 range",
					"mandatory": false
				}
			],
			"example": "org1 = GetStartOrigin( climborg, climbang, buddyanim1, [0.5] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStartTime",
			"description": "Returns the start time for the current round.",
			"calledOn": null,
			"parameters": [],
			"example": "GetStartTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStowedWeapon",
			"description": "Gets the stowed weapon for the player",
			"calledOn": "entity",
			"parameters": [],
			"example": "stowed = self GetStowedWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTagAngles",
			"description": "Gets the angles of the tag",
			"calledOn": "entity",
			"parameters": [],
			"example": "angles = self GetTagAngles( \"tag\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTagOrigin",
			"description": "Gets the origin of the tag",
			"calledOn": "entity",
			"parameters": [],
			"example": "origin = self GetTagOrigin( \"tag\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTargetEntity",
			"description": "Gets the target entity of this turret or vehicle weapon",
			"calledOn": "turret_or_vehicle",
			"parameters": [
				{
					"name": "gunnerIndex",
					"description": "the gunner index if called on a vehicle",
					"mandatory": false
				}
			],
			"example": "target = roof_turret GetTargetEntity( ); target = tank GetTargetEntity( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTargetOrigin",
			"description": "Gets the target origin of this turret or vehicle weapon",
			"calledOn": "turret_or_vehicle",
			"parameters": [
				{
					"name": "gunnerIndex",
					"description": "the gunner index if called on a vehicle (integer)",
					"mandatory": false
				}
			],
			"example": "origin = roof_turret GetTargetOrigin( ); origin = tank GetTargetOrigin( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTeam",
			"description": "Return true if the team of an entity if it can be found, undefined otherwise.",
			"calledOn": "entity",
			"parameters": [],
			"example": "orig_team = self GetTeam()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTeamPlayersAlive",
			"description": "Returns the number of players still alive on a given team",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "A string value, either 'axis' or 'allies' or 'team3'",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTeamSatellite",
			"description": "Gets whether a team has Satellite or not",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.",
					"mandatory": true
				}
			],
			"example": "GetTeamSatellite( \"allies\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTeamScore",
			"description": "Get a team's score",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either 'axis' or 'allies' or 'team3'.",
					"mandatory": true
				}
			],
			"example": "if ( GetTeamScore( \"allies\" ) > getTeamScore(\"axis\") ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTeamSpyplane",
			"description": "Gets whether a team has Spyplane or not",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.",
					"mandatory": true
				}
			],
			"example": "GetTeamSpyplane( \"allies\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTime",
			"description": "Gets the level time in Milliseconds from the start of the level.",
			"calledOn": null,
			"parameters": [],
			"example": "nextNodeTime = GetTime() + 500",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTotalServerPauseTime",
			"description": "Gets the total time the server has been paused since the map started.",
			"calledOn": null,
			"parameters": [],
			"example": "val = GetTotalServerPauseTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "gettotalunlockedweaponattachments",
			"description": "Get total number of attachments that are unlocked for the weapon specified",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon",
					"mandatory": true
				}
			],
			"example": "player GetTotalUnlockedWeaponAttachements( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTouchingVolume",
			"description": "Get the entities that are inside the bounds given",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Position of bounding box",
					"mandatory": true
				},
				{
					"name": "mins",
					"description": "The minimum extents of the bounding box",
					"mandatory": true
				},
				{
					"name": "maxs",
					"description": "The maximum extents of the bounding box",
					"mandatory": true
				}
			],
			"example": "entities = GetTouchingVolume( self.origin, mins, maxs )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTriggerAccumulate",
			"description": "Returns the accumulate value from the trigger",
			"calledOn": "trigger",
			"parameters": [],
			"example": "self GetTriggerAccumulate()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretArcLimits",
			"description": "Return turret info for arc mins and maxs",
			"calledOn": "turret",
			"parameters": [],
			"example": "limits turret GetTurretArcLimits()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretOwner",
			"description": "Gets the \"owner\" of this turret",
			"calledOn": "turret",
			"parameters": [],
			"example": "turret_user = roof_turret GetTurretOwner()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretTarget",
			"description": "Gets the current target of this turret",
			"calledOn": "turret",
			"parameters": [],
			"example": "target = roof_turret GetTurretTarget()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetUpgradedPieceNumLives",
			"description": "Returns the number of lives, or pull reps it should take a zombie to dislodge this piece, if it's upgraded.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "piece.numLives = ent GetUpgradedPieceNumLives(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetUTC",
			"description": "Gets the UTC time.",
			"calledOn": null,
			"parameters": [],
			"example": "val = GetUTC()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetValidCoverPeekOuts",
			"description": "Returns an array of directions an AI can peek out from a cover node. Possible values are 'over', 'left', and 'right'.",
			"calledOn": "pathnode",
			"parameters": [],
			"example": "GetValidCoverPeekOuts( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleArray",
			"description": "Returns an array of all of the vehicles in a level",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "enemies = GetVehicleArray( \"drones\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleSpawnerArray",
			"description": "Returns an array of all of the vehicle spawners in a level",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Name to search for.",
					"mandatory": false
				},
				{
					"name": "key",
					"description": "The key to search for.",
					"mandatory": false
				}
			],
			"example": "enemies = GetVehicleSpawnerArray( \"bob\", \"targetname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleSpawnerTeamArray",
			"description": "Returns an array of all of the vehicle spawners in a level with the specified team",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "a team name, either 'axis', 'allies', or 'neutral'",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "any number of teams names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "enemies = GetVehicleSpawnerTeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleTeamArray",
			"description": "Returns an array of all of the vehicles in a level that are not sentients",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "any number of teams names may be added, either 'axis', 'allies', or 'neutral'",
					"mandatory": false
				}
			],
			"example": "enemies = GetVehicleTeamArray( \"axis\", \"neutral\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleTriggerFlags",
			"description": "Returns the spawn flags that will allow vehicles to activate triggers",
			"calledOn": null,
			"parameters": [],
			"example": "spawn(\"trigger_radius\", (0,0,0), GetVehicleTriggerFlags())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVelocity",
			"description": "Returns the entity's velocity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity.",
					"mandatory": true
				}
			],
			"example": "vel = thing GetVelocity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVisibleNode",
			"description": "Returns the farthest visible node on the path from <start> to <end> or undefined if no path exists.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "starting origin of the path",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "ending origin of the path",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore during pathnode trace checks",
					"mandatory": false
				}
			],
			"example": "node = GetVisibleNode( guy.origin, enemy.origin, guy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVisibleNodes",
			"description": "Returns an array of nodes visible to this node",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "pathnode to check",
					"mandatory": true
				}
			],
			"example": "nodes = GetVisibleNodes( cover.node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getvrcamangles",
			"description": "Get the VR camera angles of the player",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getvrcampos",
			"description": "Get the VR camera position of the player",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWallRunWallNormal",
			"description": "Returns the normal of the wall the player is running on (or was running on)",
			"calledOn": "player",
			"parameters": [],
			"example": "wall_normal = player GetWallRunWallNormal()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWatcherWeapons",
			"description": "Returns array of weapons that need watchers so they will die when the player respawns",
			"calledOn": null,
			"parameters": [],
			"example": "watcherWeapons = GetWatcherWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWaterHeight",
			"description": "Returns the height of the water at this position",
			"calledOn": null,
			"parameters": [
				{
					"name": "pos",
					"description": "Query position",
					"mandatory": true
				}
			],
			"example": "height = getwaterheight( self.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeapon",
			"description": "Get the requested weapon object based on game mode agnostic weapon name string",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponname",
					"description": "the name of the base weapon to return",
					"mandatory": true
				},
				{
					"name": "attachmentname_1 or array of attachments",
					"description": "the name of the first attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_2",
					"description": "the name of the second attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_3",
					"description": "the name of the third attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_4",
					"description": "the name of the fourth attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_5",
					"description": "the name of the fifth attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_6",
					"description": "the name of the sixth attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_7",
					"description": "the name of the seventh attachment to return",
					"mandatory": false
				},
				{
					"name": "attachmentname_8",
					"description": "the name of the eighth attachment to return",
					"mandatory": false
				}
			],
			"example": "GetWeapon( \"ar_standard\", \"acog\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAccuracy",
			"description": "Returns accuracy at the distance from the current enemy.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity. Must be AI.",
					"mandatory": true
				},
				{
					"name": "weapon name",
					"description": "The weapon name.",
					"mandatory": true
				}
			],
			"example": "getweaponaccuracy( self, \"ak47\" ), getweaponaccuracy( ai, ai.primaryweapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAttachments",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponForCharacter",
			"description": "Returns the weapon at the given index",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "modelName = GetWeaponForCharacter( 0, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponForwardDir",
			"description": "Returns the weapon's forward direction",
			"calledOn": "weapon",
			"parameters": [],
			"example": "weapon GetWeaponForwardDir()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponModelForCharacter",
			"description": "Returns the name of the weapon model of at the given index",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "modelName = GetWeaponModelForCharacter( 0, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponMuzzlePoint",
			"description": "Returns the weapon's muzzle point",
			"calledOn": "weapon",
			"parameters": [],
			"example": "weapon GetWeaponMuzzlePoint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponOptic",
			"description": "Gets the weapon optic attachment name",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "Weapon name",
					"mandatory": true
				}
			],
			"example": "attachmentName = player GetWeaponOptic( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponWorldModel",
			"description": "Returns weaopn world model",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "model = GetWeaponWorldModel(\"lmg\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponXCam",
			"description": "Get the weapon XCam",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon object",
					"description": "The weapon entity",
					"mandatory": true
				},
				{
					"name": "camera",
					"description": "The camera to get",
					"mandatory": true
				}
			],
			"example": "weapon GetWeaponXCam( GetWeapon( weaponName ), \"cam_cac_weapon\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetXCamForCharacter",
			"description": "Returns the name of the xcam to use for the character pose in the frontend",
			"calledOn": null,
			"parameters": [
				{
					"name": "characterIndex",
					"description": "The index of the character in the current game-mode's character table",
					"mandatory": true
				},
				{
					"name": "sessionmode",
					"description": "Session Mode Index",
					"mandatory": true
				}
			],
			"example": "frontendVignetteAnim = GetXCamForCharacter( characterIndex, \"mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetXModelCenterOffset",
			"description": "Calculates the offset to the center of the model from the origin",
			"calledOn": null,
			"parameters": [
				{
					"name": "modelname",
					"description": "The name of the xmodel",
					"mandatory": true
				}
			],
			"example": "offset = GetXModelCenterOffset( \"modelname\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierArray",
			"description": "Returns an array of all of the zbarrier objects in a level.",
			"calledOn": null,
			"parameters": [],
			"example": "zbarriers = GetZBarrierArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierAttackSlotHorzOffset",
			"description": "Returns the horizontal offset used to offset the position of each attack slot relative to the zbarrier object.  Odd numbers will start in the center of the barrier and offset to each side.  Even numbers will start each side of the center - with no central spot specified.",
			"calledOn": "entity",
			"parameters": [],
			"example": "horzOffset = ent GetZBarrierAttackSlotHorzOffset()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierNumAttackSlots",
			"description": "Returns the number of attack slots used by this zbarrier.",
			"calledOn": "entity",
			"parameters": [],
			"example": "numSlots = ent GetZBarrierNumAttackSlots()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierPieceAnimLengthForState",
			"description": "Returns the length in seconds for the animation associated with the supplied state for a piece, in seconds.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "index",
					"description": "The index of the piece we care about.",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.",
					"mandatory": true
				},
				{
					"name": "scalar",
					"description": "Scalar applied to animation length.",
					"mandatory": false
				}
			],
			"example": "wait(ent GetZBarrierPieceAnimLengthForState(0, \"opening\", 0.9))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierPieceAnimState",
			"description": "Returns the anim state name to be used for zombies tearing this board down.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "anim_state = ent GetZBarrierPieceAnimState(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierPieceAnimSubState",
			"description": "Returns the anim sub-state name to be used for zombies tearing this board down.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "anim_state = ent GetZBarrierPieceAnimSubState(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierPieceIndicesInState",
			"description": "Returns an array of integer indices of the zbarriers pieces that are in the specified state.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "state",
					"description": "Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.",
					"mandatory": true
				}
			],
			"example": "open_pieces = ent GetZBarrierPieceIndicesInState(\"open\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierPieceState",
			"description": "Returns the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "pieceState = ent GetZBarrierPieceState(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierReachThroughAttackAnimState",
			"description": "Returns the anim state name for reach through attacks used by this zbarrier.",
			"calledOn": "entity",
			"parameters": [],
			"example": "attackStateName = ent GetZBarrierReachThroughAttackAnimState()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetZBarrierTauntAnimState",
			"description": "Returns the anim state name for taunts used by this zbarrier.",
			"calledOn": "entity",
			"parameters": [],
			"example": "tauntStateName = ent GetZBarrierTauntAnimState()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Ghost",
			"description": "Used when the entity should be sent over the network to clients but not be drawn",
			"calledOn": "entity",
			"parameters": [],
			"example": "model Ghost()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Gib",
			"description": "Gib an entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "gibtype",
					"description": "Type of gib",
					"mandatory": true
				},
				{}
			],
			"example": "self gib( \"normal\", temp_array )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GlassRadiusDamage",
			"description": "Damages glass in the radius",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Origin of damage",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "Radius of damage",
					"mandatory": true
				},
				{
					"name": "max_damage",
					"description": "Max damage, this is the damage at the origin",
					"mandatory": true
				},
				{
					"name": "min_damage",
					"description": "Max damage, this is the damage at the edge of the radius",
					"mandatory": true
				},
				{
					"name": "means_of_death",
					"description": "Means of death passed to the glass system from script, defaults to MOD_EXPLOSIVE",
					"mandatory": false
				}
			],
			"example": "GlassRadiusDamage( origin, range, max_damage, min_damage, means_of_damage )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GrenadeExplosionEffect",
			"description": "Create a grenade explosion effect at the position",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position of the fx",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GroundTrace",
			"description": "Allows script to do a point trace with MASK_SHOT + MASK_ITEM. Returns hit position, hit entity, hit surface normal.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The bullet start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The bullet end point",
					"mandatory": true
				},
				{
					"name": "hit characters",
					"description": "When set to true, this will trace for character hits",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore",
					"mandatory": true
				},
				{
					"name": "ignore water",
					"description": "Optionally ignore water. (bool)",
					"mandatory": false
				},
				{
					"name": "ignore glass",
					"description": "Optionally ignore glass. (bool)",
					"mandatory": false
				}
			],
			"example": "trace = GroundTrace(magicBulletOrigin.origin, eyePos, true, undefined)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasASM",
			"description": "Check if this entity has an ASM.",
			"calledOn": "entity",
			"parameters": [],
			"example": "if ( HasASM( self ) ) {",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasPart",
			"description": "Returns whether the entity has the given tagname as part of its skeleton.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "tagname",
					"description": "The tag to search for. (string)",
					"mandatory": true
				},
				{
					"name": "modelname",
					"description": "The optional model name to help specify the part location. (string)",
					"mandatory": false
				}
			],
			"example": "has_part = self HasPart( \"tag_weapon\", \"weapon_saw\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HeliTurretDogTrace",
			"description": "Determines if you helicopter turret can see the dog.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "place that check if you can see if being performed",
					"mandatory": true
				},
				{
					"name": "dog",
					"description": "the dog that the helicopter wants to see",
					"mandatory": true
				},
				{
					"name": "hitNum",
					"description": "if you run this more than once make sure to populate this with the return of the last as it will increase efficiency",
					"mandatory": true
				}
			],
			"example": "if (0 == (copter HeliTurretSightTrace(heli_turret_point, dog, lastHit))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HeliTurretSightTrace",
			"description": "Determines if you helicopter turret can see an the players eyes.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "place that check if you can see if being performed",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "the player that the helicopter wants to see",
					"mandatory": true
				},
				{
					"name": "hitNum",
					"description": "if you run this more than once make sure to populate this with the return of the last as it will increase efficiency",
					"mandatory": true
				}
			],
			"example": "if (0 == (copter HeliTurretSightTrace(heli_turret_point, player, lastHit))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Hide",
			"description": "Hide the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self Hide()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HideFromTeam",
			"description": "Hides the entity from a particular team",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "team",
					"description": "The team to show the entity to.",
					"mandatory": true
				}
			],
			"example": "self HideFromTeam( friend_team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "hideinfovolume",
			"description": "Stops an info volume from being drawn",
			"calledOn": null,
			"parameters": [
				{
					"name": "entnum",
					"description": "the entity number of the info volume",
					"mandatory": true
				}
			],
			"example": "InfoVolumeDebug_HideVolume( info_volume GetEntityNumber() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HideMiscModels",
			"description": "Hide all misc models with this targetname",
			"calledOn": null,
			"parameters": [
				{
					"name": "targetname",
					"description": "targetname of misc model(s).",
					"mandatory": true
				}
			],
			"example": "HideMiscModels( \"crash_destruct\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HidePart",
			"description": "Hide part of an entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "tagname",
					"description": "The tag to hide. All surfaces with a vertex weighted to the tag will be hidden and have no bullet collision. (string)",
					"mandatory": true
				},
				{
					"name": "modelname",
					"description": "The optional model name to help specify the part location. (string)",
					"mandatory": false
				},
				{
					"name": "bApplyToChildren",
					"description": "Optional flag to specify if we should apply the operation to children bones as well. (boolean)",
					"mandatory": false
				}
			],
			"example": "self HidePart( \"tag_weapon\", \"weapon_saw\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HideZBarrierPiece",
			"description": "Stops the indexed piece from being drawn.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent HideZBarrierPiece(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IncrementCounter",
			"description": "Increments the counter",
			"calledOn": null,
			"parameters": [
				{
					"name": "counterType",
					"description": "The counter type",
					"mandatory": true
				},
				{
					"name": "increment",
					"description": "The increment type",
					"mandatory": true
				}
			],
			"example": "IncrementCounter( \"global_comebacks\", level.globalComebacks )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "incrementSpecificWeaponPickedUpCount",
			"description": "increment the count of the times we've picked up this weapon (uniquely identified by weapon+attachemnts; see function: areWeaponsEqual )",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "the weapon",
					"mandatory": true
				}
			],
			"example": "self incrementSpecificWeaponPickedUpCount( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "InfoVolumeDebugInit",
			"description": "Initializes the info volume debug array",
			"calledOn": null,
			"parameters": [],
			"example": "DebugInfoVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "InLastStand",
			"description": "Check the last stand state for the client",
			"calledOn": "client",
			"parameters": [],
			"example": "if ( self InLastStand() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IPrintLn",
			"description": "Write line to the screen",
			"calledOn": null,
			"parameters": [
				{
					"name": "text",
					"description": "text to be written",
					"mandatory": true
				}
			],
			"example": "IPrintLn( \"Where have all the cowboys gone?\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IPrintLnBold",
			"description": "write bold line to the screen",
			"calledOn": null,
			"parameters": [
				{
					"name": "text",
					"description": "text to be written",
					"mandatory": true
				}
			],
			"example": "IPrintLnBold( \"Mitchell!\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsActor",
			"description": "Checks whether this entity is an ai character",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be an ai character",
					"mandatory": true
				}
			],
			"example": "if ( IsActor( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsActorCorpse",
			"description": "Checks whether this entity is an actor corpse",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that might be a corpse",
					"mandatory": true
				}
			],
			"example": "if ( IsActorCorpse( corpse ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsActorSpawner",
			"description": "Checks whether this entity is an actor spawner",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be an actor spawner",
					"mandatory": true
				}
			],
			"example": "if ( IsActorSpawner( ent ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAI",
			"description": "Checks whether this entity is an ai character",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be an ai character",
					"mandatory": true
				}
			],
			"example": "if ( IsAI( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAirborne",
			"description": "Checks whether this entity is an airborne unit",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object",
					"mandatory": true
				}
			],
			"example": "if ( IsAirborne( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAlive",
			"description": "Checks whether this entity is alive",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that might be alive or dead",
					"mandatory": true
				}
			],
			"example": "if ( IsAlive( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAnimLooping",
			"description": "Gets whether an animation is looped or not",
			"calledOn": null,
			"parameters": [
				{
					"name": "animation",
					"description": "an animation that needs to be identified as a looping or not",
					"mandatory": true
				}
			],
			"example": "boolLoop = IsAnimLooping( climbAnim )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsArchetypeLoaded",
			"description": "Returns true if a given archetype is loaded in the level.",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsArchetypeLoaded( ARCHETYPE_WARLORD ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsArenaMode",
			"description": "Returns true if we are in arena mode",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsArenaMode() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAssetLoaded",
			"description": "Check whether or not an asset is loaded.",
			"calledOn": null,
			"parameters": [
				{
					"name": "assetType",
					"description": "\"weapon\" or \"material\"",
					"mandatory": true
				},
				{
					"name": "assetName",
					"description": "The name of the asset - should match zone_source",
					"mandatory": true
				}
			],
			"example": "IsAssetLoaded( \"weapon\", \"rpg\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsBonusCardActive",
			"description": "Returns if the bonus card is enabled and active in the class, cannot be called on a larry",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bonuscard",
					"description": "BonusCard index from bonuscard.gsh",
					"mandatory": true
				},
				{
					"name": "classnum",
					"description": "The current class num of the player",
					"mandatory": true
				}
			],
			"example": "primary = self IsBonusCardActive( BONUSCARD_PRIMARY_GUNFIGHTER_INDEX, self.class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsBot",
			"description": "Returns true if the entity is a bot controlled player",
			"calledOn": "entity",
			"parameters": [],
			"example": "if( self IsBot() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCamAnimLooping",
			"description": "Returns whether or not a specific camera anim loop.",
			"calledOn": null,
			"parameters": [
				{
					"name": "cam_anim",
					"description": "The animation to play",
					"mandatory": true
				}
			],
			"example": "IsCamAnimLooping( \"proto_melee_cam\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsClientCacheStable",
			"description": "Is the players client cache stable, have we loaded all other clients' resources.",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsClientCacheStable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCorpse",
			"description": "Checks whether this entity is a corpse",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that might be a corpse",
					"mandatory": true
				}
			],
			"example": "if ( IsCorpse( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCoverNode",
			"description": "returns true if the node is of type NODE_TYPEFLAGS_COVER_ONLY",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to delete",
					"mandatory": true
				}
			],
			"example": "IsCoverNode( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDangerous",
			"description": "Returns true if the pathnode is dangerous for the given team",
			"calledOn": "pathnode",
			"parameters": [
				{
					"name": "team",
					"description": "Name of the team.",
					"mandatory": true
				}
			],
			"example": "if ( node IsDangerous( team ) ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDedicated",
			"description": "Returns true/false if we are running on the dedicated server",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsDedicated() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDoubleJumping",
			"description": "Returns true if the player is double jumping.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player DoubleJumping())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsEMPJammed",
			"description": "Returns true if this player is jammed by the emp, false otherwise",
			"calledOn": null,
			"parameters": [],
			"example": "if ( player IsEMPJammed() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsEntity",
			"description": "Checks whether given variable is of type entity.",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable to test",
					"mandatory": true
				}
			],
			"example": "if ( IsEntity( variable ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsEventServiced",
			"description": "Set the specified event to serviced.",
			"calledOn": "ai",
			"parameters": [
				{
					"name": "eventId",
					"description": "The identifier of the event (integer)",
					"mandatory": true
				}
			],
			"example": "serviced = self IsEventServiced( 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFiringTurret",
			"description": "Checks whether this turret is firing. The entity must be a turret",
			"calledOn": "turret",
			"parameters": [],
			"example": "turret IsFiringTurret()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFlared",
			"description": "Check is a player is under the influence of a flare",
			"calledOn": null,
			"parameters": [],
			"example": "if ( player IsFlared() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGadgetMeleeCharging",
			"description": "Is the player in the process of melee charging ",
			"calledOn": null,
			"parameters": [],
			"example": "self IsGadgetMeleeCharging()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGlobalStatsServer",
			"description": "Returns true if the game is a global stats ranked server",
			"calledOn": null,
			"parameters": [],
			"example": "level.ranked |= IsGlobalStatsServer()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGodMode",
			"description": "Checks whether this entity is in god mode",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object to check for god mode",
					"mandatory": true
				}
			],
			"example": "if ( IsGodMode( player ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsHidden",
			"description": "return true if entity is hidden",
			"calledOn": "entity",
			"parameters": [],
			"example": "self IsHidden()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInSecondChance",
			"description": "To check if player is needs revive",
			"calledOn": null,
			"parameters": [],
			"example": "if ( self IsInSecondChance() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInsideHeightLock",
			"description": "Returns whether the entity is inside the height lock or not",
			"calledOn": "entity",
			"parameters": [],
			"example": "if( self IsInsideHeightLock() ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLaserOn",
			"description": "check if the entity has laser turned on.",
			"calledOn": "entity",
			"parameters": [],
			"example": "if ( IsLaserOn( entity ) ) { ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLinkedTo",
			"description": "Returns true if the entity is linked to the other entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "other",
					"description": "Entity",
					"mandatory": true
				}
			],
			"example": "if (ent IsLinkedTo( other )) { // dostuff }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLoadingCinematicPlaying",
			"description": "Is the player playing the loading cinematic",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsLoadingCinematicPlaying()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLocalGame",
			"description": "Returns true if the game local only",
			"calledOn": null,
			"parameters": [],
			"example": "level.local = IsLocalGame()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMantling",
			"description": "Return true if the player is mantling, false otherwise.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsMantling()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMapSubLevel",
			"description": "Returns whether or not the map is a sublevel of a mission",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.isSubLevel = IsMapSubLevel( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMature",
			"description": "Checks if a player has his Graphic Content Flag is on",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player to check if his Graphic Content Flag is on",
					"mandatory": true
				}
			],
			"example": "IsMature( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ismissileinsideheightlock",
			"description": "Returns whether the entity is inside the height lock or not",
			"calledOn": "entity",
			"parameters": [],
			"example": "if( self IsInsideHeightLock() ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMovingPlatform",
			"description": "Returns whether platform is a moving platform or not",
			"calledOn": null,
			"parameters": [],
			"example": "platform IsMovingPlatform()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsNavVolumeLoaded",
			"description": "Checks whether nav volume is loaded",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsNavVolumeLoaded() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsNodeEnabled",
			"description": "returns true if the node is enabled, false otherwise",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to check",
					"mandatory": true
				}
			],
			"example": "IsNodeEnabled( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsNodeOccupied",
			"description": "See if anyone has claimed a particular node.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "which node to check.",
					"mandatory": true
				}
			],
			"example": "if ( IsNodeOccupied( node ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsOnGround",
			"description": "Returns true if entity is on ground",
			"calledOn": "entity",
			"parameters": [],
			"example": "if( self IsOnGround() ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsOnLadder",
			"description": "Return true if the player is on a ladder, false otherwise.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsOnLadder()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsOnSlide",
			"description": "Return true if the player is in the player movement slide.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsOnSlide()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPathfinder",
			"description": "Checks whether this entity is registered with navigation system so it can do pathfinding and position query",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity to check",
					"mandatory": true
				}
			],
			"example": "if ( IsPathfinder( tank ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPaused",
			"description": "Returns whether a given entity is paused as part of a world pause.",
			"calledOn": "entity",
			"parameters": [],
			"example": "if ( ent IsPaused() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayer",
			"description": "Checks whether this entity is the player",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be the player",
					"mandatory": true
				}
			],
			"example": "if ( IsPlayer( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayerNumber",
			"description": "Returns true if the passed in int is a valid client number",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayerSwimming",
			"description": "Return if a player is swimming",
			"calledOn": "player",
			"parameters": [],
			"example": "depth = get_players()[0] IsPlayerSwimming()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayerUnderwater",
			"description": "Return if a player is underwater",
			"calledOn": "player",
			"parameters": [],
			"example": "depth = get_players()[0] IsPlayerUnderwater()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayingAnimScripted",
			"description": "Returns true if the entity is playing in scripted animation.",
			"calledOn": "entity",
			"parameters": [],
			"example": "if(player IsPlayingAnimScripted())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPointInNavVolume",
			"description": "Checks if a given point is within the specified navigation volume.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position to evaluate.",
					"mandatory": true
				},
				{
					"name": "navVolumeName",
					"description": "Either \"navvolume_small\" or \"navvolume_big\".",
					"mandatory": true
				}
			],
			"example": "result = IsPointInNavVolume( (10,20,30), \"small volume\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPointOnNavMesh",
			"description": "Checks if a given point is valid on the NavMesh. This check performs all the necessary validation such as away from boundary, correct material, navmesh trigger, etc.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "Position to evaluate.",
					"mandatory": true
				},
				{
					"name": "entity / radius",
					"description": "the point is for this entity to path to, or an estimate radius of the expected character radius. default to radius 0. Note: not passing in the entity can cause false positive when point is on NavMesh but too close to boundary / on wrong material / in disabled navmesh trigger; or false negative when big character's origin is far below NavMesh but still within tolerant height.",
					"mandatory": false
				}
			],
			"example": "isValid = IsPointOnNavMesh( (10,20,30), self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPoisoned",
			"description": "Check is a player is under the influence of gas",
			"calledOn": null,
			"parameters": [],
			"example": "if ( player IsPoisoned() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsRagdoll",
			"description": "Return true if the entity is a ragdoll body, false otherwise.",
			"calledOn": "player_or_playercorpse",
			"parameters": [],
			"example": "if( player IsRagdoll() ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSentient",
			"description": "Checks whether this entity is a sentient, that is normally either an ai actor, ai vehicle or the player",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be a sentient character",
					"mandatory": true
				}
			],
			"example": "if ( IsSentient( vehicle.riders[j] ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSlamming",
			"description": "Returns true if the player is slamming.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player IsSlamming())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSliding",
			"description": "Returns true if the player is sliding.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player IsSliding())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSpawner",
			"description": "Checks whether this entity is a spawner",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be a spawner",
					"mandatory": true
				}
			],
			"example": "if ( IsSpawner( ent ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSpawnPointVisible",
			"description": "Returns true or false if a point is visible to the given team",
			"calledOn": null,
			"parameters": [
				{
					"name": "point",
					"description": "Spawnpoint origin that needs to be checked",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "Spawnpoint angles that needs to be checked",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "Team that we need to check against the point",
					"mandatory": true
				},
				{
					"name": "ignore player",
					"description": "The player that we are spawning in",
					"mandatory": true
				}
			],
			"example": "if ( IsSpawnPointVisible( point_position, point_angles, \"axis\", player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSplitScreen",
			"description": "Returns true if the game is a splitscreen game",
			"calledOn": null,
			"parameters": [],
			"example": "level.splitscreen = IsSplitScreen()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSprinting",
			"description": "Returns true if the player is sprinting.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player IsSprinting())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsStarterPack",
			"description": "Returns true if the player has starter pack",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self IsStarterPack() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsStartingClassDefault",
			"description": "Returns true if the starting class is the default class for the level",
			"calledOn": "player",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsStreamerReady",
			"description": "Is the players streamer ready.",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsStreamerReady()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTestClient",
			"description": "Returns true if the player is a test client (Does not have a remote user).",
			"calledOn": "player",
			"parameters": [],
			"example": "if( self IsTestClient() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTouching",
			"description": "Returns true if <other entity> is touching <entity>",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "other entity",
					"description": "Entity.",
					"mandatory": true
				}
			],
			"example": "if( player IsTouching( e_goal_volume ) ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTouchingSwept",
			"description": "Returns true if <other entity> is touching <entity>",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "other entity",
					"description": "Entity.",
					"mandatory": true
				}
			],
			"example": "if( player IsTouchingSwept( e_goal_volume ) ) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTouchingVolume",
			"description": "Returns true if entity is touching the volume.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "origin",
					"description": "Origin of the volume",
					"mandatory": true
				},
				{
					"name": "volume mins",
					"description": "The min extents of the volume",
					"mandatory": true
				},
				{
					"name": "volume maxs",
					"description": "The max extents of the volume",
					"mandatory": true
				}
			],
			"example": "if ( crate_ent IsTouchingVolume( origin + (0,0,40), mins, maxs ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTraversing",
			"description": "Returns true if the player is traversing.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player IsTraversing())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTriggerEnabled",
			"description": "Returns true if trigger is enabled. False otherwise",
			"calledOn": "trigger",
			"parameters": [],
			"example": "if( trig isTriggerEnabled() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTurretFiring",
			"description": "Checks if this turret is firing",
			"calledOn": "turret",
			"parameters": [],
			"example": "if( IsTurretFiring( roof_turret ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTurretLockedOn",
			"description": "Checks whether this turret is locked onto a target. The entity must be a turret",
			"calledOn": "turret",
			"parameters": [],
			"example": "turret IsTurretLockedOn()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsUsingNavVolume",
			"description": "Checks whether this entity is using Nav Volume. Note this is a relatively low level check. For general gameplay check whether an entity is flying, consider using IsAirborne.",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object",
					"mandatory": true
				}
			],
			"example": "if ( IsUsingNavVolume( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "isUsingT7Melee",
			"description": "Returns true T7 Melee system is being used",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsValidGametype",
			"description": "Returns true if the string is a valid game type",
			"calledOn": null,
			"parameters": [
				{
					"name": "game type",
					"description": "a string to check",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicle",
			"description": "Checks whether this entity is an ai character",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be an ai character",
					"mandatory": true
				}
			],
			"example": "if ( IsVehicle( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleSpawner",
			"description": "Checks whether this entity is a vehicle spawner",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity object that may be a vehicle spawner",
					"mandatory": true
				}
			],
			"example": "if ( IsVehicleSpawner( ent ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "isvr",
			"description": "check if this player has VR enabled",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWallRunning",
			"description": "Returns true if the player is wall running.",
			"calledOn": "player",
			"parameters": [],
			"example": "if(player IsWallRunning())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWallrunNode",
			"description": "returns true if the node has the PNF_WALLRUN flag set",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The node to check",
					"mandatory": true
				}
			],
			"example": "IsWallrunNode( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWorldPaused",
			"description": "returns whether or not the world is currently paused",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsWorldPaused() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsZBarrier",
			"description": "Returns true if the entity called on is a zbarrier.",
			"calledOn": "entity",
			"parameters": [],
			"example": "if(ent IsZBarrier())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsZBarrierClosed",
			"description": "Returns true if the state of all of the zbarrier's pieces is 'closed'.",
			"calledOn": "entity",
			"parameters": [],
			"example": "closed = ent IsZBarrierClosed())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsZBarrierOpen",
			"description": "Returns true if the state of all of the zbarrier's pieces is 'open'.",
			"calledOn": "entity",
			"parameters": [],
			"example": "open = ent IsZBarrierOpen())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ItemWeaponSetAmmo",
			"description": "Set the weapon ammo to the given clip ammo and reserve ammo. Can give an alternate weapon index",
			"calledOn": "item",
			"parameters": [
				{
					"name": "clipAmmo",
					"description": "Ammo for the clip",
					"mandatory": true
				},
				{
					"name": "reserveAmmo",
					"description": "Reserve ammo",
					"mandatory": true
				},
				{
					"name": "altIndex",
					"description": "Alternate weapon index",
					"mandatory": false
				}
			],
			"example": "weap ItemWeaponSetAmmo( clip, extra, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Kick",
			"description": "Kicks the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "clientnum",
					"description": "The client number of the player to kick.",
					"mandatory": true
				}
			],
			"example": "Kick( 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Kill",
			"description": "Kills this entity. If the entity could not be killed, errors. Automatically sets setCanDamage( true ).",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "source position",
					"description": "The position that the damage comes from. Defaults to entity's origin",
					"mandatory": false
				},
				{
					"name": "attacker",
					"description": "The entity that dealt the damage (such as an AI or player)",
					"mandatory": false
				},
				{
					"name": "inflictor",
					"description": "The entity that the damage came from (such as a grenade or turret)",
					"mandatory": false
				},
				{
					"name": "weapon",
					"description": "weapon to do damage with",
					"mandatory": false
				}
			],
			"example": "level.player kill()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "KillClientRadiantExploder",
			"description": "Deactivates a client side radiant exploder",
			"calledOn": null,
			"parameters": [
				{
					"name": "exploder id",
					"description": "string id of exploder to deactivate",
					"mandatory": true
				}
			],
			"example": "DeactivateClientRadiantExploder( \"light_switch\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "KillServer",
			"description": "kills the server",
			"calledOn": null,
			"parameters": [],
			"example": "KillServer()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LaserOff",
			"description": "Turns off entity's laser sight.",
			"calledOn": "entity",
			"parameters": [],
			"example": "self LaserOff()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LaserOn",
			"description": "Turns on entity's laser sight.",
			"calledOn": "entity",
			"parameters": [],
			"example": "self LaserOn()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Launch",
			"description": "Launch an object that interacts with the world, using an initial velocity. From this point on this object will no longer block either missiles or bullets.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "initial velocity",
					"description": "The initial velocity of the launch.",
					"mandatory": true
				},
				{
					"name": "initial angular velocity",
					"description": "The initial angular velocity of the launch.",
					"mandatory": false
				}
			],
			"example": "self Launch( (x, y, z) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LaunchRagdoll",
			"description": "Launch this ragdoll.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "force",
					"description": "launch force",
					"mandatory": true
				},
				{
					"name": "bonename",
					"description": "bone name to apply the force to",
					"mandatory": false
				}
			],
			"example": "self LaunchRagdoll( (0,0,100) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LaunchVehicle",
			"description": "Launch this physics vehicle.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "force",
					"description": "launch force",
					"mandatory": true
				},
				{}
			],
			"example": "panzer LaunchVehicle( (0,0,100) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LerpViewAngleClamp",
			"description": "Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "time",
					"description": "Lerp duration in seconds. A value of 0 means instantaneous.",
					"mandatory": true
				},
				{
					"name": "accel time",
					"description": "Acceleration time.",
					"mandatory": true
				},
				{
					"name": "decel time",
					"description": "Decelaration time.",
					"mandatory": true
				},
				{
					"name": "right arc",
					"description": "Angle to clamp view to the right.",
					"mandatory": true
				},
				{
					"name": "left arc",
					"description": "Angle to clamp view to the left.",
					"mandatory": true
				},
				{
					"name": "top arc",
					"description": "Angle to clamp view to the top.",
					"mandatory": true
				},
				{
					"name": "bottom arc",
					"description": "Angle to clamp view to the bottom.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkNodes",
			"description": "Connects node1 to node2. Call it again with arguments flipped if you want a two-way connection.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node1",
					"description": "first node to link",
					"mandatory": true
				},
				{
					"name": "node2",
					"description": "second node to link",
					"mandatory": true
				}
			],
			"example": "LinkNodes( node_moving_elev_left, node_moving_elev_right )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkTo",
			"description": "Attaches one entity to another",
			"calledOn": "non_player_entity",
			"parameters": [
				{
					"name": "linkto entity",
					"description": "The entity to attach this thing to",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the entity to",
					"mandatory": false
				},
				{
					"name": "originOffset",
					"description": "The positional offset from the base position",
					"mandatory": false
				},
				{
					"name": "anglesOffset",
					"description": "The angular offset from the base angles",
					"mandatory": false
				}
			],
			"example": "self.rightturret LinkTo( self, \"tag_gunRight\", (0,0,0), (0,0,0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkToBlendToTag",
			"description": "Attaches one entity to another, gradually lerping entity to the parents orientation",
			"calledOn": "non_player_entity",
			"parameters": [
				{
					"name": "linkto entity",
					"description": "The entity to attach this thing to",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the entity to",
					"mandatory": false
				},
				{
					"name": "only yaw",
					"description": "Tells if blending only the yaw. Default to true.",
					"mandatory": false
				},
				{
					"name": "collision physics",
					"description": "Sets whether we should use collision physics. Defaults to false.",
					"mandatory": false
				}
			],
			"example": "self.rightturret LinkToBlendToTag( self, \"tag_gunRight\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkToUpdateOffset",
			"description": "Attaches one entity to another, gradually lerping entity to the parents orientation",
			"calledOn": "non_player_entity",
			"parameters": [
				{
					"name": "origin_offset",
					"description": "The origin offset",
					"mandatory": true
				},
				{
					"name": "angles_offset",
					"description": "The angles offset",
					"mandatory": false
				}
			],
			"example": "self.rightturret LinkToUpdateOffset( originsOffset, anglesOffset )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkTraversal",
			"description": "Creates a user edge connecting two path nodes",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "Negotiation begin node",
					"mandatory": true
				}
			],
			"example": "LinkTraversal( beginNode )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LoadSentientEventParameters",
			"description": "Loads the global sentient event parameters for a given scriptbundle sentient events asset. (all AI will use these)",
			"calledOn": null,
			"parameters": [
				{
					"name": "scriptBundle",
					"description": "String name of the script bundle to load",
					"mandatory": true
				}
			],
			"example": "LoadSentientEventParameters( \"sentientevents\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LocalToWorldCoords",
			"description": "Transform the given local coordinate point to a world coordinate point",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "local coordinate",
					"description": "The point in local coordinates (vector3)",
					"mandatory": true
				}
			],
			"example": "ramboPoint = self LocalToWorldCoords( delta )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LookAtEntity",
			"description": "Set this actor to look at the specified entity. Call this function without any entity specified to turn it off.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "otherguy",
					"description": "the other guy to look at",
					"mandatory": false
				}
			],
			"example": "guy LookAtEntity( otherguy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LookAtPos",
			"description": "Set this actor to look at the specified position. Call this function without any position specified to turn it off.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "pos",
					"description": "the position to look at",
					"mandatory": false
				}
			],
			"example": "guy LookAtPos( pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LUINotifyEvent",
			"description": "Sends a notify from script to LUI.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player",
					"description": "the player to notify. If not specified, all players are notified.",
					"mandatory": false
				},
				{
					"name": "lui event name",
					"description": "as an IString",
					"mandatory": true
				},
				{
					"name": "num of args",
					"description": "number of parameters",
					"mandatory": true
				},
				{
					"name": "args",
					"description": "argument to pass to LUI",
					"mandatory": true
				}
			],
			"example": "LUINotifyEvent( &\"update_objectives\", 1, &\"LEVEL_GOTO_NEXT_PLACE\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LUINotifyEventToSpectators",
			"description": "Sends a notify from script to LUI.",
			"calledOn": null,
			"parameters": [
				{
					"name": "lui event name",
					"description": "as an IString",
					"mandatory": true
				},
				{
					"name": "num of args",
					"description": "number of parameters",
					"mandatory": true
				},
				{
					"name": "args",
					"description": "argument to pass to LUI",
					"mandatory": true
				}
			],
			"example": "LUINotifyEventToSpectators( &\"update_objectives\", 1, &\"LEVEL_GOTO_NEXT_PLACE\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicBullet",
			"description": "Creates a magic bullet at the source",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "Weapon type of the bullet",
					"mandatory": true
				},
				{
					"name": "source",
					"description": "Where the bullet will be spawned",
					"mandatory": true
				},
				{
					"name": "destination",
					"description": "Where the bullet will be fired at",
					"mandatory": true
				},
				{
					"name": "attacker",
					"description": "Set the owner of the bullet to this",
					"mandatory": false
				},
				{
					"name": "targetent",
					"description": "The target of the bullet",
					"mandatory": false
				},
				{
					"name": "targetOffset",
					"description": "Offset the target by this vector",
					"mandatory": false
				}
			],
			"example": "MagicBullet( GetWeapon(\"sniper_hyperion\"), level.sniper_loc.origin, target GetTagOrigin( \"tag_eye\" ), level.sniper_boss)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicGrenade",
			"description": "Creates a \"Magic\" grenade from an actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "origin",
					"description": "The starting point of the grenade toss",
					"mandatory": true
				},
				{
					"name": "target position",
					"description": "The target point of the grenade toss",
					"mandatory": true
				},
				{
					"name": "time to blow",
					"description": "The grenade fuse time in seconds",
					"mandatory": false
				},
				{
					"name": "weapon",
					"description": "The grenade weapon to use (defaults to equipped grenade weapon)",
					"mandatory": false
				}
			],
			"example": "self MagicGrenade( self.origin, target.origin, 2.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicGrenadeManual",
			"description": "creates a \"Magic\" grenade from an actor",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "origin",
					"description": "The starting point of the grenade toss",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "The initial velocity vector for the grenade movement",
					"mandatory": true
				},
				{
					"name": "time to blow",
					"description": "The grenade fuse time in seconds",
					"mandatory": false
				}
			],
			"example": "self MagicGrenadeManual( self.origin, target.origin, 2.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicGrenadeManualPlayer",
			"description": "creates a \"Magic\" grenade from a player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "origin",
					"description": "The starting point of the grenade toss",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "The initial velocity vector for the grenade movement",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The grenade weapon to base on",
					"mandatory": true
				},
				{
					"name": "time to blow",
					"description": "The grenade fuse time in seconds",
					"mandatory": false
				}
			],
			"example": "self MagicGrenadeManualPlayer( self.origin, target.origin, 2.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicGrenadePlayer",
			"description": "Creates a \"Magic\" grenade from a player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The grenade weapon to use",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The starting point of the grenade toss",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "The initial velocity vector for the grenade movement",
					"mandatory": true
				}
			],
			"example": "MagicGrenadePlayer( \"sticky_grenade_mp\", self.origin, toss_velocity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicGrenadeType",
			"description": "Fire a 'magic grenade', from the source location towards the destination point.",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponName",
					"description": "The name of the weapon",
					"mandatory": true
				},
				{
					"name": "sourceLoc",
					"description": "The grenade starting point",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "The velocity of the grenade",
					"mandatory": true
				},
				{
					"name": "time to blow",
					"description": "The grenade fuse time in seconds",
					"mandatory": false
				}
			],
			"example": "ent MagicGrenadeType( \"fraggrenade\", self.origin, myVelocity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MagicMissile",
			"description": "Launches a weapon from the given position with the given velocity.  Velocity determines direction.",
			"calledOn": "attacker",
			"parameters": [
				{
					"name": "weapon",
					"description": "- Weapon name.",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "- Position to launch from.",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "- Direction and force of launch.",
					"mandatory": true
				},
				{
					"name": "targetent",
					"description": "The target of the bullet",
					"mandatory": false
				}
			],
			"example": "bomb = player MagicMissile( \"artillery_mp\", (100,100,0), ( 0.1, 0.1, 0.1 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeFakeAI",
			"description": "Create a drone from script model, that can be moved around with simple commands",
			"calledOn": "script_model",
			"parameters": [],
			"example": "guy MakeFakeAI()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeGrenadeDud",
			"description": "Turns a grenade into a dud",
			"calledOn": "grenade",
			"parameters": [],
			"example": "grenade MakeGrenadeDud()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakePathfinder",
			"description": "Register a vehicle with Havok so it can do pathfinding and position query",
			"calledOn": "vehicle",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeSentient",
			"description": "Turn a vehicle or script mover into a sentient.",
			"calledOn": "entity",
			"parameters": [],
			"example": "heli MakeSentient()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeTurretUnusable",
			"description": "Sets a turret to be unable to be used",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret MakeTurretUnusable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeTurretUsable",
			"description": "Sets a turret able to be used",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret MakeTurretUsable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeUnusable",
			"description": "Sets this entity to be not usable by the player",
			"calledOn": "entity",
			"parameters": [],
			"example": "mover MakeUsable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeUsable",
			"description": "Sets this entity to be usable by the player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "team",
					"description": "The team that is allowed to use the object. Only for script movers.",
					"mandatory": false
				}
			],
			"example": "mover MakeUsable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Map",
			"description": "Loads a new map",
			"calledOn": null,
			"parameters": [
				{
					"name": "map name",
					"description": "The map to load",
					"mandatory": true
				},
				{
					"name": "save persistent",
					"description": "if true then player info is retained",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Map_Restart",
			"description": "Restarts the map",
			"calledOn": null,
			"parameters": [
				{
					"name": "save persistent",
					"description": "if true then player info is retained",
					"mandatory": false
				}
			],
			"example": "Map_Restart( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MapExists",
			"description": "Returns true if the map with the given name exists on the server",
			"calledOn": null,
			"parameters": [
				{
					"name": "map name",
					"description": "The map to check.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MarkDestructibleDestroyed",
			"description": "set destructible destroyed",
			"calledOn": "destructible",
			"parameters": [],
			"example": "barrel MarkDestructibleDestroyed()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MarkNoVehicleNavMeshFaces",
			"description": "Update the novehicle flag on navmesh faces. This should only be used in MP map for now.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "matchRecordOvertimeRound",
			"description": "call after matchRecordRoundStart to mark the round as an overtime round (only first overtimee round is actually recorded)",
			"calledOn": null,
			"parameters": [],
			"example": "matchRecordOvertimeRound()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "matchRecordRoundStart",
			"description": "need a hook for round starts, to get time stamps",
			"calledOn": null,
			"parameters": [],
			"example": "matchRecordRoundStart()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Matrix4x4TransformPoints",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MaySpawnEntity",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MaySpawnFakeEntity",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_DroneSetVisible",
			"description": "Set the missile or drone to be visible",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "flag",
					"description": "True to set visible, false otherwise",
					"mandatory": true
				}
			],
			"example": "self Missile_DroneSetVisible( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_GetTarget",
			"description": "Sets the target of the missile to the given entity, and resets if no entity is specified.",
			"calledOn": "missile",
			"parameters": [],
			"example": "target = missile Missile_GetTarget()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "missile_settarget",
			"description": "Sets the target of the missile to the given entity, and resets if no entity is specified.",
			"calledOn": "missile",
			"parameters": [
				{
					"name": "target",
					"description": "The target of the missile",
					"mandatory": false
				},
				{
					"name": "targetOffset",
					"description": "Offset to the target location (vector3)",
					"mandatory": false
				}
			],
			"example": "self missile_settarget( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MissionFailed",
			"description": "Restarts the map",
			"calledOn": null,
			"parameters": [],
			"example": "MissionFailed()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MissionHasAccolades",
			"description": "Returns whether or not this mission has any accolades associated with it",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.has_accolades = MissionHasAccolades( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MissionHasCollectibles",
			"description": "Returns whether or not this mission has any collectibles in it",
			"calledOn": null,
			"parameters": [
				{
					"name": "currentmap",
					"description": "the name of the current map.  If ommitted, use Dvar sv_mapname",
					"mandatory": false
				}
			],
			"example": "level.has_collectibles = MissionHasCollectibles( \"cp_mi_cairo_ramses2\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MissionRestart",
			"description": "Restarts the mission, which might take you to a different BSP if this is a sublevel",
			"calledOn": null,
			"parameters": [],
			"example": "MissionRestart()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveGravity",
			"description": "Fling this entity.",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "initial velocity",
					"description": "The initial velocity to fling this entity at",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to move the entity in seconds",
					"mandatory": true
				}
			],
			"example": "self MoveGravity( break_vector, time )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveSlide",
			"description": "Launches the entity in the given velocity. When on the ground it will slide smoothly. Call StopMoveSlide to make it stop moving.",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "center",
					"description": "The center of the entity's collision with the ground",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the entity's collision with the ground",
					"mandatory": true
				},
				{
					"name": "initial velocity",
					"description": "The initial velocity to move the entity at",
					"mandatory": true
				}
			],
			"example": "self MoveSlide( 16, anglesToForward( self.angles ) * 10 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveTo",
			"description": "Move this entity to the given point.",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "point",
					"description": "The point to move the entity to",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to move the entity in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating",
					"mandatory": false
				}
			],
			"example": "dummy MoveTo( dest_org, .5, .05, .05 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveX",
			"description": "Move this entity to the given world x value",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "point",
					"description": "The x value to move the entity to, as a floating point number",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to move the entity in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "train MoveX( -4400, 60, 15, 20 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveY",
			"description": "move this entity to the given world y value",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "point",
					"description": "The y value to move the entity to, as a floating point number",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to move the entity in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "hangardoor MoveY( 320, 10 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveZ",
			"description": "Move this entity to the given world z value",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "point",
					"description": "The z value to move the entity to, as a floating point number",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to move the entity in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NavPointSightFilter",
			"description": "Given an array of navmesh points, filters the array based on navmesh visibility to an origin.",
			"calledOn": null,
			"parameters": [
				{
					"name": "points",
					"description": "Array of navmesh points",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "Origin to check visibility from",
					"mandatory": true
				},
				{
					"name": "checksight",
					"description": "True to check sight, false otherwise",
					"mandatory": false
				}
			],
			"example": "points = NavPointSightFilter( points, nearest )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NeedsRevive",
			"description": "Used for mini maps to display compass icon",
			"calledOn": null,
			"parameters": [
				{
					"name": "bool",
					"description": "does player need to be reived",
					"mandatory": true
				}
			],
			"example": "self NeedsRevive( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NodesAreLinked",
			"description": "Returns true if node1 is connected to node2.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node1",
					"description": "first node",
					"mandatory": true
				},
				{
					"name": "node2",
					"description": "second node",
					"mandatory": true
				}
			],
			"example": "NodesAreLinked( node_moving_elev_left, node_moving_elev_right )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NodesVisible",
			"description": "Returns true if these nodes are visible to one another, false otherwise.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node1",
					"description": "pathnode to check",
					"mandatory": true
				},
				{
					"name": "node2",
					"description": "pathnode to check against node1",
					"mandatory": true
				}
			],
			"example": "if ( NodesVisible( cover, guy.node ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NotSolid",
			"description": "Unsets the solid flag, so that this object is no longer collidable.",
			"calledOn": "ent",
			"parameters": [],
			"example": "self NotSolid()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NumRemoteClients",
			"description": "Returns the number of remote clients connected to the game.  Very useful for scaling content for coop play, and network balancing.",
			"calledOn": null,
			"parameters": [],
			"example": "num_remote_clients = NumRemoteClients()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Obituary",
			"description": "Create an obituary for a character",
			"calledOn": null,
			"parameters": [
				{
					"name": "victim",
					"description": "The victim entity",
					"mandatory": true
				},
				{
					"name": "attacker",
					"description": "The attacker entity",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon name",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The means of death as a string",
					"mandatory": true
				}
			],
			"example": "Obituary( self, attacker, sWeapon, sMeansOfDeath )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Add",
			"description": "Add a new objective, with ability to specify all the info for the objective",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The number of the objective to add",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "A string value representing the state of the objective. Valid states are \"empty\", \"active\", \"invisible\", \"done\", \"current\" and \"failed\"",
					"mandatory": true
				},
				{
					"name": "position/onEntity",
					"description": "The position of the objective - or - <entity> entity to be tracked.",
					"mandatory": false
				},
				{
					"name": "displayName",
					"description": "The text to use for the objective. This should be a valid localized text reference",
					"mandatory": false
				},
				{
					"name": "entity",
					"description": "The owner entity",
					"mandatory": false
				}
			],
			"example": "Objective_Add( objective_number, \"active\", closest.bomb.origin, objective_text, self.objective )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_ClearAllUsing",
			"description": "Clears the objective of all players using status.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_ClearEntity",
			"description": "Clears the entity previous set on the objective",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_ClearPlayerUsing",
			"description": "Sets the objective to be not being used by the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player who is no longer using the objective",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Delete",
			"description": "Deletes the objective",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				}
			],
			"example": "Objective_Delete( objective_number )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_GetGamemodeFlags",
			"description": "Gets the gamemode flags for the objective.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective.",
					"mandatory": true
				}
			],
			"example": "flags = Objective_GetGamemodeFlags( myObjNumber )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Icon",
			"description": "Set the objective icon",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "icon",
					"description": "The icon name",
					"mandatory": true
				}
			],
			"example": "objective_icon( crateObjID, \"compass_supply_drop_black\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_OnEntity",
			"description": "Sets the objective to get its position from an entity.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "The entity to set the objective to",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Position",
			"description": "Set the objective position",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "The position to set",
					"mandatory": true
				}
			],
			"example": "objective_position( self.objectiveID, self.curOrigin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Set3D",
			"description": "Sets flag determining if 3D state for an objective is drawn.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "use3D",
					"description": "true if should render in hud",
					"mandatory": true
				},
				{
					"name": "unused",
					"description": "not used",
					"mandatory": false
				},
				{
					"name": "unused",
					"description": "not used",
					"mandatory": false
				},
				{
					"name": "unused",
					"description": "not used",
					"mandatory": false
				},
				{
					"name": "unused",
					"description": "not used",
					"mandatory": false
				}
			],
			"example": "Objective_Set3D( myObjNum, true, undefined, undefined, undefined, (0,0,70) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetColor",
			"description": "Sets a color for the objective that the icon will then be drawn with.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective.",
					"mandatory": true
				},
				{
					"name": "r/colorName",
					"description": "Red float value for objective, or color name set from the UIEditor as an IString.",
					"mandatory": true
				},
				{
					"name": "g",
					"description": "Green float value for objective.",
					"mandatory": false
				},
				{
					"name": "b",
					"description": "Blue float value for objective.",
					"mandatory": false
				},
				{
					"name": "a",
					"description": "Alpha float value for objective. Default of 1.0 if not specified.",
					"mandatory": false
				}
			],
			"example": "Objective_SetColor( myObjNumber, 1.0, 0.0, 0.0, 1.0 )Objective_SetColor( myObjNumber, \"FriendlyBlue\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetFlag",
			"description": "Sets the gamemode flags for the objective.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "flag",
					"description": "- active, fadeoutonscreen, perk, drawdistance, drawname, in3d, clipToMap, primary",
					"mandatory": true
				},
				{
					"name": "true/false",
					"description": "turn the flag on or off",
					"mandatory": true
				}
			],
			"example": "Objective_SetFlag( myObjNumber, \"active\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetGamemodeFlags",
			"description": "Sets the gamemode flags for the objective.  This function only works for modes not using 3d objectives (mp).",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective.",
					"mandatory": true
				},
				{
					"name": "flags",
					"description": "script managed flags.",
					"mandatory": true
				}
			],
			"example": "Objective_SetGamemodeFlags( myObjNumber, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetInvisibleToAll",
			"description": "Sets the objective to be invisible to all players.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetInvisibleToPlayer",
			"description": "Sets the objective to be invisible to the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player to whom the objective is now invisible",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetInvisibleToPlayerByIndex",
			"description": "Sets the objective to be invisible to the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "entnum",
					"description": "The entity number of the player to whom the objective is now invisible",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetPlayerUsing",
			"description": "Sets the objective to being used by the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player who is using the objective",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetProgress",
			"description": "Sets the progress for the objective.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective.",
					"mandatory": true
				},
				{
					"name": "percent",
					"description": "percent float value for objective [0-1].",
					"mandatory": true
				}
			],
			"example": "Objective_SetProgress( myObjNumber, 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetSize",
			"description": "Sets a size for the objective that the icon will then be drawn at. Min is MIN_OBJECTIVE_ICON_SIZE = 5",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The ID of the objective.",
					"mandatory": true
				},
				{
					"name": "entity/float",
					"description": "The entity to get the size from or a sizeX.",
					"mandatory": true
				},
				{
					"name": "float",
					"description": "If sizeX was used in prvious arg, this is sizeY.",
					"mandatory": false
				}
			],
			"example": "Objective_SetSize( myObjNumber, myTrigger )Objective_SetSize( myObjNumber, 20, 30 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetUIModelValue",
			"description": "Set a UI Model Value for an objective",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "lui menu data name",
					"description": "precached name string for the data which we're trying to set.",
					"mandatory": true
				},
				{
					"name": "lui menu data value",
					"description": "value for the data which we're trying to set on the objective.",
					"mandatory": true
				}
			],
			"example": "Objective_SetUIModelValue( 0, \"killedCount\", 4 ); or Objective_SetUIModelValue( 0, \"killedCount\", \"Four\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetVisibleToAll",
			"description": "Sets the objective to be visible to all players.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetVisibleToPlayer",
			"description": "Sets the objective to be visible to the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player to whom the objective is now visible",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_SetVisibleToPlayerByIndex",
			"description": "Sets the objective to be visible to the specified player.",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "entnum",
					"description": "The entity number of the player to whom the objective is now visible",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_State",
			"description": "Set a state for the objective",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "The state to set",
					"mandatory": true
				}
			],
			"example": "Objective_State( obj_id, \"active\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_Team",
			"description": "Sets the team that the objective is for. Allows having different objectives for each team",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'",
					"mandatory": true
				}
			],
			"example": "Objective_Team( 0, \"allies\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Objective_VisibleTeams",
			"description": "Sets the team that the objective is visible too for. Allows having different objectives for each team",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_number",
					"description": "The ID of the objective to alter",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'",
					"mandatory": true
				}
			],
			"example": "Objective_VisibleTeams( 0, 01101101 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OffhandWeaponsEnabled",
			"description": "Determine if offhand weapons are enabled for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "enabled = player OffhandWeaponsEnabled()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OverrideSpawnflags",
			"description": "Sets the spawnflags on this entity.  Used for patching.",
			"calledOn": "entity",
			"parameters": [],
			"example": "entity OverrideSpawnflags( 64 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathDistance",
			"description": "Returns the approximate/semi-accurate path distance between two points or undefined if no path can be found.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": ".",
					"mandatory": true
				},
				{
					"name": "end",
					"description": ".",
					"mandatory": true
				},
				{
					"name": "generatePathForAccurateDist",
					"description": "If set to true, a real path will be generated and the total length of the path segments will be returned.",
					"mandatory": false
				},
				{
					"name": "pathEnt",
					"description": "Only used when generatePathForAccurateDist is set. pathEnt will be used for generating a path, so it will respect the movement type. Only supported for actors.",
					"mandatory": false
				},
				{
					"name": "pathDistanceType",
					"description": "The method of pathdistance calculation. Two options are PATHDIST_APPROXIMATE(using getApproximateFuturePositions), PATHDIST_CORNERPREDICTED (using getCornerPredictor).",
					"mandatory": false
				},
				{
					"name": "maxCornerPredictions",
					"description": "Maximum number of cornerPrediction steps when PATHDIST_CORNERPREDICTED is used. Handles the edge case when cornerPrediction may not ever finish stepping the path all the way.",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsExplosionCylinder",
			"description": "Created a physics explosion cylinder",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The origin of the cylinder",
					"mandatory": true
				},
				{
					"name": "outer radius",
					"description": "The outer radius of the cylinder",
					"mandatory": true
				},
				{
					"name": "inner radius",
					"description": "The inner radius of the cylinder",
					"mandatory": true
				},
				{
					"name": "magnitude",
					"description": "The magnitude of the explosion",
					"mandatory": true
				}
			],
			"example": "PhysicsExplosionCylinder( self.origin, 600, 240, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsExplosionSphere",
			"description": "Create a physics explosion sphere",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The origin of the sphere",
					"mandatory": true
				},
				{
					"name": "outer radius",
					"description": "The outer radius of the sphere",
					"mandatory": true
				},
				{
					"name": "inner radius",
					"description": "The inner radius of the sphere",
					"mandatory": true
				},
				{
					"name": "magnitude",
					"description": "The magnitude of the explosion",
					"mandatory": true
				},
				{
					"name": "outer damage",
					"description": "The optional outer damage",
					"mandatory": false
				},
				{
					"name": "inner damage",
					"description": "The optional inner damage",
					"mandatory": false
				}
			],
			"example": "PhysicsExplosionSphere( origin, radius, radius, 5, max_damage, min_damage )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsJetThrust",
			"description": "Creates a physics jet thrust",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "origin of the thrust",
					"mandatory": true
				},
				{
					"name": "weapon facing dir",
					"description": "The weapon facing direction",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the thrust",
					"mandatory": true
				},
				{
					"name": "magnitude",
					"description": "The magnitude of the thrust",
					"mandatory": true
				},
				{
					"name": "angle limit",
					"description": "The angle limit for the thrust",
					"mandatory": true
				}
			],
			"example": "PhysicsJetThrust( self.origin, (0,0,1), 400, 1, 60)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsJolt",
			"description": "Create a physics radius jolt",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The origin of the jolt",
					"mandatory": true
				},
				{
					"name": "outer radius",
					"description": "The outer radius of the jolt",
					"mandatory": true
				},
				{
					"name": "inner radius",
					"description": "The inner radius of the jolt",
					"mandatory": true
				},
				{
					"name": "impulse",
					"description": "The impulse created by the explosion",
					"mandatory": true
				}
			],
			"example": "PhysicsJolt( self.origin, 600, 240, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsLaunch",
			"description": "Permanently turn this entity into a physics object with an intial force vector at the specified point.",
			"calledOn": "script_model",
			"parameters": [
				{
					"name": "contact_point",
					"description": "The point to apply the initial force",
					"mandatory": false
				},
				{
					"name": "initial_force",
					"description": "The force vector to apply",
					"mandatory": false
				}
			],
			"example": "dummy PhysicsLaunch( contact_point, initial_force )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsTrace",
			"description": "Does a physics trace from start to end. Returns hit position",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "starting position",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "ending position",
					"mandatory": true
				},
				{
					"name": "mins",
					"description": "minimum bounds",
					"mandatory": false
				},
				{
					"name": "maxs",
					"description": "maximum bounds",
					"mandatory": false
				},
				{
					"name": "ignore entity",
					"description": "the entity to not consider",
					"mandatory": false
				},
				{
					"name": "mask type",
					"description": "the trace modifier",
					"mandatory": false
				}
			],
			"example": "trace = PhysicsTrace( start, end, ( 0, 0, 0 ), ( 0, 0, 0 ), self, PHYSICS_TRACE_MASK_VEHICLE_CLIP )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PhysicsTraceEx",
			"description": "Physics trace, ignoring characters. Returns the full trace structure.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The end point",
					"mandatory": true
				},
				{
					"name": "mins",
					"description": "trace capsule min",
					"mandatory": false
				},
				{
					"name": "maxs",
					"description": "trace capsule max",
					"mandatory": false
				},
				{
					"name": "entity",
					"description": "entity to ignore",
					"mandatory": false
				},
				{
					"name": "player clip",
					"description": "collide with the player solid mask instead of ai solid mask",
					"mandatory": false
				}
			],
			"example": "trace = PhysicsTraceEx( start, end, (-10,-10,0), (10,10,0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaceSpawnPoint",
			"description": "Raises the spawn point up to make sure it's not in the ground, then drops it back down into the ground.",
			"calledOn": "spawn point",
			"parameters": [],
			"example": "spawnpoints[i] PlaceSpawnPoint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayBattleChatterToTeam",
			"description": "Play the sound alias as if coming from the entity, so that only one team can hear it",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname1",
					"description": "The first sound alias to play",
					"mandatory": true
				},
				{
					"name": "aliasname2",
					"description": "The second sound alias to play",
					"mandatory": true
				},
				{
					"name": "teamname",
					"description": "The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.",
					"mandatory": true
				},
				{
					"name": "ignoreplayer",
					"description": "If present, this player will not hear the sound.",
					"mandatory": false
				}
			],
			"example": "self PlaySoundToTeam( \"frag_out\", \"axis\", self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerBulletTrace",
			"description": "Allows script to do a bullet point trace with CONTENTS_PLAYER, collides with player hitboxes. Returns hit position, hit entity, hit surface normal.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The bullet start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The bullet end point",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore",
					"mandatory": true
				}
			],
			"example": "trace = PlayerBulletTrace( magicBulletOrigin.origin, eyePos, undefined )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerCamLinkTo",
			"description": "Sets the player's vision to look through another entity.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": "Entity to look through.",
					"mandatory": true
				},
				{
					"name": "tagname",
					"description": "Name of tag on host model to attach to.",
					"mandatory": true
				}
			],
			"example": "level.player2 CameraLinkTo( cameraUpstairs, \"tag_player\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerCamUnlink",
			"description": "Unlinks the player's vision from an entity.",
			"calledOn": "player",
			"parameters": [],
			"example": "level.player2 CameraUnlink( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerGrappleTrace",
			"description": "Trace to see if grapple is valid",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "starting position",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "ending position",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "this entity should be ignored",
					"mandatory": false
				}
			],
			"example": "hitp = PlayerGrappleTrace(player.origin, player.origin + (0,0,-500))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkedOffsetDisable",
			"description": "If disabled, the linked player's orientation will not use their link offset.",
			"calledOn": "linked_player",
			"parameters": [],
			"example": "ac130guy PlayerLinkedOffsetDisable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkedOffsetEnable",
			"description": "If enabled, the linked player's orientation will use their link offset. This is traditional (CoD4) LinkTo behavior for a player.",
			"calledOn": "linked_player",
			"parameters": [],
			"example": "ac130guy PlayerLinkedOffsetEnable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkedSetUseBaseAngleForViewClamp",
			"description": "Sets the whether the player's view clamp is based on the entity (true) or the tag selected (false). Must be called after linking using WeaponViewToDelta",
			"calledOn": "linked_player",
			"parameters": [
				{
					"name": "enable",
					"description": "whether or not to enable using the base entity for the view angle clamp base.",
					"mandatory": true
				}
			],
			"example": "player PlayerLinkedSetUseBaseAngleForViewClamp( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkTo",
			"description": "Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. Rotating the parent entity/tag will not move the player's eye position, but only the player's view angles. Thus, the player's eye position is locked in place, always directly above the parent tag.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "linkto entity",
					"description": "The entity to attach the player to.",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the player to.",
					"mandatory": false
				},
				{
					"name": "view fraction",
					"description": "How much the change in the tag's rotation effects the players view. Defaults to 0.",
					"mandatory": false
				},
				{
					"name": "right arc",
					"description": "Angle to clamp view to the right. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "left arc",
					"description": "Angle to clamp view to the left. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "top arc",
					"description": "Angle to clamp view to the top. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "bottom arc",
					"description": "Angle to clamp view to the bottom. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "use tag angles",
					"description": "Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.",
					"mandatory": false
				},
				{
					"name": "auto recenter",
					"description": "Players view will auto recenter to the tag he is linked to. use tag angles must be true.",
					"mandatory": false
				}
			],
			"example": "level.player PlayerLinkTo( vehicle, \"tag_player\", 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkToAbsolute",
			"description": "Attaches the player to an entity. No view movement is allowed.  The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lockto entity",
					"description": "The entity to attach the player to",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the player to",
					"mandatory": false
				}
			],
			"example": "player PlayerLinkToAbsolute( vehicle, \"tag_player\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkToBlend",
			"description": "Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "parent",
					"description": "The entity to attach the player to.",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the player to.",
					"mandatory": false
				},
				{
					"name": "pos time",
					"description": "Lerp duration in seconds. Default is 1.",
					"mandatory": false
				},
				{
					"name": "pos accel time",
					"description": "Acceleration time. Default is 0.",
					"mandatory": false
				},
				{
					"name": "pos decel time",
					"description": "Decelaration time. Default is 0.",
					"mandatory": false
				},
				{
					"name": "angle time",
					"description": "angle Lerp duration in seconds. Default is <time>.",
					"mandatory": false
				},
				{
					"name": "angle accel time",
					"description": "angle Acceleration time. Default is 0.",
					"mandatory": false
				},
				{
					"name": "angle decel time",
					"description": "angle Decelaration time. Default is 0.",
					"mandatory": false
				}
			],
			"example": "player PlayerLinkToBlend( ice_pick, \"tag_origin",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkToDelta",
			"description": "Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "linkto entity",
					"description": "The entity to attach the player to.",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the player to.",
					"mandatory": false
				},
				{
					"name": "view fraction",
					"description": "How much the change in the tag's rotation effects the players view. Defaults to 0.",
					"mandatory": false
				},
				{
					"name": "right arc",
					"description": "Angle to clamp view to the right. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "left arc",
					"description": "Angle to clamp view to the left. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "top arc",
					"description": "Angle to clamp view to the top. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "bottom arc",
					"description": "Angle to clamp view to the bottom. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "use tag angles",
					"description": "Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.",
					"mandatory": false
				},
				{
					"name": "auto recenter",
					"description": "Players view will auto recenter to the tag he is linked to. use tag angles must be true.",
					"mandatory": false
				}
			],
			"example": "level.player PlayerLinkToDelta( vehicle, \"tag_player\", 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerLinkWeaponViewToDelta",
			"description": "Similar to PlayerLinkToDelta(), but the player's body stays behind. The player's view attaches to the tag, and any weapon fire will also come from there.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "linkto entity",
					"description": "The entity to attach the player to.",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to attach the player to.",
					"mandatory": false
				},
				{
					"name": "view fraction",
					"description": "How much the change in the tag's rotation effects the players view. Defaults to 0.",
					"mandatory": false
				},
				{
					"name": "right arc",
					"description": "Angle to clamp view to the right. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "left arc",
					"description": "Angle to clamp view to the left. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "top arc",
					"description": "Angle to clamp view to the top. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "bottom arc",
					"description": "Angle to clamp view to the bottom. Defaults to 180.",
					"mandatory": false
				},
				{
					"name": "use tag angles",
					"description": "Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.",
					"mandatory": false
				}
			],
			"example": "level.player PlayerLinkToDelta( vehicle, \"tag_player\", 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerPhysicsTrace",
			"description": "Does a physics trace and returns the hit point.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "starting position",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "ending position",
					"mandatory": true
				}
			],
			"example": "hitp = PlayerPhysicsTrace(player.origin + (0,0,72), player.origin + (0,0,-500))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerPhysicsTraceIgnoreEnt",
			"description": "Does a physics trace and returns the hit point.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "starting position",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "ending position",
					"mandatory": true
				}
			],
			"example": "hitp = PlayerPhysicsTraceIgnoreEnt(player.origin + (0,0,72), player.origin + (0,0,-500))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerPositionValid",
			"description": "Returns true if the passed in origin is valid for a spawn (ie not inside something).",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The position of the potential spawn point",
					"mandatory": true
				}
			],
			"example": "if(playerpositionvalid(spawnpoints[i].origin))...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerPositionValidIgnoreEnt",
			"description": "Returns true if the passed in origin is valid for a spawn (ie not inside something).",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The position of the potential spawn point",
					"mandatory": true
				}
			],
			"example": "if(PlayerPositionValidIgnoreEnt(spawnpoints[i].origin))...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerSetGroundReferenceEnt",
			"description": "The ground entity's rotation will be added onto the player's view.  In particular, this will cause the player's yaw to rotate around the entity's z-axis instead of the world z-axis.  You only need to call this function once.  After that, any rotation that the reference entity undergoes will affect the player.  Call this command again with undefined to turn it off.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "ground reference entity",
					"description": "The entity used to rotate the player's view.",
					"mandatory": true
				}
			],
			"example": "player PlayerSetGroundReferenceEnt( seaEnt )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerSightTrace",
			"description": "Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "place that check if you can see if being performed",
					"mandatory": true
				},
				{
					"name": "maxDistance",
					"description": "if the position is further than this -1 will be returned",
					"mandatory": true
				},
				{
					"name": "hitNum",
					"description": "if you run this more than once make sure to populate this with the return of the last as it will increase efficiency",
					"mandatory": true
				}
			],
			"example": "if (0 == (self Playersighttrace(positionOfFlare, 200, lastHit))",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayFX",
			"description": "Plays the fx at the given location.",
			"calledOn": null,
			"parameters": [
				{
					"name": "fx name",
					"description": "Name of the fx. Fx has to be cached",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "Position to play the fx at",
					"mandatory": true
				},
				{
					"name": "forward",
					"description": "The forward vector of the fx",
					"mandatory": false
				},
				{
					"name": "up",
					"description": "The up vector of the fx",
					"mandatory": false
				},
				{
					"name": "ignore pause",
					"description": "True if the fx should play even when the game is paused.",
					"mandatory": false
				}
			],
			"example": "PlayFX( level._effect[\"nuke_fx\"], nuke_pos.origin, forward, up )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayFXOnCamera",
			"description": "Plays the fx at the given offset from the camera.",
			"calledOn": null,
			"parameters": [
				{
					"name": "fx name",
					"description": "Name of the fx. Fx has to be cached",
					"mandatory": true
				},
				{
					"name": "offset",
					"description": "Offset from camera to play fx",
					"mandatory": false
				},
				{
					"name": "forward",
					"description": "The forward vector of the fx",
					"mandatory": false
				},
				{
					"name": "up",
					"description": "The up vector of the fx",
					"mandatory": false
				},
				{
					"name": "ignore pause",
					"description": "True if the fx should play even when the game is paused.",
					"mandatory": false
				}
			],
			"example": "PlayFX( level._effect[\"bubbles\"], offset, forward, up )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayFXOnTag",
			"description": "Play fx on a particular tag of an entity",
			"calledOn": null,
			"parameters": [
				{
					"name": "fx name",
					"description": "Name of the fx. Fx has to be cached",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "The entity to play the fx on. Should have a model",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "The tag to play the fx on",
					"mandatory": true
				},
				{
					"name": "ignore pause",
					"description": "True if the fx should play even when the game is paused.",
					"mandatory": false
				}
			],
			"example": "PlayFxOnTag( level._effect[\"character_fire_death_torso\"], self, \"J_Spine1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayLoopedFX",
			"description": "Play an fx which is looped",
			"calledOn": null,
			"parameters": [
				{
					"name": "fx name",
					"description": "Name of the fx. Fx has to be cached",
					"mandatory": true
				},
				{
					"name": "repeat",
					"description": "Time to repeat after",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "Position to play the fx at",
					"mandatory": true
				},
				{
					"name": "cull distance",
					"description": "The cull distance for the fx",
					"mandatory": false
				},
				{
					"name": "forward",
					"description": "The forward vector of the fx",
					"mandatory": false
				},
				{
					"name": "up",
					"description": "The up vector of the fx",
					"mandatory": false
				}
			],
			"example": "PlayLoopedFX( level._effect[self.v[\"trailfx\"]], self.v[\"trailfxdelay\"], self.v[\"origin\"], 0, self.v[\"forward\"], self.v[\"up\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayLoopSound",
			"description": "Play a looping sound with an optional fadetime in seconds.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play",
					"mandatory": true
				},
				{
					"name": "fadetime",
					"description": "Time to fade the sound in. Range is between 1 and 31 inclusive.",
					"mandatory": false
				}
			],
			"example": "fire_sound_ent playloopsound (\"mpl_player_burn_loop\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayRumbleLoopOnEntity",
			"description": "Plays a looping rumble on the given entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "rumble name",
					"description": "The name of the rumble to play",
					"mandatory": true
				}
			],
			"example": "self PlayRumbleLoopOnEntity( \"damage_heavy\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayRumbleLoopOnPosition",
			"description": "Play a looping rumble on the given position",
			"calledOn": null,
			"parameters": [
				{
					"name": "rumblename",
					"description": "The rumble name",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "The rumble position",
					"mandatory": true
				}
			],
			"example": "PlayRumbleLoopOnPosition( \"grenade_rumble\", origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayRumbleOnEntity",
			"description": "Plays a rumble on the given entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "rumble name",
					"description": "The name of the rumble to play",
					"mandatory": true
				}
			],
			"example": "self PlayRumbleOnEntity( \"damage_heavy\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayRumbleOnPosition",
			"description": "Play a rumble on the given position",
			"calledOn": null,
			"parameters": [
				{
					"name": "rumblename",
					"description": "The rumble name",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "The rumble position",
					"mandatory": true
				}
			],
			"example": "PlayRumbleOnPosition( \"grenade_rumble\", origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySound",
			"description": "Play the sound at the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play",
					"mandatory": true
				}
			],
			"example": "bomb PlaySound( \"zmb_bomb_explode\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundAtPosition",
			"description": "Play the sound alias from a position",
			"calledOn": null,
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "The point where the sound is played",
					"mandatory": true
				}
			],
			"example": "PlaySoundAtPosition(\"Dirt_skid\", ( 100, 100, 0 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundOnTag",
			"description": "Play the sound alias as if coming from the tag",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play, this can be the string name, or the integer hash",
					"mandatory": true
				},
				{
					"name": "tag",
					"description": "If present, the sound will play at the position of the given tag",
					"mandatory": false
				},
				{
					"name": "team",
					"description": "If present or not undefined the sound will only be heard by the specified team",
					"mandatory": false
				},
				{
					"name": "ent",
					"description": "If present the sound will also be heard on the specified entity",
					"mandatory": false
				}
			],
			"example": "self PlaySoundOnTag( soundAlias, \"J_Head\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundToAllButPlayer",
			"description": "Play the sound alias as if coming from the entity, so that everyone but one player can hear it",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play (string)",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player that will not be able to hear the sound. (entity)",
					"mandatory": true
				}
			],
			"example": "self PlaySoundToAllButPlayer( \"frag_out\", self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundToPlayer",
			"description": "Play the sound alias as if coming from the entity, so that only one player can hear it",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play (string) or the sound alias (int)",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player that will be able to hear the sound. (entity)",
					"mandatory": true
				}
			],
			"example": "self PlaySoundToPlayer( \"frag_out\", self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundToTeam",
			"description": "Play the sound alias as if coming from the entity, so that only one team can hear it",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play",
					"mandatory": true
				},
				{
					"name": "teamname",
					"description": "The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.",
					"mandatory": true
				},
				{
					"name": "ignoreplayer",
					"description": "If present, this player will not hear the sound.",
					"mandatory": false
				}
			],
			"example": "self PlaySoundToTeam( \"frag_out\", \"axis\", self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlaySoundWithNotify",
			"description": "Play the sound alias as if coming from the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play",
					"mandatory": true
				},
				{
					"name": "notification string",
					"description": "If present, the sound will notify this string on this entity when done.stopsounds",
					"mandatory": false
				},
				{
					"name": "tag",
					"description": "If present, the sound will play at the position of the given tag",
					"mandatory": false
				}
			],
			"example": "self PlaySoundWithNotify(\"Dirt_skid\",\"skidsound\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionQuery_Filter_Directness",
			"description": "Directness filter compute the direction information for each of the positions, relative to <origin> and <target>.",
			"calledOn": null,
			"parameters": [
				{
					"name": "queryStruct",
					"description": "result from PositionQuery_Source function. each point contained here will have direction info computed.",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "usually the position of AI before move.",
					"mandatory": true
				},
				{
					"name": "target",
					"description": "the position AI is trying to approach.",
					"mandatory": true
				},
				{
					"name": "resultVarName",
					"description": "by default the result directness value will be stored in pointStruct.directness, but can be override by this string.",
					"mandatory": false
				}
			],
			"example": "PositionQuery_Filter_Directness( queryResult, self.origin, self.enemy.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionQuery_Filter_DistanceToGoal",
			"description": "Calculate the distance to <entity>.goalpos. If the point is in <entity>.goalradius, the distance will be 0. the result is in pointStruct.distToGoal",
			"calledOn": null,
			"parameters": [
				{
					"name": "queryStruct",
					"description": "result from PositionQuery_Source function.\"",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "the entity used to check goal.\"",
					"mandatory": true
				}
			],
			"example": "PositionQuery_Filter_DistanceToGoal( queryResult, self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionQuery_Filter_InClaimedLocation",
			"description": "Check if the locations are inside other sentients claimed locations <entity>.inClaimedLocation.",
			"calledOn": null,
			"parameters": [
				{
					"name": "queryStruct",
					"description": "result from PositionQuery_Source function.\"",
					"mandatory": true
				},
				{
					"name": "entity",
					"description": "the entity used to check goal.\"",
					"mandatory": true
				}
			],
			"example": "PositionQuery_Filter_InClaimedLocation( queryResult, self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionQuery_Filter_Sight",
			"description": "Sight filter do sight check on each of the positions to a target position, and store the result in pointStruct.visibility (boolean).",
			"calledOn": null,
			"parameters": [
				{
					"name": "queryStruct",
					"description": "result from PositionQuery_Source function. each point contained here will be used to check sight against <targetPosition>. \"",
					"mandatory": true
				},
				{
					"name": "targetPosition",
					"description": "the position to check sight.\"",
					"mandatory": true
				},
				{
					"name": "offset",
					"description": "offset to add on each point before sight checking. this is usually something like: offset = ai GetEye() - ai.origin. default to (0,0,0). \"",
					"mandatory": false
				},
				{
					"name": "visibleBy_Ent",
					"description": "if defined, the corresponding sight check function on Actor or Vehicle will be called. Otherwise the checks just do simple bullet tracing.\"",
					"mandatory": false
				},
				{
					"name": "numOfPassedToEarlyOut",
					"description": "if defined and bigger than 0, the filter will early out after found this many passed sight checks. this is useful if the points are pre sorted by score and we don't care about lower scored ones.\"",
					"mandatory": false
				},
				{
					"name": "ignoreEnt",
					"description": "ignore entity during trace. if [visibleBy_Ent] is defined, it is already ignored internally. \"",
					"mandatory": false
				},
				{
					"name": "resultVarName",
					"description": "by default the results will be stored in pointStruct.visibility, but can be override by this string. \"",
					"mandatory": false
				}
			],
			"example": "PositionQuery_Filter_Sight( queryResult, self.enemy.origin, self GetEye() - self.origin, self, 30, self.enemy );",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionQuery_Source_Navigation",
			"description": "Generate points around <origin>, between <minSearchRadius> and <maxSearchRadius> and within <halfHeight> height difference. For ground AI, the points will be on Nav Mesh; for flying AI, the points will be in Nav Volume. Only the points in pathable area will be kept. If the <origin> itself is in pathable area, all the points are guaranteed to be reachable from <origin>. If the <origin> is outside pathable area, all the points will still be in pathable areas surrounding <origin>, but reach-abilities cannot be guaranteed.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Position to start the search around.",
					"mandatory": true
				},
				{
					"name": "minSearchRadius",
					"description": "the minimum radius away from origin.",
					"mandatory": true
				},
				{
					"name": "maxSearchRadius",
					"description": "the maximum radius away from origin. can equal to minSearchRadius.",
					"mandatory": true
				},
				{
					"name": "halfHeight",
					"description": "the max height difference (both positive and negative) away from origin.",
					"mandatory": true
				},
				{
					"name": "innerSpacing",
					"description": "the distance between points in.",
					"mandatory": true
				},
				{
					"name": "reachableBy_Ent",
					"description": "if defined, it will be used to make sure all the points are reachable by this entity from <origin> (not the entity's current position). Can pass in a float number radius to get points on NavMesh. Can also pass in string 'navvolume_small' or 'navvolume_big' to get points on navvolume. Note passing in entity radius only gives rough estimate, not correct result.",
					"mandatory": false
				},
				{
					"name": "outerSpacing",
					"description": "if defined, the distance between points will be Lerped from <innerSpacing> to [outerSpacing], to create a gradual distribution.",
					"mandatory": false
				},
				{
					"name": "distributionBias",
					"description": "(vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.",
					"mandatory": false
				}
			],
			"example": "queryResult = PositionQuery_Source_Navigation( goalpos, self.radius, self.radius * 8, heightRadius, AI_GOAL_POINT_STEP, self, AI_GOAL_POINT_STEP * 0.2 )if ( queryResult.centerOnNav ){foreach( pointStruct in queryResult.data ){position = pointStruct.origindist = pointStruct.distToOrigin2D...}}",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PositionWouldTelefrag",
			"description": "Returns true if the passed in origin would telefrag a player if another player was spawned there.",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The position of the potential spawn point",
					"mandatory": true
				}
			],
			"example": "if ( PositionWouldTelefrag( spawnpoints[i].origin ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PrecacheLeaderboards",
			"description": "Precache a sp/mp leaderboard.",
			"calledOn": null,
			"parameters": [
				{
					"name": "leaderboard names",
					"description": "The name of the leaderboards to precache",
					"mandatory": true
				}
			],
			"example": "PrecacheLeaderboards( \"LB_KILLS LB_WINS LB_TOTALXP LB_ACCURACY\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictGrenade",
			"description": "Predict where the grenade (self) will explode.",
			"calledOn": "grenade",
			"parameters": [],
			"example": "grenade PredictGrenade()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictPosition",
			"description": "Predict position of the entity at the end of the frames",
			"calledOn": null,
			"parameters": [
				{
					"name": "ent",
					"description": "The entity to predict position of",
					"mandatory": true
				},
				{
					"name": "frames",
					"description": "The frame count",
					"mandatory": true
				}
			],
			"example": "prediction = PredictPosition( ent, 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictSpawnPoint",
			"description": "Indicates to the Texture Streamer where we expect to spawn in.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "origin",
					"description": "The origin to spawn at",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The angle.",
					"mandatory": true
				}
			],
			"example": "player predictSpawnPoint( origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Print",
			"description": "Development only - write to the console",
			"calledOn": null,
			"parameters": [
				{
					"name": "text",
					"description": "text to be written",
					"mandatory": true
				}
			],
			"example": "Print( \"Stuff and things!\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PrintLn",
			"description": "Development only - write line to the console",
			"calledOn": null,
			"parameters": [
				{
					"name": "text",
					"description": "text to be written",
					"mandatory": true
				}
			],
			"example": "PrintLn( \"I could be doing better!\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PropagateCurrentEvent",
			"description": "Propagate the current event to other AI.",
			"calledOn": "ai_or_player",
			"parameters": [],
			"example": "point = self PropagateCurrentEvent()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "QSortScoredSpawnPointsAscending",
			"description": "Sort the scored spawn points in an ascending order",
			"calledOn": null,
			"parameters": [
				{
					"name": "input_array",
					"description": "The array of points",
					"mandatory": true
				}
			],
			"example": "sorted_spawn_points = QSortScoredSpawnPointsAscending( scored_spawn_points )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "queuemeleeactionstate",
			"description": "Sets the queued action state to melee for the player's default hand.",
			"calledOn": null,
			"parameters": [],
			"example": "player QueueMeleeActionState()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RadiusDamage",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RecordBreadcrumbDataForPlayer",
			"description": "record a breadcrumb data point for player at time",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RefreshShieldAttachment",
			"description": "Re-attach the shield model to the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "player RefreshShieldAttachment()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RegisterClientField",
			"description": "Register a client field. Client fields are variable bit length fields communicated from server to client.",
			"calledOn": null,
			"parameters": [
				{
					"name": "Client field pool name",
					"description": "Which pool the field is allocated from. Currently supported : \"world\", \"actor\", \"vehicle\", \"scriptmover\"",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "version",
					"description": "Number indicating version this field was added in - see _version.gsh for defines.",
					"mandatory": true
				},
				{
					"name": "num bits",
					"description": "How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.",
					"mandatory": true
				},
				{
					"name": "type",
					"description": "Type of the field. Currently supported types \"int\" or \"float\"",
					"mandatory": true
				}
			],
			"example": "RegisterClientField(\"world\", \"my_field\", 2, \"int\"); // registers a world int field with 2 bits of resolution, that can hold the values 0,1,2,3.",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RegisterSkipto",
			"description": "Register a new skipto name",
			"calledOn": null,
			"parameters": [
				{
					"name": "skipto_name",
					"description": "The skipto name to register",
					"mandatory": true
				}
			],
			"example": "struct.code_index = RegisterSkipto( msg )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReleaseClaimedTrigger",
			"description": "Release a currently claimed trigger",
			"calledOn": "trigger",
			"parameters": [],
			"example": "self.trigger releaseClaimedTrigger()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoveForceNoCull",
			"description": "Removes the force-no-cull flag. Entity will now be culled by portals",
			"calledOn": "entity",
			"parameters": [],
			"example": "helicopter RemoveForceNoCull()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoveInfluencer",
			"description": "Removes the given influencer",
			"calledOn": null,
			"parameters": [
				{
					"name": "influencer id",
					"description": "The influencer to remove",
					"mandatory": true
				}
			],
			"example": "RemoveInfluencer( influencer_id )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoveNoSunShadow",
			"description": "Removes the no-sunshadow flag.",
			"calledOn": "entity",
			"parameters": [],
			"example": "helicopter RemoveNoSunShadow()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReportUser",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetAILimit",
			"description": "Clears any previous restrictions on the max number of AI.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetDestructible",
			"description": "Resets the destructible entity back to its start state",
			"calledOn": "entity",
			"parameters": [],
			"example": "vehicle ResetDestructible()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetDoubleJumpRechargeTime",
			"description": "Resets the double jump recharge timer as if the player had just used it",
			"calledOn": "player",
			"parameters": [],
			"example": "player ResetDoubleJumpRechargeTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetFOV",
			"description": "Replace the current FOV by the default FOV",
			"calledOn": "player",
			"parameters": [],
			"example": "player ResetFOV()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetGlass",
			"description": "Server side glass struct loops through all glass and resets to inital state",
			"calledOn": null,
			"parameters": [],
			"example": "ResetGlass()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetMissileDetonationTime",
			"description": "Resets the timer for a grenade or missile to its max fuse time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "time",
					"description": "Override the reset timer from the weapon and specify the time left.",
					"mandatory": false
				}
			],
			"example": "grenadeEnt ResetMissileDetonationTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReviveObituary",
			"description": "Create an revive obituary for a character",
			"calledOn": null,
			"parameters": [
				{
					"name": "victim",
					"description": "The victim entity",
					"mandatory": true
				}
			],
			"example": "Obituary( self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Rotate",
			"description": "Causes a script entity to rotate, rotating around its origin",
			"calledOn": null,
			"parameters": [
				{
					"name": "rotation vector",
					"description": "The direction of the bobbing",
					"mandatory": true
				}
			],
			"example": "self Rotate( rotationVir )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotatePitch",
			"description": "Rotate this entity to the given pitch",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "pitch angle",
					"description": "The new pitch angle in degrees",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to rotate in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "treeorg RotatePitch( -5, 0.26, 0.15, 0.1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotateRoll",
			"description": "Rotate this entity to the given roll angle",
			"calledOn": "model_origin_brushmodel",
			"parameters": [
				{
					"name": "roll angle",
					"description": "The new roll angle in degrees",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to rotate in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "self RotateRoll( (2 * 1500 + 3 * Randomfloat( 2500 )) * -1, 5, 0, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotateTo",
			"description": "Rotate this entity to the given world rotation value",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "angles",
					"description": "The new world angle to rotate to",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to rotate in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "shutter RotateTo( (shutter.angles[0], newYaw, shutter.angles[2]), newTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotateVelocity",
			"description": "Rotate this entity at a particular velocity for a given time",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "rotate velocity",
					"description": "The rotational velocity to rotate",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to rotate in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"example": "self RotateVelocity( (x,y,z), 12 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotateYaw",
			"description": "Rotate this entity to the given yaw",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "yaw angle",
					"description": "The new yaw angle in degrees",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to rotate in seconds",
					"mandatory": true
				},
				{
					"name": "acceleration time",
					"description": "The time spent accelerating in seconds",
					"mandatory": false
				},
				{
					"name": "deceleration time",
					"description": "The time spent decelerating in seconds",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ScreenShake",
			"description": "Create a screen shake event on the given point.",
			"calledOn": null,
			"parameters": [
				{
					"name": "sourcePoint",
					"description": "The position of the earthquake.",
					"mandatory": true
				},
				{
					"name": "scalepitch",
					"description": "The scale of the shake in player's pitch. Max is 100; Accurate to 2 decimal places.",
					"mandatory": true
				},
				{
					"name": "scaleyaw",
					"description": "The scale of the shake in player's yaw. Max is 100; Accurate to 2 decimal places.",
					"mandatory": true
				},
				{
					"name": "scaleroll",
					"description": "The scale of the shake in player's roll. Max is 100; Accurate to 2 decimal places.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "Duration in seconds.",
					"mandatory": true
				},
				{
					"name": "durationfadeup",
					"description": "Duration in seconds, included in base duration. Default is 0. Value of -1 means duration - durationfadeup.",
					"mandatory": false
				},
				{
					"name": "durationfadedown",
					"description": "Duration in seconds, included in base duration. Default is -1. Value of -1 means duration - durationfadedown.",
					"mandatory": false
				},
				{
					"name": "radius",
					"description": "The radius of shake, dampens as you move away from entity. Default is 0 = shake is global",
					"mandatory": false
				},
				{
					"name": "frequencypitch",
					"description": "The scaled speed of the shake's pitch. Default is 1. Max is 100; Accurate to 2 decimal places.",
					"mandatory": false
				},
				{
					"name": "frequencyyaw",
					"description": "The scaled speed of the shake's yaw. Default is 1. Max is 100; Accurate to 2 decimal places.",
					"mandatory": false
				},
				{
					"name": "frequencyroll",
					"description": "The scaled speed of the shake's roll. Default is 1. Max is 100; Accurate to 2 decimal places.",
					"mandatory": false
				},
				{
					"name": "exponent",
					"description": "The scale is multiplied by itself 'exponent' times to determine how the shake falls off. Default is 1 which is a linear falloff. Max is 100; Accurate to 2 decimal places",
					"mandatory": false
				},
				{
					"name": "target",
					"description": "Target is given if screen shake is to be shown to particular client only",
					"mandatory": false
				}
			],
			"example": "ScreenShake( jolt.origin, 0.3, 0.3, 0.3, 3, 0.2, 3, 850, 0.5, 0.25, 0.25 ); // locationalScreenShake( (0,0,0), 0.3, 0.3, 0.3, 3, 0.2, 3, 0, 0.5, 0.25, 0.25, player ); // non locational for one player only",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SendFaceEvent",
			"description": "Broadcast to the client a face event",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "index",
					"description": "Face event index (string)",
					"mandatory": true
				}
			],
			"example": "self SendFaceEvent( <index> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SendKillstreakDamageEvent",
			"description": "Send a killstreak damage event to the client",
			"calledOn": null,
			"parameters": [
				{
					"name": "damage",
					"description": "How much damage was done",
					"mandatory": false
				}
			],
			"example": "killstreakOwner SendKillstreakDamageEvent( 25 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ServerFieldGetValue",
			"description": "Get the value of a serverfield from a given player",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "player to get value from",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "name of field to retrieve",
					"mandatory": true
				}
			],
			"example": "ServerFieldGetValue(self, \"my_field\"); ",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "serverfieldregister",
			"description": "Register a server field. Server fields are variable bit length fields communicated from client to server",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "Unique name to identify the field.",
					"mandatory": true
				},
				{
					"name": "num bits",
					"description": "How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.",
					"mandatory": true
				},
				{
					"name": "type",
					"description": "Type of the field. Currently supported types \"int\" or \"float\"",
					"mandatory": true
				},
				{
					"name": "callback",
					"description": "Function that gets called when the value changes (each client can toggle this bit independently of the others)",
					"mandatory": true
				}
			],
			"example": "RegisterServerField(\"my_field\", 2, \"int\"); // registers an int field with 2 bits of resolution, that can hold the values 0,1,2,3.",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ServiceEvent",
			"description": "Set the specified event to serviced.",
			"calledOn": "ai",
			"parameters": [
				{
					"name": "eventId",
					"description": "The identifier of the event (integer)",
					"mandatory": true
				}
			],
			"example": "point = self ServiceEvent( 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ServiceEventsInRadius",
			"description": "Set the events within a radius to serviced.",
			"calledOn": "ai",
			"parameters": [
				{
					"name": "origin",
					"description": "Source position",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "Radius of events to service (-1 for all)",
					"mandatory": true
				}
			],
			"example": "self ServiceEventsInRadius( self.origin, 500 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeAbbreviation",
			"description": "Returns abbreviation of the current session mode, or \"default\" if none",
			"calledOn": null,
			"parameters": [],
			"example": "spawnpointname = SessionModeAbbreviation() + \"_frontend_camera",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsCampaignGame",
			"description": "Returns true/false if the current session mode is a campaign game",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsCampaignGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsCampaignZombiesGame",
			"description": "Returns true/false if the current session mode is a campaign game and the campaign mode is set to zombies.",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsCampaignZombiesGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsMultiplayerGame",
			"description": "Returns true/false if the current session mode is a multiplayer game",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsMultiplayerGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsOnlineGame",
			"description": "Returns true/false if the current session mode is onlinegame",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsOnlineGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsPrivate",
			"description": "Returns true/false if the current session mode is a private game",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsPrivate() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsPrivateOnlineGame",
			"description": "Returns true/false if the current session mode is a private onlinegame",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsPrivateOnlineGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsSystemlink",
			"description": "Returns true/false if the current session mode is a systemlink game",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsSystemlink() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SessionModeIsZombiesGame",
			"description": "Returns true/false if the current session mode is a zombies game",
			"calledOn": null,
			"parameters": [],
			"example": "if ( SessionModeIsZombiesGame() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetActorWeapon",
			"description": "Sets the actor weapon.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "weaponname",
					"description": "The weapon name. (string)",
					"mandatory": true
				},
				{
					"name": "weapon options",
					"description": "options value computed using calcweaponoptions",
					"mandatory": false
				}
			],
			"example": "self SetActorWeapon( \"weapon_name\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAILimit",
			"description": "Allows you to specify a max number of active AI - which over-rides the MAX_AI functionality in the engine, when it comes time to spawn in new AI.  Setting the value higher will not give you more AI than the system supports.",
			"calledOn": null,
			"parameters": [],
			"example": "SetAILimit( 10 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAISpread",
			"description": "Sets the spread of this turret when used by an AI",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "spread",
					"description": "The spread of the turret in degrees",
					"mandatory": true
				}
			],
			"example": "roof_turret SetAISpread( 0.2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnim",
			"description": "Restart\": These functions cause the animation to restart. If they had been previously playing, without this they would continue from their current time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnim( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimForceNew",
			"description": "Debug only functionality that adds a new instance of an animation to an animtree setting its time to a specific point.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to set this animation to after adding it. Defaults to 0.",
					"mandatory": false
				},
				{
					"name": "goalTime",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimForceNew( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnob",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnob( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobAll",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "root",
					"description": "An ancestor of the animation.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobAll( %precombatrun1, %body, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobAllLimited",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "root",
					"description": "An ancestor of the animation.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobAllLimited( %precombatrun1, %body, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobAllLimitedRestart",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "root",
					"description": "An ancestor of the animation.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobAllLimitedRestart( %precombatrun1, %body, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobAllRestart",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "root",
					"description": "An ancestor of the animation.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobAllRestart( %precombatrun1, %body, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobLimited",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobLimited( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobLimitedRestart",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobLimitedRestart( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimKnobRestart",
			"description": "See \"SetAnim.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "The animation or animtree node to change.",
					"mandatory": true
				},
				{
					"name": "weight",
					"description": "Goal weight of this animation. Defaults to 1.0.",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "Time to transition to this weight in seconds. Defaults to 0.2.",
					"mandatory": false
				},
				{
					"name": "rate",
					"description": "Playback rate of the animation. Defaults to 1.0.",
					"mandatory": false
				}
			],
			"example": "self SetAnimKnobRestart( %precombatrun1, 1, 0.1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimTime",
			"description": "Get the animation time for the given animation.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "animation to manipulate",
					"mandatory": true
				}
			],
			"example": "if ( (self GetAnimTime( %walk_and_run_loops ) ) < 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAnimTimeByName",
			"description": "Set the animation normalized time for the given animation.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "animation",
					"description": "animation to manipulate",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "0->1",
					"mandatory": true
				}
			],
			"example": "self SetAnimTimeByName( \"ai_anim_walk\",  0.5)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetArchive",
			"description": "deprecated function, does nothing",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAssassinationEnabled",
			"description": "Enable or disable assassinations on the AI.  Also turns on/off the can assassinate indicator.",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag",
					"description": "Whether to use infrared material or not (boolean)",
					"mandatory": true
				}
			],
			"example": "quadtank SetAssassinationEnabled( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAttachmentCosmeticVariantIndex",
			"description": "Set the attachment cosmetic variant index for the weapon",
			"calledOn": "weapon",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon full name",
					"mandatory": true
				},
				{
					"name": "attachment name",
					"description": "The attachment name of the weapon",
					"mandatory": true
				},
				{
					"name": "acvi",
					"description": "The attachment cosmetic variant index",
					"mandatory": true
				}
			],
			"example": "level.weapon_clientscript_cac_model[type] SetAttachmentCosmeticVariantIndex( weaponFullName, level.attachment_names[i], 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAttachmentCosmeticVariantIndexes",
			"description": "Sets the previously calculated SetAttachmentCosmeticVariantIndexes of the entity. The entity should not be a player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "acvi",
					"description": "The AttachmentCosmeticVariantIndexes to set",
					"mandatory": true
				}
			],
			"example": "killcamEnt SetAttachmentCosmeticVariantIndexes( acvi )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAttachmentCosmeticVariants",
			"description": "Set the AttachmentCosmeticVariantIndexes data to be passed in to the weapon",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponname",
					"description": "the name of the base weapon to return",
					"mandatory": true
				},
				{
					"name": "attachmentname_1",
					"description": "the name of the first attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_1",
					"description": "the index of the cosmetic variant to use for the first attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_2",
					"description": "the name of the second attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_2",
					"description": "the index of the cosmetic variant to use for the second attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_3",
					"description": "the name of the third attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_3",
					"description": "the index of the cosmetic variant to use for the third attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_4",
					"description": "the name of the fourth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_4",
					"description": "the index of the cosmetic variant to use for the fourth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_5",
					"description": "the name of the fifth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_5",
					"description": "the index of the cosmetic variant to use for the fifth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_6",
					"description": "the name of the sixth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_6",
					"description": "the index of the cosmetic variant to use for the sixth attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_7",
					"description": "the name of the seventh attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_7",
					"description": "the index of the cosmetic variant to use for the seventh attachment",
					"mandatory": false
				},
				{
					"name": "attachmentname_8",
					"description": "the name of the eighth attachment",
					"mandatory": false
				},
				{
					"name": "variantindex_8",
					"description": "the index of the cosmetic variant to use for the eighth attachment",
					"mandatory": false
				}
			],
			"example": "SetAttachmentCosmeticVariants( \"mp7_mp\", \"acog\", 2, \"grip\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAvoidanceMask",
			"description": "Set the avoidance mask of this Havok character.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "Mask",
					"description": "(const string) Mask must be 'avoid all', 'avoid none', 'avoid actor', 'avoid ai'(actors+vehicles), 'avoid player', or 'avoid vehicle'",
					"mandatory": true
				}
			],
			"example": "randEnemy SetAvoidanceMask(\"avoid none\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAvoidanceProperty",
			"description": "Set the avoidance properties of this Havok character.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "Property",
					"description": "(const string) Property must be 'collision penalty' or 'dodge penalty'",
					"mandatory": true
				},
				{
					"name": "Value",
					"description": "(float) The value to set the property to",
					"mandatory": true
				}
			],
			"example": "randAlly SetAvoidanceProperty(\"collision penalty\", 0.1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBallPassAllowed",
			"description": "Enables or disables ball passing for the given player.",
			"calledOn": null,
			"parameters": [],
			"example": "player SetBallPassAllowed( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBlur",
			"description": "Blur the screen over a period of time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "target_blur",
					"description": "The final blur. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Time in seconds",
					"mandatory": true
				}
			],
			"example": "setblur( 10.3, 3.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBodyRenderOptions",
			"description": "Sets the entity body, helmet and head render options.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "bodyRenderOptions",
					"description": "The packed body render options - calculated with GetHeroBodyRenderOptions",
					"mandatory": true
				},
				{
					"name": "helmetRenderOptions",
					"description": "The packed helmet render options - calculated with GetHeroHelmetRenderOptions",
					"mandatory": true
				},
				{
					"name": "headRenderOptions",
					"description": "The packed head render options - calculated with GetHeroHeadRenderOptions",
					"mandatory": true
				}
			],
			"example": "heroModel SetBodyRenderOptions( bodyRenderOptions, helmetRenderOptions, headRenderOptions )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBombTimer",
			"description": "Bomb timer set in the match state",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag bit",
					"description": "The flag bit to change",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The new value of the bit",
					"mandatory": true
				}
			],
			"example": "SetBombTimer( \"A\", 50000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBurn",
			"description": "Set the entity burning for the given time",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "time",
					"description": "Time to burn for ( greater than 0 )",
					"mandatory": true
				}
			],
			"example": "self SetBurn( 3.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCameraSpikeActive",
			"description": "Sets the state of a player's camera spike.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "toggle",
					"description": "0 for off, 1 for on",
					"mandatory": true
				}
			],
			"example": "player SetCameraSpikeActive( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCanDamage",
			"description": "Set the candamage flag for this entity - this means that it can respond to notifies from bullets and grenade hits",
			"calledOn": "script_model, script_origin or script_brushmodel",
			"parameters": [
				{
					"name": "can damage",
					"description": "The can damage flag",
					"mandatory": true
				}
			],
			"example": "self SetCanDamage( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClearanceCeiling",
			"description": "Sets a new clearance ceiling. If the value is larger than the current ceiling, cut faces will be invalidated.",
			"calledOn": null,
			"parameters": [],
			"example": "SetClearanceCeiling( 15.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientNameMode",
			"description": "alters the way that the player name is updated, to prevent cheating by spectators altering their name to communicate with active players.",
			"calledOn": null,
			"parameters": [
				{
					"name": "name mode",
					"description": "either 'auto_change' or 'manual_change'",
					"mandatory": true
				}
			],
			"example": "SetClientNameMode( \"auto_change\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClone",
			"description": "Sets the contents for the clone.",
			"calledOn": "entity",
			"parameters": [],
			"example": "clone SetClone()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetContents",
			"description": "Sets contents of the entity to the given content",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "content",
					"description": "The content to set for the entity",
					"mandatory": true
				}
			],
			"example": "reconModel SetContents( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCullDist",
			"description": "Set the cull distance for a level",
			"calledOn": null,
			"parameters": [
				{
					"name": "cull distance",
					"description": "The cull distance",
					"mandatory": true
				}
			],
			"example": "SetCullDist( 7200 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCursorHint",
			"description": "Attach a cursor hint to the entity.",
			"calledOn": "entity",
			"parameters": [],
			"example": "self setCursorHint( cursor_hint, cursor_hint_weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDangerous",
			"description": "Set this node to be a dangerous node for a particular team. works only on pathnodes. ",
			"calledOn": "pathnode",
			"parameters": [
				{
					"name": "team",
					"description": "Name of the team.",
					"mandatory": true
				},
				{
					"name": "flag",
					"description": "True if dangerous. False otherwise",
					"mandatory": true
				}
			],
			"example": "self SetDangerous( self.team, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDedicatedShadow",
			"description": "Enabled or Disables dedicated shadow for a model",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "flag",
					"description": "True or False, enabled or disabled",
					"mandatory": false
				}
			],
			"example": "thing SetDedicatedShadow( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDefaultDropPitch",
			"description": "Set the default drop pitch that the turret attempts to return to when it is not in use.",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "pitch",
					"description": "yaw of the turret (side to side) in degrees.",
					"mandatory": true
				}
			],
			"example": "turret SetDefaultDropPitch( -90 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDemoIntermissionPoint",
			"description": "Sets the intermission point for the demos.",
			"calledOn": null,
			"parameters": [
				{},
				{}
			],
			"example": "setDemoIntermissionPoint( spawnpoint.origin, spawnpoint.angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDepthOfField",
			"description": "Set the Depth of Field.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "nearStart",
					"description": "Near start (should be greater than 0)",
					"mandatory": true
				},
				{
					"name": "nearEnd",
					"description": "Near end (should be greater than 0)",
					"mandatory": true
				},
				{
					"name": "farStart",
					"description": "Far start (should be greater than 0)",
					"mandatory": true
				},
				{
					"name": "farEnd",
					"description": "Far end (should be greater than 0)",
					"mandatory": true
				},
				{
					"name": "nearBlur",
					"description": "Near blur",
					"mandatory": true
				},
				{
					"name": "farBlur",
					"description": "Far blur",
					"mandatory": true
				}
			],
			"example": "self SetDepthOfField( 0, 0, 512, 4000, 4, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDoubleJumpEnergy",
			"description": "Sets a double jump energy amount on the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "energy",
					"description": "% energy to set on the player",
					"mandatory": true
				}
			],
			"example": "player SetDoubleJumpEnergy( <energy> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDrawInfrared",
			"description": "Draw this entity using infrared material when using infrared scope.",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag",
					"description": "Whether to use infrared material or not (boolean)",
					"mandatory": true
				}
			],
			"example": "helicopter SetDrawInfrared( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDvar",
			"description": "Sets the value of a dvar.",
			"calledOn": null,
			"parameters": [
				{
					"name": "dvar",
					"description": "The dvar name as a string.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The dvar value.",
					"mandatory": true
				}
			],
			"example": "SetDvar( \"r_eyesAdjust\", \"1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetElectrified",
			"description": "Electrify the entity for the given time",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "time",
					"description": "Time to get electrified for ( greater than 0 )",
					"mandatory": true
				}
			],
			"example": "self SetElectrified( 3.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEMPJammed",
			"description": "Sets whether a player/client is affected by EMP",
			"calledOn": null,
			"parameters": [
				{
					"name": "isJammed",
					"description": "Whether the player should be jammed or not. ( boolean )",
					"mandatory": true
				}
			],
			"example": "player SetEMPJammed( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEnableNode",
			"description": "Disables or enabled this node.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "the node to enable/disable",
					"mandatory": true
				},
				{
					"name": "truefalse",
					"description": "whether it should be enabled",
					"mandatory": false
				}
			],
			"example": "SetEnableNode( node, false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEnemyModel",
			"description": "Sets the model of the actor that actors enemies will see to the given model name",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "model name",
					"description": "The name of the model to set this actor to",
					"mandatory": true
				}
			],
			"example": "dog SetEnemyModel( \"german_shepard_black\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntGravityTrajectory",
			"description": "Sets the gravity trajectory type for the entity.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "trajectory",
					"description": "0 = TR_GRAVITY, 1 = TR_MOON_GRAVITY",
					"mandatory": true
				}
			],
			"example": "player SetEntGravityTrajectory( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntityAnimRate",
			"description": "set the entity animation rate - ZOMBIES ONLY",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "rate",
					"description": "animation rate",
					"mandatory": true
				}
			],
			"example": "self SetEntityAnimRate( 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntityPaused",
			"description": "Sets whether a given entity will advance normally.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "ignore",
					"description": "Whether or not to advance normally.",
					"mandatory": true
				}
			],
			"example": "ent SetEntityPaused( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntityWeapon",
			"description": "Set weapon ent field from script.",
			"calledOn": "entity",
			"parameters": [
				{}
			],
			"example": "ent SetEntityWeapon( \"kniferang_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetExcludeTeamForTrigger",
			"description": "Set the team that this trigger will not react to. Reacts to all other teams.",
			"calledOn": "trigger",
			"parameters": [
				{
					"name": "team name",
					"description": "The name of the team that the trigger will not respond to. Must be either 'axis', 'allies', 'team3', 'team4', 'team5', 'team6' or 'none'",
					"mandatory": true
				}
			],
			"example": "self SetExcludeTeamForTrigger( game[\"attackers\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetExpFog",
			"description": "Creates an exponential fog.",
			"calledOn": null,
			"parameters": [
				{
					"name": "startDist",
					"description": "The distance, in world units, at which the fog begins.",
					"mandatory": true
				},
				{
					"name": "halfwayDist",
					"description": "The distance, beyond the startDist, at which the scene will be 50% fogged.",
					"mandatory": true
				},
				{
					"name": "red",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "green",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "blue",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "transition time",
					"description": "transition time in seconds",
					"mandatory": true
				}
			],
			"example": "SetExpFog(.0001144, 131/255, 116/255, 71/255, 0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFakeFire",
			"description": "Simulates gun fire.  Sound and radar blip.",
			"calledOn": null,
			"parameters": [],
			"example": "entity SetFakeFire( <enabled> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetForceNoCull",
			"description": "Sets the force-no-cull flag. Entity will not be culled by portals",
			"calledOn": "entity",
			"parameters": [],
			"example": "helicopter SetForceNoCull()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFOVForKillcam",
			"description": "Sets the fov for use with this killcam entity.  Setting it to zero makes it use the default fov.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "fov",
					"description": "The fov you want to use for the killcam",
					"mandatory": true
				}
			],
			"example": "killCamEnt SetFOVForKillcam( 25 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGameEndTime",
			"description": "Sets the time the current match will end",
			"calledOn": null,
			"parameters": [
				{
					"name": "time",
					"description": "The time to set",
					"mandatory": true
				}
			],
			"example": "setGameEndTime( getTime() + int(timeLeft) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGametypeSetting",
			"description": "Sets the value of a gametype setting.",
			"calledOn": null,
			"parameters": [
				{
					"name": "setting",
					"description": "The setting name as a string.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The new value for the setting.",
					"mandatory": true
				}
			],
			"example": "SetGametypeSetting( \"timeLimit\", 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGrapplableType",
			"description": "Set how an entity is grappled.",
			"calledOn": null,
			"parameters": [],
			"example": "platform SetGrapplableType( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGravity",
			"description": "sets the gravity in inches per second per second.",
			"calledOn": null,
			"parameters": [
				{
					"name": "gravity",
					"description": "The gravity to set",
					"mandatory": true
				}
			],
			"example": "SetGravity( 800 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHideonClientWhenScriptedAnimCompleted",
			"description": "hides the entity on the client side onces its scripted animation ends",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "An entity",
					"mandatory": true
				}
			],
			"example": "SetHideonClientWhenScriptedAnimCompleted( ent )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHighDetail",
			"description": "Enabled or Disables High Detail rendering for a model",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "flag",
					"description": "True or False, enabled or disabled",
					"mandatory": false
				}
			],
			"example": "thing SetHighDetail( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHintLowPriority",
			"description": "Sets this as a low priority hint which is lower priority then everything other then turrets and dropped weapons",
			"calledOn": null,
			"parameters": [
				{
					"name": "bool",
					"description": "True\\False if its on or off",
					"mandatory": true
				}
			],
			"example": "m_e_hack_trigger SetHintLowPriority( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHintString",
			"description": "Set the hint string for the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "hint string",
					"description": "The hint string that will be displayed to the player",
					"mandatory": true
				},
				{
					"name": "...",
					"description": "Additional arguments may be appended to the hint string",
					"mandatory": false
				}
			],
			"example": "t_door SetHintString( \"Press and Hold ^3[{+activate}]^7 to transmit unlock code\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHintStringForPerk",
			"description": "Shows this hint string to the player if the player has the specified perk",
			"calledOn": null,
			"parameters": [
				{
					"name": "perk",
					"description": "The perk that the player needs to have to see this hint string",
					"mandatory": true
				},
				{
					"name": "hint string",
					"description": "The hint string that will be displayed to the player that has the perk",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHintStringForPlayer",
			"description": "Sets the trigger hint string for one specific player",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player that will see the hint string",
					"mandatory": true
				},
				{
					"name": "hint string",
					"description": "The hint string that will be displayed to the player",
					"mandatory": true
				},
				{
					"name": "...",
					"description": "Additional arguments may be appended to the hint string in the same way as SetHintString.",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetIgnoreEntForTrigger",
			"description": "Ignores this entity when doing trigger sight traces. Currently only works for trigger_radius_use",
			"calledOn": "trigger",
			"parameters": [
				{
					"name": "entity to ignore",
					"description": "The entity that will be ignored during sight trace checks",
					"mandatory": true
				}
			],
			"example": "self SetIgnoreEntForTrigger( camera_spike_ent )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetIgnorePauseWorld",
			"description": "Sets whether a given entity will advance normally when the world is paused.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "ignore",
					"description": "Whether or not to advance normally when the world is paused.",
					"mandatory": true
				}
			],
			"example": "ent SetIgnorePauseWorld( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetIncludeMeshes",
			"description": "Sets a streamer hint entity to include mesh data",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "self setIncludeMeshes( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInfluenceAt",
			"description": "Sets the influence value on the influence map, returns true/false if the value was set.",
			"calledOn": null,
			"parameters": [
				{
					"name": "influenceMapIndex",
					"description": "Index of the influence map",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The location to set the influence value",
					"mandatory": true
				},
				{
					"name": "influence",
					"description": "The influence value to set",
					"mandatory": true
				}
			],
			"example": "SetInfluenceAt(influenceMapIndex, origin, influence)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInfluencerTeamMask",
			"description": "Sets the team mask for the given influencer",
			"calledOn": null,
			"parameters": [
				{
					"name": "influencer id",
					"description": "The influencer id",
					"mandatory": true
				},
				{
					"name": "team mask",
					"description": "The team mask to apply",
					"mandatory": true
				}
			],
			"example": "SetInfluencerTeamMask( influencer_id, team_mask )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInfluencerTimeout",
			"description": "Sets the timeout for the influencer in seconds from current time",
			"calledOn": null,
			"parameters": [
				{
					"name": "influencer id",
					"description": "The influencer id",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The timeout for the influencer",
					"mandatory": true
				}
			],
			"example": "SetInfluencerTimeout( influencer_id, 2.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInfraredVision",
			"description": "Switches using the infrared vision (infrared visionset and thermal characters)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "is infrared vision",
					"description": "Whether using infrared vision",
					"mandatory": true
				}
			],
			"example": "player SetInfraredVision( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInitialPlayersConnected",
			"description": "Set initialPlayersConnected bool in match state to true",
			"calledOn": null,
			"parameters": [],
			"example": "SetInitialPlayersConnected()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInvisibleToAll",
			"description": "Set entity invisible to all players",
			"calledOn": "entity",
			"parameters": [],
			"example": "use_trigger SetInvisibleToAll()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInvisibleToPlayer",
			"description": "Make the entity invisible to the player",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player to set the entity invisible to.",
					"mandatory": true
				},
				{
					"name": "setInvisible",
					"description": "True if entity has to be invisible to player. False otherwise",
					"mandatory": false
				}
			],
			"example": "hackable._trigger SetInvisibleToPlayer( player, false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetJumpHeight",
			"description": "Set the global jump height of all players.  Minimum value of 0, maximum value of 1023.",
			"calledOn": null,
			"parameters": [
				{
					"name": "height_in_inches",
					"description": "The height to jump in inches",
					"mandatory": true
				}
			],
			"example": "SetJumpHeight( 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightColor",
			"description": "Sets the current color of the light, as an RGB vector.",
			"calledOn": "light",
			"parameters": [
				{
					"name": "color",
					"description": "An RGB vector with components in the range 0 to 1. The given values get rounded before they are stored. (vector3)",
					"mandatory": true
				}
			],
			"example": "self SetLightColor( (0.5, 0.75, 1.0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightExponent",
			"description": "Sets the current exponent of the light.",
			"calledOn": "light",
			"parameters": [
				{
					"name": "exponent",
					"description": "A new value for the exponent of the light. This should be an integer in the range of 0 to 100. (integer)",
					"mandatory": true
				}
			],
			"example": "self SetLightExponent( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightFovRange",
			"description": "Sets the current fov range of the light.",
			"calledOn": "light",
			"parameters": [
				{
					"name": "fov_outer",
					"description": "A new value for the outer FOV of the light, in degrees. This cannot be larger than the fov when the map was compiled, or less than 1. (float)",
					"mandatory": true
				},
				{
					"name": "fov_inner",
					"description": "A new value for the inner FOV of the light, in degrees. This cannot be larger than fov_outer, or less than 0. If not specified, the map value is used. (float)",
					"mandatory": false
				}
			],
			"example": "self SetLightFovRange( 200, 50 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightingOnly",
			"description": "Sets a streamer hint entity to only hint lighting data",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "self SetLightingOnly( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightingState",
			"description": "Changes lighting state for the map",
			"calledOn": null,
			"parameters": [
				{
					"name": "new light state",
					"description": "new state to change to. Lighting state defaults to 1 at start of game",
					"mandatory": true
				}
			],
			"example": "SetLightingState( 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightIntensity",
			"description": "Sets the current intensity of the light.",
			"calledOn": "light",
			"parameters": [
				{
					"name": "intensity",
					"description": "A new value for the intensity of the light. 1 is fullbright, but values can be larger than 1. (float)",
					"mandatory": true
				}
			],
			"example": "self SetLightIntensity( 1.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLightRadius",
			"description": "Sets the current radius of the light.",
			"calledOn": "light",
			"parameters": [
				{
					"name": "radius",
					"description": "A new value for the radius of the light. This cannot be larger than the radius when the map was compiled. (float)",
					"mandatory": true
				}
			],
			"example": "self SetLightRadius( 200 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMapCenter",
			"description": "Set the center of the map (used by the network code to optimize position data)",
			"calledOn": null,
			"parameters": [
				{
					"name": "mapCenter",
					"description": "The map center",
					"mandatory": true
				}
			],
			"example": "SetMapCenter( level.mapCenter )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMatchFlag",
			"description": "Flags a bit in the match state",
			"calledOn": "player",
			"parameters": [
				{
					"name": "flag bit",
					"description": "The flag bit to change",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The new value of the bit",
					"mandatory": true
				}
			],
			"example": "SetMatchFlag( \"bomb_timer\", \"1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMatchTalkFlag",
			"description": "Flags a bit in the match talk state",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag bit",
					"description": "The flag bit to change",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The new value of the bit",
					"mandatory": true
				}
			],
			"example": "SetMatchTalkFlag( \"DeadChatWithDead\", \"1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetmaxHealth",
			"description": "Sets the max health of this entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "health",
					"description": "The new max health",
					"mandatory": true
				}
			],
			"example": "self SetMaxHealth( required_amount )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMiniMap",
			"description": "Sets the minimap bounds and material",
			"calledOn": null,
			"parameters": [
				{
					"name": "material",
					"description": "Sets the material",
					"mandatory": true
				},
				{
					"name": "upperLeftX",
					"description": "Upper left X value",
					"mandatory": true
				},
				{
					"name": "upperLeftY",
					"description": "Upper left Y value",
					"mandatory": true
				},
				{
					"name": "lowerRightX",
					"description": "Lower right X value",
					"mandatory": true
				},
				{
					"name": "lowerRightY",
					"description": "Lower right Y value",
					"mandatory": true
				}
			],
			"example": "setMiniMap(material, northwest[0], northwest[1], southeast[0], southeast[1])",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMissileBrake",
			"description": "Tells a remote missile to disable brake",
			"calledOn": "missile",
			"parameters": [
				{
					"name": "flag",
					"description": "True to enable or disable missile brake.",
					"mandatory": true
				}
			],
			"example": "missile DisableMissileBrake( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMissileCoasting",
			"description": "Tells a remote missile to start coasting at a reduced speed.",
			"calledOn": "missile",
			"parameters": [
				{
					"name": "flag",
					"description": "True to start coasting at reduced speed.",
					"mandatory": true
				}
			],
			"example": "missile SetMissileCoasting( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMissileOwner",
			"description": "Sets the missile entity owner.",
			"calledOn": "missile",
			"parameters": [
				{}
			],
			"example": "grenade SetMissileOwner( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMode",
			"description": "Set the mode of a turret.",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "mode",
					"description": "The turret mode. Possible modes are \"auto_ai\", \"manual\", \"manual_ai\" and \"auto_nonai",
					"mandatory": true
				}
			],
			"example": "turret SetMode( \"auto_ai\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetModel",
			"description": "Set the model for the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "model alias",
					"description": "Name of the model",
					"mandatory": true
				}
			],
			"example": "raps_meteor SetModel( \"veh_t7_drone_raps\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMoveSpeedScale",
			"description": "Sets the speed scale multiplier for the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "speed scale multiplier",
					"description": "The speed scale multiplier (float)",
					"mandatory": true
				}
			],
			"example": "self SetMoveSpeedScale( HOLDING_CRATE_MOVEMENT_SPEED )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMovingPlatformEnabled",
			"description": "Enbles the moving platfrom.",
			"calledOn": null,
			"parameters": [],
			"example": "platform SetMovingPlatformEnabled( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNemesisXUID",
			"description": "Sets the Nemesis XUID",
			"calledOn": null,
			"parameters": [
				{
					"name": "nemesisXuidString",
					"description": "The Nemesis XUID string",
					"mandatory": true
				}
			],
			"example": "player setNemesisXuid( player.pers[\"nemesis_xuid\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNodePriority",
			"description": "Enable or disable the priority for this node.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "(node) A priority allowed node.",
					"mandatory": true
				},
				{
					"name": "enable",
					"description": "(boolean) True if this node is enabled.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNormalHealth",
			"description": "Set health of entity. Input health is normalized.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "normal health",
					"description": "Health in normalized form. Range 0 - 1",
					"mandatory": true
				}
			],
			"example": "self SetNormalHealth( 0.8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNoSunShadow",
			"description": "Sets the no-sunshadow flag.",
			"calledOn": "entity",
			"parameters": [],
			"example": "helicopter SetNoSunShadow()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetObjectivePointStatus",
			"description": "Objective status set in the match state",
			"calledOn": null,
			"parameters": [
				{
					"name": "objective_index",
					"description": "The objective index in the matchstate",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team of the objective",
					"mandatory": true
				},
				{
					"name": "percent",
					"description": "Percentage completed",
					"mandatory": true
				}
			],
			"example": "SetObjectivePointStatus( 1, \"allies\", 80 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetOnTargetAngle",
			"description": "Set the angle range at which the turret_on_target notify will occur.",
			"calledOn": "turret_or_vehicle",
			"parameters": [
				{
					"name": "angle",
					"description": "In degrees (float)",
					"mandatory": true
				},
				{
					"name": "gunnerIndex",
					"description": "Which gun, 0-3.",
					"mandatory": false
				}
			],
			"example": "boat SetOnTargetAngle( 0, 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetOwner",
			"description": "Sets the entity owner.",
			"calledOn": "entity",
			"parameters": [
				{}
			],
			"example": "grenade SetOwner( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPauseWorld",
			"description": "pauses playback of animations and effects, but doesn't affect the server tick the way slomo does",
			"calledOn": null,
			"parameters": [
				{
					"name": "pause",
					"description": "Whether or not to pause the world",
					"mandatory": true
				}
			],
			"example": "SetPauseWorld( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPerkForTrigger",
			"description": "Set the perk that the player must have for this trigger will react to",
			"calledOn": "trigger",
			"parameters": [
				{
					"name": "perk name",
					"description": "The name of the perk that the trigger will respond to.",
					"mandatory": true
				}
			],
			"example": "self SetPerkForTrigger( \"specialty_fastinteract\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerCollision",
			"description": "Use to turn on off the collision with the player.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "on_off",
					"description": "True for on and false for off",
					"mandatory": true
				}
			],
			"example": "self SetPlayerCollision( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerCurrentObjective",
			"description": "Sets the current objective information on the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "objective_index",
					"description": "The objective index in the matchstate",
					"mandatory": true
				},
				{
					"name": "objective_type",
					"description": "Type of the objective",
					"mandatory": true
				}
			],
			"example": "SetPlayerCurrentObjective( \"flag_a\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerCurrentStreak",
			"description": "Sets the current kill streak count on the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "current streak",
					"description": "The current kill streak count",
					"mandatory": true
				}
			],
			"example": "SetPlayerCurrentStreak( 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerGravity",
			"description": "Sets the gravity override value for the player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "gravity",
					"description": "The gravity to set",
					"mandatory": true
				}
			],
			"example": "player SetPlayerGravity( 600 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerIgnoreRadiusDamage",
			"description": "Set the player to take or ignore radius damage",
			"calledOn": null,
			"parameters": [
				{
					"name": "flag",
					"description": "true to ignore radius damage, false otherwise",
					"mandatory": true
				}
			],
			"example": "SetPlayerIgnoreRadiusDamage( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerSpread",
			"description": "Sets the spread of this turret when used by the player",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "spread",
					"description": "The spread of the turret in degrees",
					"mandatory": true
				}
			],
			"example": "roof_turret SetPlayerSpread( 0.2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerStateLoadoutBonusCards",
			"description": "Set the player state to have bonus card info, for codcaster to view it",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				}
			],
			"example": "self SetPlayerStateLoadoutBonusCards( class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerStateLoadoutWeapons",
			"description": "Set the player state to have primary and secondary weapon info, for codcaster to view it",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom Class",
					"description": "Class Num",
					"mandatory": true
				}
			],
			"example": "self SetPlayerStateLoadoutWeapons( class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetReviveHintString",
			"description": "Set the revive hint string to show to all or to a team.",
			"calledOn": null,
			"parameters": [
				{
					"name": "hint string",
					"description": "The hint string that will be displayed to the player that has the perk",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team to show the hint to",
					"mandatory": false
				}
			],
			"example": "self.revivetrigger setReviveHintString( &\"GAME_BUTTON_TO_REVIVE_PLAYER\", self.team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRoundsPlayed",
			"description": "Set rounds played in match state",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "The number of rounds played",
					"mandatory": true
				}
			],
			"example": "SetRoundsPlayed( game[\"roundsplayed\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetScale",
			"description": "Set the model scale on a script mover.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "scale",
					"description": "The scale factor. (float)",
					"mandatory": true
				}
			],
			"example": "entity SetScale(2.0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetScanningPitch",
			"description": "Set the pitch that the turret attempts to use while scanning for enemies.",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "pitch",
					"description": "of the turret (up and down) in degrees.",
					"mandatory": true
				}
			],
			"example": "turret SetScanningPitch( -45 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetScoreboardColumns",
			"description": "Set the scoreboard columns.",
			"calledOn": null,
			"parameters": [
				{
					"name": "column1",
					"description": "to <column5>",
					"mandatory": true
				},
				{
					"name": "...",
					"description": "More columns if needed.",
					"mandatory": false
				}
			],
			"example": "SetScoreboardColumns( \"score\", \"kills\", \"deaths\", \"kdratio\", \"assists\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetScriptMoverFlag",
			"description": "Sets flag 0-7 on the script mover ent.",
			"calledOn": "non_player_entity",
			"parameters": [
				{}
			],
			"example": "some_script_model SetScriptMoverFlag( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSessStat",
			"description": "Sets the indicated stat",
			"calledOn": "player",
			"parameters": [
				{
					"name": "stat path",
					"description": "The path to the stat to set the value for.",
					"mandatory": true
				}
			],
			"example": "self SetSessStat( \"byteStat\", 0, 12 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSharedViewPort",
			"description": "Sets the view mode to either shared or independent, shared combines all views into a single shared viewport, modifies the way input is handled, and places the camera into scripted camera mode (i.e. control it with script).",
			"calledOn": null,
			"parameters": [
				{
					"name": "mode",
					"description": "true if shared viewport, false for independent (default splitscreen behavior)",
					"mandatory": true
				}
			],
			"example": "SetSharedViewPort(true)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSkipTos",
			"description": "Set skip tos",
			"calledOn": null,
			"parameters": [
				{
					"name": "skipto",
					"description": "The skipto name",
					"mandatory": true
				}
			],
			"example": "SetSkiptos( ToLower( skipto ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSlowMotion",
			"description": "sets the current slow motion timescale interpolation.",
			"calledOn": null,
			"parameters": [
				{
					"name": "startTimescale",
					"description": "The initial timescale.",
					"mandatory": true
				},
				{
					"name": "endTimescale",
					"description": "The final timescale. Default to 1.",
					"mandatory": false
				},
				{
					"name": "deltaTime",
					"description": "The time to go from start to end timescale. Default to 1. (in seconds)",
					"mandatory": false
				}
			],
			"example": "SetSlowMotion( 1.0, 0.25, 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpawnClientFlag",
			"description": "Set a flag on a client's spawn client data in the spawning system.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "flag",
					"description": "Flag to set",
					"mandatory": true
				}
			],
			"example": "player SetSpawnClientFlag( \"SCDFL_DISABLE_LOGGING\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpawnPointRandomVariation",
			"description": "Random value will be added into the spawn point weighting calculation.",
			"calledOn": null,
			"parameters": [
				{
					"name": "variation",
					"description": "random range will be [0, variation]",
					"mandatory": true
				}
			],
			"example": "SetSpawnPointRandomVariation( 10 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpawnPointsBaseWeight",
			"description": "If the spawn point is facing the objective position then it will have an additional score applied",
			"calledOn": null,
			"parameters": [
				{
					"name": "team mask",
					"description": "teams that this command will affect",
					"mandatory": true
				},
				{
					"name": "objective position",
					"description": "Position of the objective that will be used in the facing calculations",
					"mandatory": true
				},
				{
					"name": "angle",
					"description": "max angle that will be accepted",
					"mandatory": true
				},
				{
					"name": "score",
					"description": "additional score that will be applied",
					"mandatory": true
				}
			],
			"example": "SetSpawnPointsBaseWeight( team_mask, point, 30, 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStableMissile",
			"description": "Set the stable missile flag of the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "flag",
					"description": "Set to true if the stable flag should be set. False otherwise",
					"mandatory": true
				}
			],
			"example": "self SetStableMissile( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStance",
			"description": "Sets the stance of the player. It only works for the player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "stance",
					"description": "The stance.  Possible values are 'crouch', 'prone' and 'stand'",
					"mandatory": true
				}
			],
			"example": "player SetStance( \"stand\" );\\",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStowedWeapon",
			"description": "Sets the stowed weapon for the player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "weaponName",
					"description": "The weapon name to attach (string).",
					"mandatory": true
				}
			],
			"example": "self SetStowedWeapon( \"mp40_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetEntity",
			"description": "Sets the target of this turret",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "target",
					"description": "the turret target",
					"mandatory": true
				}
			],
			"example": "roof_turret SetTargetEntity( target )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetOrigin",
			"description": "Sets the target origin of this turret or vehicle weapon",
			"calledOn": "turret_or_vehicle",
			"parameters": [
				{
					"name": "origin",
					"description": "the turret target origin",
					"mandatory": true
				}
			],
			"example": "roof_turret SetTargetOrigin( origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTeam",
			"description": "Sets the entity team.",
			"calledOn": "entity",
			"parameters": [
				{}
			],
			"example": "panzer SetTeam( team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTeamForTrigger",
			"description": "Set the team that this trigger will react to",
			"calledOn": "trigger",
			"parameters": [
				{
					"name": "team name",
					"description": "The name of the team that the trigger will respond to. Must be either 'axis', 'allies', 'team3' or 'none'",
					"mandatory": true
				}
			],
			"example": "self SetTeamForTrigger( game[\"attackers\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTeamSatellite",
			"description": "Sets whether a team has Spyplane or not",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.",
					"mandatory": true
				},
				{
					"name": "availability",
					"description": "Whether the team has Satellite; defaults to false",
					"mandatory": true
				}
			],
			"example": "SetTeamSatellite( \"allies\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTeamScore",
			"description": "Set a team's score",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either 'axis' or 'allies' or 'team3'.",
					"mandatory": true
				},
				{
					"name": "score",
					"description": "The new team score",
					"mandatory": true
				}
			],
			"example": "SetTeamScore( \"allies\", 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTeamSpyplane",
			"description": "Sets whether a team has Spyplane or not",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.",
					"mandatory": true
				},
				{
					"name": "availability",
					"description": "Whether the team has Spyplane; defaults to false",
					"mandatory": true
				}
			],
			"example": "SetTeamSpyplane( \"allies\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTmodeProvider",
			"description": "Enables (or disables) the actor to provide tmode traces to the player.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "value",
					"description": "(int) 1-enable 0-disable",
					"mandatory": true
				}
			],
			"example": "entity SetTmodeProvider( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTopDownCameraYaw",
			"description": "Set the top down camera yaw that is used in DOA to get the player controls to work correctly in bgpmove.",
			"calledOn": null,
			"parameters": [
				{
					"name": "yaw_angle",
					"description": "The yaw angle to set",
					"mandatory": true
				}
			],
			"example": "SetTopDownCameraYaw( 180 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTopScorer",
			"description": "Sets the top scorer for the end game screen.",
			"calledOn": null,
			"parameters": [
				{
					"name": "index",
					"description": "position [0..2] of the player",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "player who is the top scorer",
					"mandatory": true
				},
				{
					"name": "taunt",
					"description": "players selected taunt index",
					"mandatory": true
				},
				{
					"name": "gesture0",
					"description": "players selected gesture type 0 index",
					"mandatory": true
				},
				{
					"name": "gesture1",
					"description": "players selected gesture type 1 index",
					"mandatory": true
				},
				{
					"name": "gesture2",
					"description": "players selected gesture type 2 index",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "players weapon",
					"mandatory": true
				},
				{
					"name": "weapon render options",
					"description": "players weapon renderoptions",
					"mandatory": false
				},
				{
					"name": "acvi",
					"description": "players attachment cosmetic variant indexes",
					"mandatory": false
				}
			],
			"example": "SetTopScorer( 0, player, weapon, renderoptions, acvi)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretAccuracy",
			"description": "Currently does nothing.",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret SetTargetAccuracy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretCarried",
			"description": "Sets whether a turret is being carried.",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "flag",
					"description": "True if the turret is being carried",
					"mandatory": true
				}
			],
			"example": "turret SetTurretCarried( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretMinimapVisible",
			"description": "Sets whether a turret is visible on the minimap.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "flag",
					"description": "True if the turret is visible on the minimap",
					"mandatory": true
				}
			],
			"example": "sentry SetTurretMinimapVisible( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretNode",
			"description": "Set this turretnode to use this turret.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The turret node to connect to the turret",
					"mandatory": true
				},
				{
					"name": "turret",
					"description": "The turret to connect to the node",
					"mandatory": true
				}
			],
			"example": "SetTurretNode( node, turret )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretOwner",
			"description": "Sets the turret entity owner.",
			"calledOn": "turret",
			"parameters": [
				{}
			],
			"example": "turret SetTurretOwner( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretSpinning",
			"description": "Set the minigun spin for the turret on this entity. Works for vehicles also.",
			"calledOn": "turret",
			"parameters": [
				{
					"name": "onoff",
					"description": "Turn it on or off (boolean)",
					"mandatory": true
				}
			],
			"example": "roof_turret SetTurretSpinning( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretType",
			"description": "Sets the turret Type, Sentry or TOW.",
			"calledOn": "turret",
			"parameters": [
				{}
			],
			"example": "turret SetTurretType( \"sentry\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetupFieldOpsKitLoadouts",
			"description": "Sets up all the field ops custom classes (using slots 6 through 9)",
			"calledOn": null,
			"parameters": [
				{
					"name": "mapname",
					"description": "The map to load the field ops kits for",
					"mandatory": true
				}
			],
			"example": "SetupFieldOpsKitLoadouts( mapname )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetViewAngleResistance",
			"description": "Sets the zones in the player's view cone in which resistance will be applied in the direction of the view limit",
			"calledOn": "player",
			"parameters": [
				{
					"name": "right arc",
					"description": "Angle to resist against the right plane of the view cone.",
					"mandatory": true
				},
				{
					"name": "left arc",
					"description": "Angle to resist against the left plane of the view cone.",
					"mandatory": true
				},
				{
					"name": "top arc",
					"description": "Angle to resist against the top plane of the view cone.",
					"mandatory": true
				},
				{
					"name": "bottom arc",
					"description": "Angle to resist against the bottom plane of the view cone.",
					"mandatory": true
				},
				{
					"name": "snap to",
					"description": "false when the resistance will be blended to over time. True by default.",
					"mandatory": false
				}
			],
			"example": "level.player SetViewAngleResistance( 40, 40, 20, 0, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetViewModelDepthOfField",
			"description": "Set the view model depth of field of the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "start",
					"description": "Start DOF ( >= 0 )",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "End DOF ( >= 0 )",
					"mandatory": true
				}
			],
			"example": "self SetViewModelDepthOfField(0,1000)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVisibleToAll",
			"description": "Make the entity visible to all players",
			"calledOn": "entity",
			"parameters": [],
			"example": "trigger SetVisibleToAll()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVisibleToAllExceptTeam",
			"description": "Set self visible to all teams except the selected teams",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "team",
					"description": "Which to teams not to show this entity too",
					"mandatory": true
				}
			],
			"example": "plane SetVisibleToAllExceptTeam( self.team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVisibleToPlayer",
			"description": "Make the entity visible to the player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "player",
					"description": "The player to set the entity visible to.",
					"mandatory": true
				}
			],
			"example": "trigger SetVisibleToPlayer( self )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVisibleToTeam",
			"description": "Set self visible only to selected team",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "team",
					"description": "Which to show this entity to",
					"mandatory": true
				}
			],
			"example": "plane SetVisibleToSquad( self.team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVisionSetForPlayer",
			"description": "Specify the server override visionset and the transition time into it.",
			"calledOn": null,
			"parameters": [
				{
					"name": "visionset name",
					"description": "Vision set to transition into (string)",
					"mandatory": true
				},
				{
					"name": "transition time",
					"description": "How long, in seconds, to take transitioning to the new vision set if a transition is possible. Default is one second. (float)",
					"mandatory": false
				}
			],
			"example": "player SetVisionSetForPlayer( \"mortar_thermal\", 1.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVolFog",
			"description": "Creates an exponential fog.",
			"calledOn": null,
			"parameters": [
				{
					"name": "startDist",
					"description": "The distance, in world units, at which the fog begins.",
					"mandatory": true
				},
				{
					"name": "halfwayDist",
					"description": "The distance at which the scene will be 50% fogged.",
					"mandatory": true
				},
				{
					"name": "halfwayHeight",
					"description": "The height at which the scene will be 50% fogged.",
					"mandatory": true
				},
				{
					"name": "baseHeight",
					"description": "The ground-level Z position at which the fog will start from.",
					"mandatory": true
				},
				{
					"name": "red",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "green",
					"description": "The green component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "blue",
					"description": "The blue component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "transition time",
					"description": "transition time in seconds",
					"mandatory": true
				},
				{
					"name": "startDist",
					"description": "The distance, in world units, at which the fog begins.",
					"mandatory": true
				},
				{
					"name": "halfwayDist",
					"description": "The distance at which the scene will be 50% fogged.",
					"mandatory": true
				},
				{
					"name": "halfwayHeight",
					"description": "The height at which the scene will be 50% fogged.",
					"mandatory": true
				},
				{
					"name": "baseHeight",
					"description": "The ground-level Z position at which the fog will start from.",
					"mandatory": true
				},
				{
					"name": "red",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "green",
					"description": "The green component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "blue",
					"description": "The blue component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "fogColorScale",
					"description": "The scaler for the colors as a value between 1 and 10000.0",
					"mandatory": true
				},
				{
					"name": "sunFogRed",
					"description": "The red component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogGreen",
					"description": "The green component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogBlue",
					"description": "The blue component of the fog as a value between 0.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogDirX",
					"description": "The X component of the fog direction as a value between -1.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogDirY",
					"description": "The Y component of the fog direction as a value between -1.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogDirZ",
					"description": "The Z component of the fog direction as a value between -1.0 and 1.0",
					"mandatory": true
				},
				{
					"name": "sunFogStartAng",
					"description": "The starting angle of the sun fog as a value between 0 and 180",
					"mandatory": true
				},
				{
					"name": "sunFogEndAng",
					"description": "The ending angle of the sun fog as a value between 0 and 180",
					"mandatory": true
				},
				{
					"name": "fog max opacity",
					"description": "The maximum opacity of the fog as a value between 0 and 1",
					"mandatory": true
				},
				{
					"name": "transition time",
					"description": "transition time in seconds",
					"mandatory": true
				}
			],
			"example": "SetVolFog(0.0001144, 0.01, 131/255, 116/255, 71/255, 0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVoteNoCount",
			"description": "Sets the number of No votes",
			"calledOn": null,
			"parameters": [
				{
					"name": "no count",
					"description": "Number of 'no' votes",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVoteString",
			"description": "Sets the string for a vote",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The vote string",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVoteTime",
			"description": "Sets the start time for a vote",
			"calledOn": null,
			"parameters": [
				{
					"name": "time",
					"description": "The vote time in ms",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVoteYesCount",
			"description": "Sets the number of Yes votes",
			"calledOn": null,
			"parameters": [
				{
					"name": "no count",
					"description": "Number of 'yes' votes",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWaterDrops",
			"description": "Sets water drops equal to the count",
			"calledOn": "player",
			"parameters": [
				{
					"name": "count",
					"description": "Number of water drops (should be >= 0)",
					"mandatory": true
				}
			],
			"example": "self SetWaterDrops( 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWaveWaterGeneratorAmplitude",
			"description": "Sets the wave water amplitude of the generator.",
			"calledOn": null,
			"parameters": [
				{
					"name": "generator name",
					"description": "The generator name",
					"mandatory": true
				},
				{
					"name": "amplitude",
					"description": "The amplitude for the generator",
					"mandatory": true
				}
			],
			"example": "SetWaveWaterGeneratorAmplitude( \"exampleGenerator\", 1.1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeapon",
			"description": "Sets the weapon of the entity. The entity should not be a player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to set",
					"mandatory": true
				}
			],
			"example": "killcamEnt SetWeapon( self.weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponOptions",
			"description": "Sets the previously calculated weapon options of the entity. The entity should not be a player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "weaponOptions",
					"description": "The weapon options to set",
					"mandatory": true
				}
			],
			"example": "killcamEnt SetWeaponOptions( weapon_options )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponRenderOptions",
			"description": "Sets the weapon render options in the entity.",
			"calledOn": "entity",
			"parameters": [
				{},
				{},
				{},
				{},
				{}
			],
			"example": "level.weapon_clientscript_model SetWeaponRenderOptions( level.camo_index, level.reticle_index, level.show_player_tag, level.show_emblem, level.show_paintshop )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWinningPlayer",
			"description": "Sets a player to be the winner",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player to set as the winning player",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWinningTeam",
			"description": "Sets a team to be the winner",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The team name of the winning team. Must be 'axis', 'allies' or 'none'",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWorldFogActiveBank",
			"description": "Sets world fog volumes active bank mask.",
			"calledOn": "client",
			"parameters": [
				{
					"name": "bankMask",
					"description": "Active bank",
					"mandatory": true
				}
			],
			"example": "self setworldfogactivebank(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetZBarrierColModel",
			"description": "Sets the collision model for a zbarrier.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "model",
					"description": "The model.",
					"mandatory": true
				}
			],
			"example": "ent SetZBarrierColModel(\"p6_anim_zm_barricade_board_collision\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetZBarrierPieceState",
			"description": "Set's the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				},
				{
					"name": "state",
					"description": "State to set - valid states are open, opening, closed and closing.",
					"mandatory": true
				},
				{
					"name": "animation scalar",
					"description": "Valid range 0.1 - 2.0, changes the playback speed of the animation in the set state - numbers less than 1.0 are faster.",
					"mandatory": false
				}
			],
			"example": "ent SetZBarrierPieceState(1, \"open\", 0.8)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetZombieName",
			"description": "Set this actors name",
			"calledOn": "actor",
			"parameters": [],
			"example": "guy SetZombieName( \"zombie11\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShellShock",
			"description": "Start a shell shock sequence for the entity for given duration.",
			"calledOn": null,
			"parameters": [
				{},
				{
					"name": "duration",
					"description": "duration in seconds. The duration must be between 0 and 60 seconds.",
					"mandatory": true
				},
				{
					"name": "allowReduceShellShockPerk",
					"description": "true if shell shock perk should be reduced",
					"mandatory": false
				}
			],
			"example": "self shellShock( \"frag_grenade_mp\", 0.2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShootTurret",
			"description": "Shoots a turret",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret ShootTurret()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShootUp",
			"description": "Gives an entity vertical movement",
			"calledOn": null,
			"parameters": [
				{
					"name": "float",
					"description": "upwards velocity",
					"mandatory": true
				}
			],
			"example": "betty ShootUp( 350 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldDoInitialWeaponRaise",
			"description": "Set weaponstate to force or prevent first raise animation the next time the player switches to it. Only works if the player currently has it",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to set the first raise anim state for",
					"mandatory": true
				},
				{
					"name": "bool shouldDoRaise",
					"description": "Whether the weapon should do the initial raise",
					"mandatory": true
				}
			],
			"example": "old_state = self ShouldDoInitialWeaponRaise( \"ak47\", false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Show",
			"description": "Show the entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "self Show()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowAllParts",
			"description": "Show all parts of an entity.",
			"calledOn": "entity",
			"parameters": [],
			"example": "self ShowAllParts()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowInfoVolume",
			"description": "Enables an info volume to be drawn with the specified color",
			"calledOn": null,
			"parameters": [
				{
					"name": "entnum",
					"description": "The entity number of the info volume",
					"mandatory": true
				},
				{
					"name": "rgb color",
					"description": "The rgb color that the info volume will be drawn with",
					"mandatory": false
				},
				{
					"name": "alpha",
					"description": "The alpha that the info volume will be drawn with",
					"mandatory": false
				}
			],
			"example": "InfoVolumeDebug_ShowVolume( info_volume GetEntityNumber(), ( 0.2, 0.2, 0.5 ), 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowMiscModels",
			"description": "Show all misc models with this targetname",
			"calledOn": null,
			"parameters": [
				{
					"name": "targetname",
					"description": "targetname of misc model(s).",
					"mandatory": true
				}
			],
			"example": "ShowMiscModels( \"crash_destruct\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowPart",
			"description": "Show part of an entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "tagname",
					"description": "The tag to show. All surfaces with a vertex weighted to the tag will be shown. (string)",
					"mandatory": true
				},
				{
					"name": "modelname",
					"description": "The optional model name to help specify the part location. (string)",
					"mandatory": false
				},
				{
					"name": "bApplyToChildren",
					"description": "Optional flag to specify if we should apply the operation to children bones as well. (boolean)",
					"mandatory": false
				}
			],
			"example": "self ShowPart( \"tag_weapon\", \"weapon_saw\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowToPlayer",
			"description": "Show the entity to a given client",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "player",
					"description": "The player to show the entity to.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowToTeam",
			"description": "Show the entity to a particular team",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "team",
					"description": "The team to show the entity to.",
					"mandatory": true
				}
			],
			"example": "self ShowToTeam( team )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowZBarrierPiece",
			"description": "Allows the indexed piece to be drawn.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ShowZBarrierPiece(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SightConeTrace",
			"description": "Determines how much the entity can be seen from the given position, using the same check that is used by grenades. Performs multiple sight traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "sight position",
					"description": "The point the sight starts at",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore when doing the traces",
					"mandatory": false
				},
				{
					"name": "cone forward",
					"description": "The forward direction of the cone, whose base is at the <sight position>.  Must be normalized.",
					"mandatory": false
				},
				{
					"name": "cone angle",
					"description": "Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.",
					"mandatory": false
				}
			],
			"example": "tankVisibilityFraction = tank SightConeTrace( player.origin, player, player.angles, 65)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SightTracePassed",
			"description": "Does a sight trace from start to end. Returns true if doesnt hit anything",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The bullet start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The bullet end point",
					"mandatory": true
				},
				{
					"name": "hit characters",
					"description": "An entity to ignore",
					"mandatory": true
				},
				{
					"name": "ignore entity",
					"description": "An entity to ignore",
					"mandatory": true
				}
			],
			"example": "passed = SightTracePassed( player.origin + ( 0, 0, 64 ), self.origin + ( 0, 0, 64 ), false, undefined )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SnapshotAcknowledged",
			"description": "Returns 1 if all clients have acknowledged the snapshot or the timeout has expired. Otherwise returns undefined.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "The array returned by GetSnapshotIndexArray.",
					"mandatory": true
				}
			],
			"example": "acked = SnapshotAcknowledged( snapindices )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Solid",
			"description": "Set the solid flag, so that this object is collidable.",
			"calledOn": "ent",
			"parameters": [],
			"example": "self Solid()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SoundExists",
			"description": "Returns true if the given sound exists",
			"calledOn": null,
			"parameters": [
				{
					"name": "soundName",
					"description": "The sound alias",
					"mandatory": true
				}
			],
			"example": "if( SoundExists( soundAlias )) { //do something }",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SoundGetAlias",
			"description": "The the string alias of a sound from the hashed sound id. Will return undefined if no sound is found",
			"calledOn": null,
			"parameters": [
				{
					"name": "soundId",
					"description": "the hashed sound id of the alias",
					"mandatory": true
				}
			],
			"example": "soundAlias =  SoundGetAlias( soundId )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SoundGetPlaybackTime",
			"description": "Get the playback time for the sound",
			"calledOn": null,
			"parameters": [
				{
					"name": "soundName",
					"description": "The sound alias",
					"mandatory": true
				}
			],
			"example": "playbackTime = SoundGetPlaybackTime( \"evt_infection_record_oneshot\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Spawn",
			"description": "Spawn an entity.",
			"calledOn": null,
			"parameters": [
				{
					"name": "classname",
					"description": "The classname of the entity to spawn",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The position to spawn at",
					"mandatory": true
				},
				{
					"name": "spawnflags",
					"description": "Optional spawn flags (up to 5)",
					"mandatory": false
				}
			],
			"example": "Spawn( \"trigger_radius\", trigger_origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnActor",
			"description": "Spawns an actor from an actor spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag)",
			"calledOn": null,
			"parameters": [
				{
					"name": "AIType",
					"description": "AI type (constant string)",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The position of the vehicle (vector)",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The angle to spawn the vehicle at (vector)",
					"mandatory": true
				},
				{
					"name": "targetname",
					"description": "sets the targetname of the spawned entity",
					"mandatory": false
				},
				{
					"name": "forcespawn",
					"description": "forces a guy to spawn even if the spawn may be visible to the player",
					"mandatory": false
				},
				{
					"name": "fullyaware",
					"description": "gives the AI full awareness of all enemies",
					"mandatory": false
				},
				{
					"name": "spawnerEnt",
					"description": "if passed in, then the fields of the spawnerEnt will be duplicated to the newly spawned actor",
					"mandatory": false
				}
			],
			"example": "spawned = SpawnActor( \"spawner_bo3_soldier_ally_sniper_tool\", origin, angles, \"george\", false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnCollision",
			"description": "Spawns a script mover thats used only for collision",
			"calledOn": null,
			"parameters": [
				{
					"name": "modelname",
					"description": "The name of the model to spawn (constant string)",
					"mandatory": true
				},
				{
					"name": "targetname",
					"description": "target name (constant string)",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The position of the collision (vector)",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The angle to spawn the collision at (vector)",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnFromSpawner",
			"description": "Spawns an actor or vehicle from a spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag) Unsupplied optional fields will use flag values from the entity",
			"calledOn": "actor_or_vehicle_spawner",
			"parameters": [
				{
					"name": "targetname",
					"description": "sets the targetname of the spawned entity",
					"mandatory": false
				},
				{
					"name": "forcespawn",
					"description": "forces a guy to spawn even if the spawn may be visible to the player",
					"mandatory": false
				},
				{
					"name": "makeroom",
					"description": "will remove an undeletable entity if necessary to spawn a new one",
					"mandatory": false
				},
				{
					"name": "infinitespawn",
					"description": "don't increment the spawn count",
					"mandatory": false
				},
				{
					"name": "classnameOverride",
					"description": "override the spawner's classname",
					"mandatory": false
				}
			],
			"example": "spawned = spawnerent SpawnFromSpawner( \"george\", false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnFX",
			"description": "Spawn an FX",
			"calledOn": null,
			"parameters": [
				{
					"name": "fx name",
					"description": "Name of the fx. Fx has to be cached",
					"mandatory": true
				},
				{
					"name": "position",
					"description": "Position to play the fx at",
					"mandatory": true
				},
				{
					"name": "forward",
					"description": "The forward vector of the fx",
					"mandatory": false
				},
				{
					"name": "up",
					"description": "The up vector of the fx",
					"mandatory": false
				}
			],
			"example": "fx = SpawnFx( level._effect[player.light_playFX], monkey.origin + (0,0,-12),(1,0,0),(0,0,1) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnHelicopter",
			"description": "Spawns a helicopter",
			"calledOn": null,
			"parameters": [
				{
					"name": "owner",
					"description": "the owner entity",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "the location",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "the angles",
					"mandatory": true
				},
				{
					"name": "vehicle name",
					"description": "the vehicle name",
					"mandatory": true
				},
				{
					"name": "model name",
					"description": "the model name",
					"mandatory": true
				}
			],
			"example": "heliGuard = spawnHelicopter( self, startPos, startAng, \"heli_guard_mp\" , \"veh_t6_drone_overwatch_light\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnNapalmGroundFlame",
			"description": "Spawn a napalm ground flame at the origin with the direction.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "origin",
					"description": "The origin of the flame",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon",
					"mandatory": true
				},
				{
					"name": "direction",
					"description": "The direction of the flame",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time to live",
					"mandatory": false
				}
			],
			"example": "self SpawnNapalmGroundFlame( bot_pos , weapon, forward)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnPathNode",
			"description": "Spawn a dynamically created path node or cover node",
			"calledOn": null,
			"parameters": [
				{
					"name": "classname",
					"description": "The class name",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The origin",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The view angles",
					"mandatory": true
				},
				{
					"name": "key1",
					"description": "Key 1",
					"mandatory": false
				},
				{
					"name": "value1",
					"description": "Value for key 1",
					"mandatory": false
				},
				{
					"name": "key2",
					"description": "Key 2",
					"mandatory": false
				},
				{
					"name": "value2",
					"description": "Value for key 2",
					"mandatory": false
				}
			],
			"example": "node = SpawnPathNode( cover_left, origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnPlane",
			"description": "Spawns a plane at the origin",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "the owner",
					"mandatory": true
				},
				{
					"name": "classname",
					"description": "class of entity",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "location to spawn at",
					"mandatory": true
				},
				{
					"name": "spawnflags",
					"description": "optional spawn flags",
					"mandatory": false
				}
			],
			"example": "plane = spawnplane( owner, \"script_model\", origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnStruct",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnTimedFX",
			"description": "Spawns a broadcast entity that plays an oriented timed FX using the weapon's property projExplosionEffect",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon to spawn fx on",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "the position to spawn fx at",
					"mandatory": true
				},
				{
					"name": "direction",
					"description": "default (0,0,1)",
					"mandatory": false
				},
				{
					"name": "time",
					"description": "default 10 seconds",
					"mandatory": false
				},
				{
					"name": "team",
					"description": "defaults to TEAM_FREE",
					"mandatory": false
				}
			],
			"example": "ent = SpawnTimedFX( smokeGrenade, position, directionUp, duration )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnTurret",
			"description": "Unsupported function. Do not use.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnVehicle",
			"description": "Spawns a new vehicle and returns a reference to it",
			"calledOn": null,
			"parameters": [
				{
					"name": "vehicletype",
					"description": "vehicle type (constant string)",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The position of the vehicle (vector)",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The angle to spawn the vehicle at (vector)",
					"mandatory": true
				},
				{
					"name": "targetname",
					"description": "vehicle target name (constant string)",
					"mandatory": false
				},
				{
					"name": "destructibledef",
					"description": "The destructibledef to use to make this vehicle a destructible",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartBinocs",
			"description": "Start Binoculars on player",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "player StartBinocs()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartFadingBlur",
			"description": "Blurs the screen, then fades out the blur to 0, over a period of time.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "blur_amount",
					"description": "The initial blur amount. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Time in seconds, how long the fade out will take",
					"mandatory": true
				}
			],
			"example": "player StartFadingBlur( 3, 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartFiring",
			"description": "Starts a turret firing",
			"calledOn": "turret",
			"parameters": [],
			"example": "turret StartFiring()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartMission",
			"description": "Start the (server side) mission script for the specified mission - all loading (on all clients) should be completed before calling - use client side LoadMission to load missions",
			"calledOn": null,
			"parameters": [
				{
					"name": "mission_index",
					"description": "index of the mission name to start - mission names can be retrieved by calling GetMissions to return the available mission array",
					"mandatory": true
				}
			],
			"example": "StartMission()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartPoisoning",
			"description": "Start poisoning player",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "player StartPoisoning()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartRagdoll",
			"description": "Begin ragdoll physics for this entity.  Does nothing if the entity is already a ragdoll.",
			"calledOn": "player_or_playercorpse",
			"parameters": [
				{
					"name": "immediate",
					"description": "Start the ragdoll immediately and don't do the velocity capture on the client.",
					"mandatory": false
				}
			],
			"example": "self StartRagdoll()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartResurrectViewAngleTransition",
			"description": "Finishes the flashback",
			"calledOn": null,
			"parameters": [],
			"example": "self StartResurrectViewAngleTransition()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopAllRumbles",
			"description": "Stop all the rumbles playing right now",
			"calledOn": null,
			"parameters": [],
			"example": "StopAllRumbles()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopAnimScripted",
			"description": "Halts animscript on this entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "blend",
					"description": "The blend out time for the animation",
					"mandatory": false
				},
				{
					"name": "ImmediateStop",
					"description": "Stop the animation immediatly on the client side (no client/server time sync)",
					"mandatory": false
				}
			],
			"example": "self StopAnimScripted()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopBinocs",
			"description": "Stop Binoculars on player",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "player StopBinocs()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopDemoRecording",
			"description": "Stops demo recording",
			"calledOn": null,
			"parameters": [],
			"example": "Demo_End()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopFiring",
			"description": "Stops a turret firing",
			"calledOn": "turret",
			"parameters": [],
			"example": "turret StopFiring()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopJukeMove",
			"description": "Stops the player juke movement in progress",
			"calledOn": "player",
			"parameters": [],
			"example": "player StopJukeMove()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopLoopSound",
			"description": "Stops the looping sound with an optional fadetime.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "fadetime",
					"description": "Time to fade the sound in. Range is between 1 and 31 inclusive.",
					"mandatory": false
				}
			],
			"example": "m_chasm stoploopsound( 5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopMission",
			"description": "fire Mission_Stop event to terminate the current mission",
			"calledOn": null,
			"parameters": [],
			"example": "StopMission()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopMoveSlide",
			"description": "Stops the movement caused by MoveSlide().",
			"calledOn": "model_origin_brushmodel",
			"parameters": [],
			"example": "self StopMoveSlide()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopPoisoning",
			"description": "Stop poisoning player",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "player StopPoisoning()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopRumble",
			"description": "Plays a looping rumble on the given entity.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "rumble name",
					"description": "The name of the rumble to play",
					"mandatory": true
				}
			],
			"example": "self StopRumble( \"damage_heavy\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopShellShock",
			"description": "Stops the shell shock sequence for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "player StopShellShock()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopShootTurret",
			"description": "Stops a turrent from firing.",
			"calledOn": "turret",
			"parameters": [],
			"example": "roof_turret StopShootTurret()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopSound",
			"description": "Stop a particular sound on an entity *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.",
			"calledOn": null,
			"parameters": [],
			"example": "beatBox StopSound(\"alias\");",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopSounds",
			"description": "Stop all sounds on an entity.  *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.",
			"calledOn": "entity",
			"parameters": [],
			"example": "beatBox StopSounds()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StreamerModelHint",
			"description": "Force a model to be loaded for a set period of time.",
			"calledOn": null,
			"parameters": [
				{
					"name": "modelname",
					"description": "The name of the model.",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "Length of time (in seconds) to keep it loaded.",
					"mandatory": true
				}
			],
			"example": "streamerModelHint( \"c_hro_hendricks_base_fb\", 10 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StreamerRequest",
			"description": "Streamer request",
			"calledOn": null,
			"parameters": [
				{
					"name": "command",
					"description": "\"set\", \"clear\" or \"play\"",
					"mandatory": true
				},
				{
					"name": "name",
					"description": "Name of the streamer hint asset",
					"mandatory": true
				}
			],
			"example": "streamerRequest( \"set\", \"ramses_igc1\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StreamerSkiptoDebug",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchMap_Load",
			"description": "Start loading a map/level.",
			"calledOn": null,
			"parameters": [
				{
					"name": "map name",
					"description": "the name of the map to preload",
					"mandatory": true
				}
			],
			"example": "SwitchMap_Load( \"cp_sh_cairo\", \"coop\", 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchMap_Preload",
			"description": "Start preloading a map/level.  A 'switchmap_preload_finished' notify is sent to the level when its finished.",
			"calledOn": null,
			"parameters": [
				{
					"name": "map name",
					"description": "the name of the map to preload",
					"mandatory": true
				}
			],
			"example": "SwitchMap_Preload( \"cp_sh_cairo\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchMap_SetLoadingMovie",
			"description": "Set the loading movie to play",
			"calledOn": null,
			"parameters": [
				{
					"name": "movie_name",
					"description": "The name of the movie",
					"mandatory": true
				}
			],
			"example": "SwitchMap_SetLoadingMovie( str_intro_movie )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchMap_Switch",
			"description": "Switch to the loaded map/level",
			"calledOn": null,
			"parameters": [],
			"example": "SwitchMap_Switch()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_BoundingIsUnderReticle",
			"description": "Returns true if the player's cursor is roughly inside of the target's bounding box.",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player entity",
					"mandatory": true
				},
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "maxDistance",
					"description": "The maximum distance to check for target intersection",
					"mandatory": true
				}
			],
			"example": "player Target_BoundingIsUnderReticle( player, enemy_chopper, 1000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_ClearReticleLockOn",
			"description": "Cancels any lock-on sequence on the hud.",
			"calledOn": null,
			"parameters": [],
			"example": "Target_ClearReticleLockOn()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_GetArray",
			"description": "Gets an array of entities that are set as targets",
			"calledOn": null,
			"parameters": [],
			"example": "mytargets = Target_GetArray()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_GetOffset",
			"description": "Gets the target offset",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity that is the target",
					"mandatory": true
				}
			],
			"example": "offset = Target_GetOffset( entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_IsInCircle",
			"description": "Returns whether a target is within a given radius from the center of the player's screen",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player entity",
					"mandatory": true
				},
				{
					"name": "fov",
					"description": "The player's field of view",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "radius of the circle, centered at the center of the screen",
					"mandatory": true
				},
				{
					"name": "zoffset",
					"description": "if entity is not in target array, use optional zoffset for target pos",
					"mandatory": false
				}
			],
			"example": "player Target_IsInCircle( enemy_chopper, player, 65, 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_IsInRect",
			"description": "Returns whether a target is within a given rectangle, centered in the center of the player's screen",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player entity",
					"mandatory": true
				},
				{
					"name": "fov",
					"description": "The player's field of view",
					"mandatory": true
				},
				{
					"name": "halfwidth",
					"description": "half the width of the rectangle",
					"mandatory": true
				},
				{
					"name": "halfheight",
					"description": "half the height of the rectangle",
					"mandatory": true
				}
			],
			"example": "player Target_IsInRect( enemy_chopper, player, 65, 100, 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_IsTarget",
			"description": "Returns whether an entity has been marked as a target",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity to check",
					"mandatory": true
				}
			],
			"example": "if ( Target_IsTarget( foundEnt ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_OriginIsInCircle",
			"description": "Returns whether a target is within a given radius from the center of the player's screen",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The origin to test",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player entity",
					"mandatory": true
				},
				{
					"name": "fov",
					"description": "The player's field of view",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "radius of the circle, centered at the center of the screen",
					"mandatory": true
				}
			],
			"example": "player Target_IsInCircle( enemy_chopper, player, 65, 100 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_Remove",
			"description": "Removes a target",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				}
			],
			"example": "Target_Remove( enemy_chopper )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_ScaleMinMaxRadius",
			"description": "Returns the ratio from 0-1 of where the target is in relation to the radius min and radius max",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "The player entity",
					"mandatory": true
				},
				{
					"name": "fov",
					"description": "The player's field of view",
					"mandatory": true
				},
				{
					"name": "radius_min",
					"description": "radius of the circle, centered at the center of the screen",
					"mandatory": true
				},
				{
					"name": "radius_max",
					"description": "radius of the circle, centered at the center of the screen",
					"mandatory": true
				}
			],
			"example": "scale = Target_ScaleMinMaxRadius( target, self, level.hackerToolLockOnFOV, radiusInner, radiusOuter )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_Set",
			"description": "Adds a new target to draw on the hud",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "target offset",
					"description": "The offset of the target position from the entity's origin",
					"mandatory": false
				}
			],
			"example": "Target_Set( enemy_chopper )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetAllowHighSteering",
			"description": "Target will allow incoming missiles to steer more making the target easier to hit",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "bool",
					"description": "true/false\"",
					"mandatory": true
				}
			],
			"example": "Target_SetAllowHighSteering( enemy_tank, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetAttackMode",
			"description": "Sets how missiles and rockets should approach the target.",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "mode name",
					"description": "\"top\" or \"direct\"",
					"mandatory": true
				}
			],
			"example": "Target_SetAttackMode( enemy_tank, \"top\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetJavelinOnly",
			"description": "Target will only draw on player's hud when they are looking through the Javelin-weapon's site.",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "mode name",
					"description": "\"top\" or \"direct\"",
					"mandatory": true
				}
			],
			"example": "Target_SetJavelinOnly( enemy_tank, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetOffscreenShader",
			"description": "Sets the material that is used when a target clamps to the edge of the screen.  The target must have already been created with target_set()",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "materialname",
					"description": "The shader for the quad drawn over the target",
					"mandatory": true
				}
			],
			"example": "Target_SetOffscreenShader( enemy_chopper, \"arrow\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetOffset",
			"description": "Sets the offset for a particular target",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "target offset",
					"description": "The offset of the target position from the entity's origin",
					"mandatory": false
				}
			],
			"example": "Target_SetOffset( enemy_chopper, ( 0, 0, -100 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetShader",
			"description": "Changes the material of a target.  The target must have already been created with target_set()",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "materialname",
					"description": "The shader for the quad drawn over the target",
					"mandatory": true
				}
			],
			"example": "Target_SetShader( enemy_chopper, \"locked_on_shader\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_SetTurretAquire",
			"description": "Sets if the target can be attacked by SAM turrets",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity to set the flag",
					"mandatory": true
				},
				{
					"name": "bool",
					"description": "false if you want the SAM turret to ignore the targe. default is true.",
					"mandatory": false
				}
			],
			"example": "Target_SetTurretAquire( chopper, false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Target_StartReticleLockOn",
			"description": "Begins the lock-on sequence for the target on the hud.  This affects the animation of the vehicle reticle.",
			"calledOn": null,
			"parameters": [
				{
					"name": "target entity",
					"description": "The entity that is the target",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "The amount of time between now and fully locked-on, in seconds.",
					"mandatory": true
				}
			],
			"example": "Target_StartReticleLockOn( enemy_chopper, 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TestSpawnPoint",
			"description": "Returns true if the player would not be in a solid when spawned at the given point.",
			"calledOn": null,
			"parameters": [
				{
					"name": "point",
					"description": "the point to test",
					"mandatory": true
				}
			],
			"example": "TestSpawnPoint( self.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TmodeSetServerUser",
			"description": "informs the server if the entity is using tmode",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "value",
					"description": "(int) 1-using 0-not usuing",
					"mandatory": true
				}
			],
			"example": "entity TmodeSetServerUser( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ToggleNoVehicleFaceTraversability",
			"description": "Set whether the entity can use NoVehicleFaces. This should only be used in MP map for now.",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TracePassedOnNavMesh",
			"description": "Run a trace on NavMesh to see if a character can go straight from start to end.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "start of the trace",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "end of the trace",
					"mandatory": true
				},
				{
					"name": "characterRadius",
					"description": "the radius of the capsule used in trace. default to 0.",
					"mandatory": false
				},
				{
					"name": "materialFlags",
					"description": "the flags marking whether a face type can be used",
					"mandatory": false
				}
			],
			"example": "posOnNavMesh = TracePassedOnNavMesh( (10,20,30), 25, 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TriggerEnable",
			"description": "Enables or disables the trigger",
			"calledOn": "trigger",
			"parameters": [
				{
					"name": "flag",
					"description": "True if trigger should be enabled, false otherwise",
					"mandatory": true
				}
			],
			"example": "trig TriggerEnable( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TriggerFX",
			"description": "Trigger the fx after some time delay",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The fx entity",
					"mandatory": true
				},
				{
					"name": "time delay",
					"description": "The time delay for the fx to play",
					"mandatory": false
				}
			],
			"example": "triggerFx( domFlag.enemyBaseEffect, 0.001 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TriggerIgnoreTeam",
			"description": "Trigger ignores team",
			"calledOn": "trigger",
			"parameters": [],
			"example": "trig TriggerIgnoreTeam()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Unlink",
			"description": "Unlinks a linked entity from another entity",
			"calledOn": "entity",
			"parameters": [],
			"example": "guy Unlink()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnlinkNodes",
			"description": "Disconnects node1 from node2. Call it again with arguments flipped if you want to completely disconnect the two nodes.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node1",
					"description": "first node to unlink",
					"mandatory": true
				},
				{
					"name": "node2",
					"description": "second node to unlink",
					"mandatory": true
				}
			],
			"example": "UnlinkNodes( node_moving_elev_left, node_moving_elev_right )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnlinkTraversal",
			"description": "Destroys a user edge connecting two path nodes",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "Negotiation begin node",
					"mandatory": true
				}
			],
			"example": "UnlinkTraversal( beginNode )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnlockSongByAlias",
			"description": "Unlock the the sound alias",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "aliasname",
					"description": "The sound alias to play (string)",
					"mandatory": true
				}
			],
			"example": "self UnlockSongByAlias( \"frag_out\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnSetTurretNode",
			"description": "Unset the turret from this node.",
			"calledOn": null,
			"parameters": [
				{
					"name": "node",
					"description": "The turret node to disconnect",
					"mandatory": true
				}
			],
			"example": "UnSetTurretNode( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UpdateClientNames",
			"description": "Update all of the client names: only works in 'manual_change' mode",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UpdateNavTriggers",
			"description": "Optimized code that performs the update_nav_triggers() script functionality",
			"calledOn": null,
			"parameters": [],
			"example": "UpateNavTriggers()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UpdateUnlockedAttachmentBits",
			"description": "Updates client->unlockedAttachments",
			"calledOn": "entity",
			"parameters": [],
			"example": "self UpdateUnlockedAttachmentBits()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseAnimTree",
			"description": "Sets the anim tree for the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "anim tree",
					"description": "The anim tree to set",
					"mandatory": true
				}
			],
			"example": "self UseAnimTree( #animtree )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseBuildKitWeaponModel",
			"description": "Use a build kit weapon model",
			"calledOn": null,
			"parameters": [
				{
					"name": "player",
					"description": "The player whose build kit data will be used",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon to base the build kit on",
					"mandatory": true
				},
				{
					"name": "camoIndex",
					"description": "The index of the camo to override the build kit's camo with",
					"mandatory": false
				},
				{
					"name": "upgraded",
					"description": "bool whether this should be the upgraded version. If so extclip and fmj will be added",
					"mandatory": false
				}
			],
			"example": "wall_weapon_model UseBuildKitWeaponModel( player, magicbox.weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseBy",
			"description": "Uses the entity with the passed in entity as the activator",
			"calledOn": "entity",
			"parameters": [
				{}
			],
			"example": "self UseBy( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseServerVisionset",
			"description": "Switches using the server supplied (via SetVisionSetForPlayer()) visionset.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "use it",
					"description": "Whether using the server override visionset",
					"mandatory": true
				}
			],
			"example": "player UseServerVisionset( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseTriggerIgnoreUseHoldTime",
			"description": "Set the require look at flag for the trigger",
			"calledOn": "trigger",
			"parameters": [],
			"example": "e_trig_mobile_armory UseTriggerIgnoreUseHoldTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseTriggerRequireLookAt",
			"description": "Set the require look at flag for the trigger",
			"calledOn": "trigger",
			"parameters": [],
			"example": "e_trig_plaza_igc UseTriggerRequireLookAt()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseTriggerRequireLookToward",
			"description": "Set the require look along flag for the trigger",
			"calledOn": "trigger",
			"parameters": [],
			"example": "e_trig_plaza_igc UseTriggerRequireLookToward()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseWeaponHideTags",
			"description": "Hides tags on this entity based on the hidetags value of the provided weaponname",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponName",
					"description": "The name of the weapon to base the tags to hide on",
					"mandatory": true
				}
			],
			"example": "wall_weapon_model UseWeaponHideTags()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseWeaponModel",
			"description": "Use a weapon model",
			"calledOn": null,
			"parameters": [
				{
					"name": "weaponName",
					"description": "The name of the weapon to base the tags to hide on",
					"mandatory": true
				},
				{
					"name": "model",
					"description": "The name of a model to use. If none is specified the world model for the weapon will be used",
					"mandatory": false
				},
				{
					"name": "weapon options",
					"description": "The weapon options",
					"mandatory": false
				}
			],
			"example": "wall_weapon_model UseWeaponModel(\"m16_zm\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Vibrate",
			"description": "Causes a script entity to vibrate, rotating around its origin, along a given vector dir",
			"calledOn": null,
			"parameters": [
				{
					"name": "direction vector",
					"description": "The direction of the vibration",
					"mandatory": true
				},
				{
					"name": "amplitude",
					"description": "The amount of the vibration in degrees",
					"mandatory": true
				},
				{
					"name": "period",
					"description": "The period of the vibration in seconds",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The length of time of the vibration in seconds",
					"mandatory": true
				}
			],
			"example": "self Vibrate( directionVir, 0.3, 0.4, 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VideoPause",
			"description": "Pause video playback",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name of movie to pause.  do not add a file suffix (like .mp4)",
					"mandatory": true
				}
			],
			"example": "VideoPause( \"MyAwesomeMovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VideoPrime",
			"description": "Preload the first second of a movie.  Call this several seconds before the movie needs to play to prevent any delay",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name of movie to play.  do not add a file suffix (like .mp4)",
					"mandatory": true
				},
				{
					"name": "loop",
					"description": "Set this to true if the movie should automatically restart when it reaches the end.",
					"mandatory": false
				}
			],
			"example": "VideoPrime( \"MyAwesomeMovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VideoStart",
			"description": "Start a video for playback on an in-game surface",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name of movie to play.  do not add a file suffix (like .mp4)",
					"mandatory": true
				},
				{
					"name": "loop",
					"description": "Set this to true if the movie should automatically restart when it reaches the end.",
					"mandatory": false
				}
			],
			"example": "VideoStart( \"MyAwesomeMovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VideoStop",
			"description": "Stop a video being played on an in-game surface",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name of movie to stop.  do not add a file suffix (like .mp4)",
					"mandatory": true
				}
			],
			"example": "VideoStop( \"MyAwesomeMovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VideoUnpause",
			"description": "Unpause video playback",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "name of movie to pause.  do not add a file suffix (like .mp4)",
					"mandatory": true
				}
			],
			"example": "VideoUnpause( \"MyAwesomeMovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ViewKick",
			"description": "Give the player a view kick",
			"calledOn": "player",
			"parameters": [
				{
					"name": "damage",
					"description": "The damage to inflict",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The origin of the kick",
					"mandatory": true
				}
			],
			"example": "entity ViewKick( 25, self.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VisionSetLastStand",
			"description": "Sets players' laststand vision.  Optionally give a transition time from the current vision.",
			"calledOn": null,
			"parameters": [
				{
					"name": "vision name",
					"description": "Vision to transition to.",
					"mandatory": true
				},
				{
					"name": "transition time",
					"description": "How long, in seconds, to take transitioning to the new vision set if a transition is possible.  Default is one second.",
					"mandatory": false
				}
			],
			"example": "VisionSetLastStand( \"armada\", 1.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VisionSetLerpRatio",
			"description": "Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.",
			"calledOn": null,
			"parameters": [
				{
					"name": "float",
					"description": "ratio between 0 and 1",
					"mandatory": true
				}
			],
			"example": "self VisionSetLerpRatio ( currentDistance / maxDistance )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VisionSetNaked",
			"description": "Set the vision and its duration",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "The vision set name",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "The duration of the vision",
					"mandatory": false
				}
			],
			"example": "VisionSetNaked( \"cp_igc_chinatown_intro\", 0.05 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WalkUnderwater",
			"description": "Sets if a player should walk while underwater",
			"calledOn": "player",
			"parameters": [
				{
					"name": "boolean",
					"description": "true if player should walk underwater.  False if player should swim",
					"mandatory": true
				}
			],
			"example": "depth = get_players()[0] WalkUnderwater( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponCyclingEnabled",
			"description": "Determine if weapon cycling is enabled for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "enabled = player WeaponCyclingEnabled()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponHasAttachment",
			"description": "Does the weapon have all the attachments specified?",
			"calledOn": null,
			"parameters": [],
			"example": "WeaponHasAttachment( weapon, \"extbarrel\", \"damage, \"fmj\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponHasAttachmentAndUnlocked",
			"description": "Does the weapon have all the attachments specified? And are they all unlocked for challenge stat purposes?",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon",
					"description": "weapon",
					"mandatory": true
				},
				{
					"name": "string",
					"description": "string id for attachment",
					"mandatory": true
				}
			],
			"example": "player WeaponHasAttachmentAndUnlocked( weapon, \"extbarrel\", \"damage, \"fmj\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WorldEntNumber",
			"description": "Returns the entity number for the world",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WorldToLocalCoords",
			"description": "Transform the given world point into the local space of the entity",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "world coords",
					"description": "The point in world coordinates (vector3)",
					"mandatory": true
				}
			],
			"example": "local_point = self WorldToLocalCoords( world_point )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WorldTrace",
			"description": "Trace from start to end",
			"calledOn": null,
			"parameters": [
				{
					"name": "start",
					"description": "The trace start point",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "The trace end point",
					"mandatory": true
				}
			],
			"example": "trace = WorldTrace( start_pos, end_pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierPieceUseAlternateModel",
			"description": "Sets the indexed piece to use the alternate model.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ZBarrierPieceUseAlternateModel(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierPieceUseAttachWeapon",
			"description": "Sets the indexed piece to attach the zbarrier's weapon to tag_weapon (and tag_weapon_left if it's dual wield).",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ZBarrierPieceUseAttachWeapon( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierPieceUseBoxRiseLogic",
			"description": "Sets the indexed piece to use the box rise logic.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ZBarrierPieceUseBoxRiseLogic(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierPieceUseDefaultModel",
			"description": "Sets the indexed piece to use the default model.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ZBarrierPieceUseDefaultModel(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierPieceUseUpgradedModel",
			"description": "Sets the indexed piece to use the upgraded model.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "piece number",
					"description": "The piece index.",
					"mandatory": true
				}
			],
			"example": "ent ZBarrierPieceUseUpgradedModel(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierSupportsZombieReachThroughAttacks",
			"description": "Returns true if this zbarrier supports zombie reach through attacks.",
			"calledOn": "entity",
			"parameters": [],
			"example": "useAttack = ent ZBarrierSupportsZombieReachThroughAttacks()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZBarrierSupportsZombieTaunts",
			"description": "Returns true if this zbarrier supports zombie taunt anims.",
			"calledOn": "entity",
			"parameters": [],
			"example": "useTaunt = ent ZBarrierSupportsZombieTaunts()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZeroGravityVolumeOff",
			"description": "Disables Zero Gravity Volume.",
			"calledOn": null,
			"parameters": [
				{
					"name": "volume name",
					"description": "The volume name.",
					"mandatory": true
				}
			],
			"example": "ZeroGravityVolumeOff( \"area_four\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ZeroGravityVolumeOn",
			"description": "Enables Zero Gravity Volume.",
			"calledOn": null,
			"parameters": [
				{
					"name": "volume name",
					"description": "The volume name.",
					"mandatory": true
				}
			],
			"example": "ZeroGravityVolumeOn( \"area_four\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddSentientEventListener",
			"description": "Registers entity to listen to a specific event. Call waittill(<event>) to get the notification in script.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "event",
					"description": "The event name",
					"mandatory": true
				}
			],
			"example": "self AddSentientEventListener(\"bulletwhizby\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "aithrowgrenade",
			"description": "Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GrenadeThrow()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowPitchAngle",
			"description": "Allows AI to pitch on stairs",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "on_off",
					"description": "1 to allow and 0 to disallow",
					"mandatory": true
				}
			],
			"example": "guy AllowPitchAngle ( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnimMode",
			"description": "Set the way that animation deltas are interpreted by the game engine",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "mode",
					"description": "which animmode to use. Must be 'gravity', 'nogravity', 'angle deltas', 'pos deltas', 'normal', 'normal_nogravity', 'zonly_physics', 'nophysics', 'none'",
					"mandatory": true
				},
				{
					"name": "clear path",
					"description": "The clear path flag",
					"mandatory": false
				}
			],
			"example": "self AnimMode( \"gravity\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AtDangerousNode",
			"description": "Determine whether this actor is near a dangerous node.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if ( ai atDangerousNode() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AttackedRecently",
			"description": "Returns true if given sentient has attacked the entity within last \"time\" sec.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "entity",
					"description": "The enemy entity",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Time interval in seconds.",
					"mandatory": true
				}
			],
			"example": "self AttackedRecently(self.enemy)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CalcApproximatePathToPosition",
			"description": "Returns an array of world positions representing the approximate path an actor will take.  Calculating an approximate path will cause the AI to clear their current path.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "The goal position for the path",
					"mandatory": true
				},
				{
					"name": "clear path",
					"description": "True to clear path, false otherwise. Defaults to True",
					"mandatory": false
				}
			],
			"example": "self CalcApproximatePathToPosition( position )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CalcLookaheadPos",
			"description": "Calculate a lookahead point based on a given starting location and number of iterations. Returns an array with these keys: \"position\", \"node\" and \"next_node\", which contain vectors for the actual lookahead position and the next two nodes on the path, respectively.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "startPos",
					"description": "Starting position of the lookahead traces",
					"mandatory": true
				},
				{
					"name": "numIter",
					"description": "Number of times to iterate (more gives better results, but is more expensive). Set to 0 to get current lookahead.",
					"mandatory": true
				}
			],
			"example": "self CalcLookaheadPos( self.origin, 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanAttackEnemyNode",
			"description": "Checks if this actor can attack its enemies node.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self CanAttackEnemyNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanSee",
			"description": "Check to see if the AI can see the given entity.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "target",
					"description": "(entity) The entity to check.",
					"mandatory": true
				},
				{
					"name": "cacheLength",
					"description": "(integer) The cache length",
					"mandatory": false
				}
			],
			"example": "if( self CanSee( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanShoot",
			"description": "Check to see if the actor can shoot the given position.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "shoot at position",
					"description": "(vector) The position to shoot at.",
					"mandatory": true
				},
				{
					"name": "offset from gun",
					"description": "(vector) The offset from the gun muzzle from which to calculate collision.",
					"mandatory": false
				}
			],
			"example": "canShoot = self CanShoot( eye, offset )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanShootEnemy",
			"description": "Check to see if the actor can shoot his current enemy.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "cache duration",
					"description": "(int) When set, uses a custom time value for the cache.",
					"mandatory": false
				}
			],
			"example": "canShootEnemy = self CanShootEnemy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanThrowGrenade",
			"description": "Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "hand offset",
					"description": "(vector) the estimated offset of the hand for the throw",
					"mandatory": true
				},
				{
					"name": "random range",
					"description": "(float) random range from target position to throw at",
					"mandatory": true
				}
			],
			"example": "throwvel = self CanThrowGrenade( armOffset, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanThrowGrenadePos",
			"description": "Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "hand offset",
					"description": "(vector) the estimated offset of the hand for the throw",
					"mandatory": true
				},
				{
					"name": "targetpos",
					"description": "(vector) The target position, should be at ground level of potential target",
					"mandatory": true
				}
			],
			"example": "throwvel = self CanThrowGrenadePos( armOffset, targetPos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CheckGrenadeThrow",
			"description": "Checks whether the actor can throw a grenade at his target. If he can't then result will be undefined, otherwise the result is the resultant velocity vector",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "hand offset",
					"description": "(vector) the estimated offset of the hand for the throw",
					"mandatory": true
				},
				{
					"name": "method",
					"description": "(string) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'",
					"mandatory": true
				},
				{
					"name": "random range",
					"description": "(float) random range from target position to throw at",
					"mandatory": true
				}
			],
			"example": "throwvel = self CheckGrenadeThrow( armOffset, \"min energy\", 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CheckGrenadeThrowPos",
			"description": "Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "hand offset",
					"description": "(vector) the estimated offset of the hand for the throw",
					"mandatory": true
				},
				{
					"name": "method",
					"description": "(vector) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'",
					"mandatory": true
				},
				{
					"name": "targetpos",
					"description": "(vector) The target position, should be at ground level of potential target",
					"mandatory": true
				}
			],
			"example": "throwvel = self CheckGrenadeThrowPos( armOffset, \"min energy\", targetPos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CheckProne",
			"description": "Returns true when a character can go prone at the specified position. Specifically setup for use by AI characters.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "(vector) The position of the prone character.",
					"mandatory": true
				},
				{
					"name": "yaw",
					"description": "(float) The world yaw in degrees.",
					"mandatory": true
				},
				{
					"name": "is prone",
					"description": "(bool) Flag if the character is already prone.",
					"mandatory": true
				}
			],
			"example": "canFitProne = self CheckProne( origin, yaw, alreadyProne )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ChooseBetterCoverNode",
			"description": "Chooses a better cover node for an ai",
			"calledOn": "actor",
			"parameters": [],
			"example": "newNode = behaviorTreeEntity ChooseBetterCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearEnemy",
			"description": "Clear the actor's current enemy entity.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearEnemy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearEntityOwner",
			"description": "Clears an AI's entity owner.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearEntityOwner()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearEntityTarget",
			"description": "Clears an AI's entity target.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearEntityTarget( vehicle_entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearFixedNodeSafeVolume",
			"description": "Clears this actor's fixed node safe volume.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearFixedNodeSafeVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearForcedGoal",
			"description": "Clears the forcedGoal for this AI's goal.",
			"calledOn": "sentient",
			"parameters": [],
			"example": "self ClearForcedGoal()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearGoalVolume",
			"description": "Clears this actor's goal volume.",
			"calledOn": "sentient",
			"parameters": [],
			"example": "self ClearGoalVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPath",
			"description": "Clears the AI's current path.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearPath()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPitchOrient",
			"description": "Clear pitch orientation",
			"calledOn": "actor",
			"parameters": [],
			"example": "self clearPitchOrient()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPotentialThreat",
			"description": "Clear the potential threat direction. See SetPotentialThreat for more info on potential threats",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "dir",
					"description": "direction of the threat. This is the angle from which the NPC should expect danger",
					"mandatory": true
				}
			],
			"example": "self ClearPotentialThreat( 90 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearUsePosition",
			"description": "Clear the override for the goal pos.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ClearUsePosition()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CollideWithActors",
			"description": "Toggles collision with other actors. Actor will go through each other, when its toggled off.",
			"calledOn": "actor",
			"parameters": [
				{}
			],
			"example": "entity CollideWithActors( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CreateThreatBiasGroup",
			"description": "Create a new threat bias group. If it already exists, do nothing",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "threat bias group name.",
					"mandatory": true
				}
			],
			"example": "CreateThreatBiasGroup( \"flanking_team\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DamageMode",
			"description": "Set the damage mode of this actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "damage mode",
					"description": "(const string) DamageMode must be 'normal' or 'next_shot_kills'",
					"mandatory": true
				}
			],
			"example": "randAlly DamageMode(\"next_shot_kills\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DropWeapon",
			"description": "Drop the actor's weapon",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "weapon name",
					"description": "(string) The name of the weapon.",
					"mandatory": true
				},
				{
					"name": "hand",
					"description": "(string) The tag to throw the weapon from.",
					"mandatory": true
				},
				{
					"name": "velocity",
					"description": "(vector) The initial velocity of the weapon.",
					"mandatory": false
				},
				{
					"name": "angular velocity",
					"description": "(vector) The initial angular velocity of the weapon.",
					"mandatory": false
				},
				{
					"name": "scavenger",
					"description": "(bool) If the weapon requires the player to have scavenger perk to pick up the weapon.",
					"mandatory": false
				}
			],
			"example": "self DropWeapon(self.weapon, self.anim_gunHand, throwVel)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindBestCoverNode",
			"description": "Find the best cover node for a given NPC given his state.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self FindBestCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindBestCoverNodes",
			"description": "Find the best cover nodes for a given NPC given his state. Sorted by best",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "radius",
					"description": "search radius",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "search origin",
					"mandatory": true
				}
			],
			"example": "nodes = self FindBestCoverNodes(radius,origin)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindCoverNodeAtLocation",
			"description": "Finds a near by cover node for the character.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "radius",
					"description": "search radius",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "search origin",
					"mandatory": true
				}
			],
			"example": "guy FindCoverNodeAtLocation(512,loc)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindReacquireDirectPath",
			"description": "Finds a path directly to the enemy. Call ReacquireMove to use the path.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "ignore suppression",
					"description": "Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindReacquireNode",
			"description": "Finds a reacquire node when exposed.",
			"calledOn": "actor",
			"parameters": [],
			"example": "guy FindReacquireNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FindReacquireProximatePath",
			"description": "Finds a path to a point that can see the enemy without leaving goal. Call ReacquireMove to use the path.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "ignore suppression",
					"description": "Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FinishActorDamage",
			"description": "Does damage to an actor - usually as part of the damage callback",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "Inflictor",
					"description": "The entity that causes the damage.(e.g. a turret)",
					"mandatory": true
				},
				{
					"name": "Attacker",
					"description": "The entity that is attacking.",
					"mandatory": true
				},
				{
					"name": "Damage",
					"description": "Integer specifying the amount of damage done",
					"mandatory": true
				},
				{
					"name": "Damage Flags",
					"description": "Integer specifying flags that are to be applied to the damage",
					"mandatory": true
				},
				{
					"name": "Means Of Death",
					"description": "Integer specifying the method of death",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				},
				{
					"name": "Direction",
					"description": "(vector) The direction of the damage",
					"mandatory": true
				},
				{
					"name": "Hit Loc",
					"description": "The location of the hit",
					"mandatory": true
				},
				{
					"name": "Damage Origin",
					"description": "Position of the originator of the damage",
					"mandatory": true
				},
				{
					"name": "Offset Time",
					"description": "The time offset for the damage",
					"mandatory": true
				},
				{
					"name": "Bone Index",
					"description": "Index of nearest bone",
					"mandatory": true
				},
				{
					"name": "Surface Type",
					"description": "The surface type of the hit location",
					"mandatory": false
				},
				{
					"name": "Surface Normal",
					"description": "The surface normal at hit location",
					"mandatory": false
				}
			],
			"example": "self FinishActorDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, vDamageOrigin, psOffsetTime, iBoneIndex, iSurfaceType, vSurfaceNormal )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForceTeleport",
			"description": "Force Teleport the actor to a new position with the given origin and angles, regardless of wether it will be visible to the player or not.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "(point) The actor's new position.",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "(vector) The actor's new angles.",
					"mandatory": false
				},
				{
					"name": "updategoalpos",
					"description": "(bool) Update the script goal position to the teleport location. True by default.",
					"mandatory": false
				},
				{
					"name": "resetEntity",
					"description": "(bool) Reset the entity behaviors.",
					"mandatory": false
				}
			],
			"example": "self ForceTeleport( org, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GenerateRadioEvent",
			"description": "Searches animation selector table and returns an animation alias based on current state of the blackboard.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "type of event",
					"description": "The type of radio event",
					"mandatory": true
				}
			],
			"example": "self GenerateRadioEvent(\"radio_event_low\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAimLimitsFromEntry",
			"description": "Searches animation selector table and returns an animation alias based on current state of the blackboard.",
			"calledOn": "actor",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBehaviorTreeStatus",
			"description": "Returns current status/BHTN_STATUS of the behavior tree for an actor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "isBehaviorTreeInRunningState = behaviorTreeEntity GetBehaviortreeStatus() == BHTN_RUNNING",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetClosestEnemySqDist",
			"description": "Get the distance to the nearest enemy",
			"calledOn": "sentient",
			"parameters": [],
			"example": "dist = self GetClosestEnemySqDist()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDropToFloorPosition",
			"description": "Gets the floor position for dropping an AI or player to the ground. Returns undefined if the AI is in solid.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "position",
					"description": "test position. Defaults to entity's current origin",
					"mandatory": false
				}
			],
			"example": "position = ai GetDropToFloorPosition( ai.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFinalPathPos",
			"description": "Get the last position in the path",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFireMode",
			"description": "returns the firemode",
			"calledOn": "actor",
			"parameters": [],
			"example": "soldier GetFireMode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFixedNodeSafeVolume",
			"description": "Get this actor's fixed node safe volume.",
			"calledOn": "actor",
			"parameters": [],
			"example": "volume = self GetFixedNodeSafeVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFlashBangedStrength",
			"description": "Retrieves how strongly the actor was initially hit by a flashbang. 1.0 is full strength, 0.0 is none at all.",
			"calledOn": "actor",
			"parameters": [],
			"example": "flashedPercent = self GetFlashBangedStrength()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGoalVolume",
			"description": "Get this actor's goal volume.",
			"calledOn": "sentient",
			"parameters": [],
			"example": "goalVolume = self GetGoalVolume()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGroundEntType",
			"description": "Get the entity type of the 'ground' that the actor is on.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetGroundEntType()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHitEntType",
			"description": "Get the type of entity that the actor has hit. Can be 'hit', 'obstacle' or 'world'.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetHitEntType()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHitYaw",
			"description": "Get the direction in degrees that the player has hit an obstacle at. Returns an error if nothing was hit.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetHitYaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetIgnoreEnt",
			"description": "Returns if a specific sentient entity is ignored by this sentient entity or not",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "sentient",
					"description": "Another sentient entity",
					"mandatory": true
				}
			],
			"example": "if ( aiGuy GetIgnoreEnt( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNextFindBestCoverTime",
			"description": "Generates a new next find cover time",
			"calledOn": null,
			"parameters": [
				{
					"name": "minEngageDist",
					"description": "Min engage enemy dist.",
					"mandatory": true
				},
				{
					"name": "maxEngageDist",
					"description": "Max engage enemy dist.",
					"mandatory": true
				},
				{
					"name": "noEnemyInterval",
					"description": "How often cover should be searched when without an enemy",
					"mandatory": true
				}
			],
			"example": "behaviorTreeEntity.nextFindBestCoverTime = GetActorNextFindBestCoverTime( behaviorTreeEntity.engageMinDist, behaviorTreeEntity.engagemaxdist, behaviorTreeEntity.coversearchinterval )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeOffsetAngles",
			"description": "Returns the angles the actor thinks the node is facing, this can contain additional rotation from the node's actual angles.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetNodeOffsetAngles( self.node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNodeOffsetPosition",
			"description": "Returns the position the actor thinks the node's origin is at, this can be offset from where the actual node's position in the world is.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetNodeOffsetPosition( self.node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetOrientMode",
			"description": "Set the orient mode of this actor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "orientMode = randAlly GetOrientMode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathLength",
			"description": "Gets the length of the path being used by this actor",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GetPathLength()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathMode",
			"description": "Get the path mode of this actor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "pathMode = randAlly GetPathMode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPerfectInfo",
			"description": "Forces the AI to become aware of this entity regardless of whether it can be seen or not.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity to become aware of. Must be a sentient (i.e. AI or player)",
					"mandatory": true
				},
				{
					"name": "update sight",
					"description": "If true then it will update the last seen position also.",
					"mandatory": false
				}
			],
			"example": "self GetPerfectInfo( get_players()[0] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPersonalThreatBias",
			"description": "return the personal threat bias for this sentient versus the other sentient",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "sentient",
					"description": "Self",
					"mandatory": true
				},
				{
					"name": "enemy",
					"description": "The enemy to get threat bias for",
					"mandatory": true
				}
			],
			"example": "value = self GetPersonalThreatBias( self.enemy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetReacquireNode",
			"description": "Gets the reacquire node of this actor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "guy GetReacquireNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetStealthSightValue",
			"description": "Get the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "otherSentient",
					"description": "other sentient you want to get the value on this sentient for",
					"mandatory": true
				}
			],
			"example": "aiGuy GetStealthSightValue( forOtherGuy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetThreatBias",
			"description": "Get threat bias of first group against second group",
			"calledOn": null,
			"parameters": [
				{
					"name": "of group",
					"description": "(string) threat bias group for.",
					"mandatory": true
				},
				{
					"name": "against group",
					"description": "(string) threat bias group against.",
					"mandatory": true
				}
			],
			"example": "GetThreatBias( \"axis\", \"flanking_team\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetThreatBiasGroup",
			"description": "Get the threat bias group of an AI or player",
			"calledOn": "entity",
			"parameters": [],
			"example": "GetThreatBiasGroup()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurnExitYaw",
			"description": "Predicts exit yaw vector using havok pathfinding.",
			"calledOn": "actor",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GrenadeThrow",
			"description": "Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self GrenadeThrow()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasPath",
			"description": "returns true/false if AI has a path",
			"calledOn": "sentient",
			"parameters": [],
			"example": "self HasPAth()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasValidInterrupt",
			"description": "Return true if there is a valid interrupt with the given name alive on the current server frame.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "interrupt name",
					"description": "The name of the interrupt",
					"mandatory": true
				}
			],
			"example": "if ( entity HasValidInterrupt(\"pain\") )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsActorShooting",
			"description": "Checks whether this entity is an ai is shooting",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "entity",
					"description": "An actor",
					"mandatory": true
				}
			],
			"example": "if ( meanGuy IsActorShooting() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsApproachingGoal",
			"description": "returns true/false if actor at the goal or approaching the goal.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsApproachingGoal()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAtCoverNode",
			"description": "returns true/false if actor is at cover node. (exposed node is considered as covernode)",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsAtCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAtCoverNodeStrict",
			"description": "returns true/false if actor is at cover node. (exposed node is not considered as covernode)",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsAtCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsAtGoal",
			"description": "returns true/false if actor has at/reached its current goal, similar to waiting for \"goal\" notify.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsAtGoal()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsBadGuy",
			"description": "Returns true if the sentient is on the bad guy team (not 'allies', not 'neutral').",
			"calledOn": "entity",
			"parameters": [],
			"example": "if ( ai IsBadGuy() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCoverValid",
			"description": "Return true if the passed in node is a valid cover node.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "pathnode",
					"description": "The pathnode to check for validity",
					"mandatory": true
				}
			],
			"example": "if( self IsCoverValid( pathnode ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCurrentBTActionLooping",
			"description": "Return true if there is an action running and its looping.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if( behaviorTreeEntity IsCurrentBTActionLooping() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDeflected",
			"description": "Check if the actor has been deflected.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsDeflected()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFlankedAtCoverNode",
			"description": "returns true/false if actor is at is flanked at cover node",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsFlankedAtCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGrenadePosSafe",
			"description": "Checks a grenade throw target position is safe.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "throw pos",
					"description": "(vector) position to throw at",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "(float) safety radius",
					"mandatory": false
				}
			],
			"example": "if ( self IsGrenadeThrowSafe( throwPos, 200 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInAnyBadPlace",
			"description": "Returns whether the AI is in a bad place.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsInAnyBadPlace()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInGoal",
			"description": "Determine whether a given point is in the actor's current goal area",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "point",
					"description": "which point to check.",
					"mandatory": true
				}
			],
			"example": "if ( ai IsInGoal( point ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInScriptedState",
			"description": "Checks if actor is in a scripted state (animscripted, custom, negotiation)",
			"calledOn": "actor",
			"parameters": [],
			"example": "self isInScripteState()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsKnownEnemyInRadius",
			"description": "Checks if there is a known enemy in a radius for an AI.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "center of radius to check.",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": ".",
					"mandatory": true
				}
			],
			"example": "if ( self IsKnownEnemyInRadius( pos, radius ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsKnownEnemyInVolume",
			"description": "Checks if there is a known enemy in a volume for an AI.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "volume",
					"description": "volume entity to check in.",
					"mandatory": true
				}
			],
			"example": "if ( self isKnownEnemyInVolume( volume ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMoveSuppressed",
			"description": "Checks whether this actor is in a suppressed state ( blocked by friendly fire ).",
			"calledOn": "actor",
			"parameters": [],
			"example": "while ( self IsMoveSuppressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsNoTarget",
			"description": "returns if the sentient is marked no target",
			"calledOn": "sentient",
			"parameters": [],
			"example": "if ( self IsNoTarget() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPathDirect",
			"description": "Check whether the actor's current path is direct",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsPathDirect()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPosAtGoal",
			"description": "returns true/false if position is inside the current goal",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsPosAtGoal(position)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPosInClaimedLocation",
			"description": "returns true/false if position is claimed by another sentient",
			"calledOn": "sentient",
			"parameters": [],
			"example": "self IsPosInClaimedLocation( position )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSafeFromGrenade",
			"description": "returns true/false if actor is within a blast radius of a grenade.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self IsSafeFromGrenade()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsStanceAllowed",
			"description": "Checks whether this actor can go to the given stance.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "stance",
					"description": "(string) A stance, can be 'prone', 'crouch', 'stand'.",
					"mandatory": true
				}
			],
			"example": "if ( self IsStanceAllowed( \"stand\" ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSuppressed",
			"description": "Checks whether this actor is in a suppressed state ( under fire ).",
			"calledOn": "actor",
			"parameters": [],
			"example": "while ( self IsSuppressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSuppressionWaiting",
			"description": "Checks whether this actor is still doing suppression wait.",
			"calledOn": "actor",
			"parameters": [],
			"example": "while ( self IsSuppressionWaiting() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsThreateningMyProtectEntity",
			"description": "Returns true if the enemy is currently threatening my protect entity.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "target",
					"description": "(sentient) The sentient to check.",
					"mandatory": true
				}
			],
			"example": "if ( self IsThreateningMyProtectEntity( self.enemy ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Knockback",
			"description": "Turn knockback on and off for an actor",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "true/false",
					"description": "if true, actor affected by knockback",
					"mandatory": true
				}
			],
			"example": "self Knockback( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LastKnownPos",
			"description": "Return the last known pos of an AI.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "target",
					"description": "(sentient) The sentient to check.",
					"mandatory": true
				}
			],
			"example": "if ( self lastKnownPos( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LastKnownTime",
			"description": "Return the last time an AI was aware of target. Includes visibility and ai events like footstep, gunshot etc.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "target",
					"description": "(sentient) The sentient to check.",
					"mandatory": true
				}
			],
			"example": "if( self lastKnownTime( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LerpPosition",
			"description": "Interpolate an actor's position, and angles.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "origin",
					"description": "(vector) the position to interpolate to.",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "(vector) the angles to interpolate to.",
					"mandatory": true
				}
			],
			"example": "self LerpPosition( entry['origin'], entry['angles'] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MayMoveFromPointToPoint",
			"description": "Check whether the actor can move from a given point to a given point. Does not check friendly fire and in goal radius unlike maymovetopoint",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "start",
					"description": "(point) start position.",
					"mandatory": true
				},
				{
					"name": "end",
					"description": "(point) end position.",
					"mandatory": true
				},
				{
					"name": "check drop",
					"description": "checks if the point would cause the AI to drop. Defaults to true.",
					"mandatory": false
				},
				{
					"name": "check direct",
					"description": "checks if there are no obstructions between actor origin and <Position>.",
					"mandatory": false
				}
			],
			"example": "if ( !self MayMoveFromPointToPoint( startPoint endPoint ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MayMoveToPoint",
			"description": "Check whether the actor can move to a given point.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "(point) The position that the actor may be able to move to.",
					"mandatory": true
				},
				{
					"name": "check drop",
					"description": "checks if the point would cause the AI to drop. Defaults to true.",
					"mandatory": false
				},
				{
					"name": "check direct",
					"description": "checks if there are no obstructions between actor origin and <Position>.",
					"mandatory": false
				}
			],
			"example": "if ( !self MayMoveToPoint( endPoint ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Melee",
			"description": "Makes this actor melee attack. Returns the entity hit, if any.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "direction",
					"description": "direction to attack, if not specified, uses direction to current enemy.",
					"mandatory": false
				}
			],
			"example": "guy Melee()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MeleeWithOffset",
			"description": "Makes this actor melee attack. Returns the entity hit, if any.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "offset",
					"description": "A vector offset added to the actor's eye position from which to start the melee trace.",
					"mandatory": true
				}
			],
			"example": "guy MeleeWithOffset( (0,0,32) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NearClaimNode",
			"description": "Determine whether this actor is near its claim node.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if ( ai NearClaimNode() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NearClaimNodeAndAngle",
			"description": "Determine whether this actor is near its claim node and nearly matches the angle.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if ( ai NearClaimNodeAndAngle() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NearNode",
			"description": "Determine whether this actor is near to a given path node.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "node",
					"description": "The path node to check.",
					"mandatory": true
				}
			],
			"example": "if ( ai NearNode( node ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OrientMode",
			"description": "Set the orient mode of this actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "orient mode",
					"description": "(const string) OrientMode must be 'face angle', 'face current', 'face direction', 'face enemy', 'face enemy or motion', 'face goal', 'face motion', 'face point', or 'face default'",
					"mandatory": true
				},
				{
					"name": "face angle",
					"description": "(float) The yaw angle to face if orient mode is 'face angle'",
					"mandatory": false
				},
				{
					"name": "direction vector",
					"description": "(vector) The direction vector to face if orient mode is 'face direction'",
					"mandatory": false
				},
				{
					"name": "face position",
					"description": "(vector) The point to face if orient mode is 'face point'",
					"mandatory": false
				}
			],
			"example": "randAlly OrientMode(\"face direction\", player.origin-randAlly.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathMode",
			"description": "Set the path mode of this actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "path mode",
					"description": "(const string) PathMode must be 'dont move', 'move allowed', or 'move delayed'",
					"mandatory": true
				},
				{
					"name": "clear path",
					"description": "(integer) 1 to clear path",
					"mandatory": false
				},
				{
					"name": "path delay",
					"description": "(float) Amount of time (seconds) to wait if path mode is 'move delayed'",
					"mandatory": false
				}
			],
			"example": "randAlly PathMode(\"dont move\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PickUpGrenade",
			"description": "Pick up a grenade",
			"calledOn": "actor",
			"parameters": [],
			"example": "self PickUpGrenade()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictArrival",
			"description": "Predicts the arrival direction vector using havok corner predictor.",
			"calledOn": "actor",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictExit",
			"description": "Predicts the exit direction vector using havok corner predictor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "predictedLookAheadInfo = self PredictExit()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PredictPath",
			"description": "Predicts the path to look for upcoming corner using havok corner predictor.",
			"calledOn": "actor",
			"parameters": [],
			"example": "predictedLookAheadInfo = self PredictPath()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PushPlayer",
			"description": "Set whether this character can push the player. Don't call this unless you know what you are doing.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "can push player",
					"description": "(bool) True if this character can push the player.",
					"mandatory": true
				}
			],
			"example": "level.elder PushPlayer( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReacquireMove",
			"description": "Start the reaquire move",
			"calledOn": "actor",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReacquireStep",
			"description": "Do side step move to safe place left or right while facing enemy.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "dist",
					"description": "(floating point number) amount to side step left or right",
					"mandatory": true
				}
			],
			"example": "reacquirePos = entity ReacquireStep( step_size )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoveSentientEventListener",
			"description": "De-Registers entity to listen to a specific event. if event is undefined, entity will stop listening to all the evnets.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "event",
					"description": "The event name",
					"mandatory": false
				}
			],
			"example": "self RemoveSentientEventListener(\"bulletwhizby\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetVisibilityCacheWithinRadius",
			"description": "Reset the viscache for sentients within the specified radius",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "Center of reset bounds",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "Distance around the origin to scan for sentients",
					"mandatory": true
				}
			],
			"example": "ResetVisibilityCacheWithinRadius(origin, 500)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SeeRecently",
			"description": "Check to see if the AI saw the given sentient in the past <time>. If called on a non-sentient, just does a cansee check",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "target",
					"description": "(entity) The entity to check.",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "(int) seconds.",
					"mandatory": true
				}
			],
			"example": "if( self SeeRecently( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntityOwner",
			"description": "Set an entity as the AI's owner. The owner will never be targeted.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity for owner.",
					"mandatory": true
				}
			],
			"example": "self SetEntityOwner( vehicle_entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEntityTarget",
			"description": "Set an entity as the AI's target. This is for special cases only. Do not set AI or player targets with this.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "entity",
					"description": "An entity to target (cannot be server only entity).",
					"mandatory": true
				},
				{
					"name": "threat",
					"description": "A fraction of maximum possible threat an AI can have. Must be in 0 to 1 range. Defaults to 1.",
					"mandatory": false
				},
				{
					"name": "tag name",
					"description": "Tag to aim/shoot at on this entity. Defaults to tag_eye for actors/players\".",
					"mandatory": false
				}
			],
			"example": "self SetEntityTarget( vehicle_entity, 0.7, \"tag_head\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFixedNodeSafeVolume",
			"description": "Set this actor's fixed node safe volume.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "volume entity",
					"description": "(entity) The safe volume entity.",
					"mandatory": true
				}
			],
			"example": "self SetFixedNodeSafeVolume( volume )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFlashBanged",
			"description": "Sets whether an actor is under a flashbang effect.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "flashed",
					"description": "Whether or not the actor is under the affect of a flashbang.",
					"mandatory": true
				},
				{
					"name": "strength",
					"description": "If actor is flashed, how severely they were initially affected. Between 0.0 and 1.0 (full strength).",
					"mandatory": false
				}
			],
			"example": "self SetFlashBanged( true, 0.8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFlashbangImmunity",
			"description": "Sets whether an actor is succeptable to flashbangs.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "immune",
					"description": "If the actor can be affected by flashbangs.",
					"mandatory": true
				}
			],
			"example": "level.suicideguy SetFlashbangImmunity( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetFreeCameraLockOnAllowed",
			"description": "Sets whether the ai is allowed to be locked onto in the demo free camera",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "allowed",
					"description": "boolean of whether it is allowed",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGoal",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setgoalentity",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setgoalnode",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setgoalpos",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setgoalvolume",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setgoalvolumeauto",
			"description": "Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "pos",
					"description": "/<node>/<entity>/<volume>",
					"mandatory": true
				},
				{
					"name": "forced",
					"description": "(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.",
					"mandatory": false
				},
				{
					"name": "goalradius",
					"description": "radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				},
				{
					"name": "goalheight",
					"description": "height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.",
					"mandatory": false
				}
			],
			"example": "self SetGoal( node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetIgnoreEnt",
			"description": "Set a sentient entity to ignore another specific sentient entity or not",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "sentient",
					"description": "Another sentient entity",
					"mandatory": true
				},
				{
					"name": "ignored",
					"description": "true/false",
					"mandatory": true
				}
			],
			"example": "aiGuy SetIgnoreEnt( player, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetIgnoreMeGroup",
			"description": "Make first group ignored by second group",
			"calledOn": null,
			"parameters": [
				{
					"name": "ignored group",
					"description": "(string) ignored group.",
					"mandatory": true
				},
				{
					"name": "ignoring group",
					"description": "(string) ignoring group.",
					"mandatory": true
				}
			],
			"example": "SetIgnoreMeGroup( \"flanking_team\", \"axis\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPersonalIgnore",
			"description": "self will not pick enemy as target for the duration",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "sentient",
					"description": "Self",
					"mandatory": true
				},
				{
					"name": "enemy",
					"description": "The enemy to set threat bias for",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "How long this threat bias lasts in seconds",
					"mandatory": false
				}
			],
			"example": "self SetPersonalIgnore( self.enemy, 5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPersonalThreatBias",
			"description": "Sets a personal threat bias for this sentient versus the other sentient.  It lasts for the given duration.",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "sentient",
					"description": "Self",
					"mandatory": true
				},
				{
					"name": "enemy",
					"description": "The enemy to set threat bias for",
					"mandatory": true
				},
				{
					"name": "threatBias",
					"description": "The threat bias amount",
					"mandatory": true
				},
				{
					"name": "duration",
					"description": "How long this threat bias lasts in seconds",
					"mandatory": false
				}
			],
			"example": "self SetPersonalThreatBias( self.enemy, -1000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPhysParams",
			"description": "Sets the collision bounds for an actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "radius",
					"description": "size of the actor.",
					"mandatory": true
				},
				{
					"name": "minsz",
					"description": "min height of the actor.",
					"mandatory": true
				},
				{
					"name": "maxsz",
					"description": "max height of the actor.",
					"mandatory": true
				}
			],
			"example": "self setPhysParams( 15, 0, 72 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPitchOrient",
			"description": "Set pitch orientation",
			"calledOn": "actor",
			"parameters": [],
			"example": "self setPitchOrient()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPotentialThreat",
			"description": "In non-combat situations. This is mostly useful for friendlies.",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "dir",
					"description": "direction of the threat. This is the angle from which the NPC should expect danger",
					"mandatory": true
				}
			],
			"example": "self SetPotentialThreat( 90 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRepairPaths",
			"description": "True allows havok to repath automatically if the AI moves off their predefined path.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "on_off",
					"description": "true to enable repair paths, false otherwise",
					"mandatory": true
				}
			],
			"example": "self SetRepairPaths( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStairsExitTransform",
			"description": "Sets the base transform for the exit stairs animation using the current position in the looping anim",
			"calledOn": "actor",
			"parameters": [],
			"example": "self SetStairsExitTransform()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStealthSight",
			"description": "Set the parameters for given awarenesslevel of stealth sight when active on an sentient",
			"calledOn": null,
			"parameters": [
				{
					"name": "awareness",
					"description": "\"unaware\", \"low_alert\", \"high_alert\", or \"combat\"",
					"mandatory": true
				},
				{
					"name": "timeDecay",
					"description": "float value of seconds stealth sight takes to fall off completely (0 for never/infinite)",
					"mandatory": true
				},
				{
					"name": "timeDistMin",
					"description": "float value of seconds stealth sight takes to grow completely at min range (0 for never/infinite)",
					"mandatory": true
				},
				{
					"name": "timeDistMax",
					"description": "float value of seconds stealth sight takes to grow completely at max range (0 for never/infinite)",
					"mandatory": true
				},
				{
					"name": "distMin",
					"description": "float value of the min distance",
					"mandatory": true
				},
				{
					"name": "distMax",
					"description": "float value of the max distance",
					"mandatory": true
				},
				{
					"name": "extendSight",
					"description": "indicates of sight continues beyond max range at the max rate",
					"mandatory": false
				}
			],
			"example": "SetStealthSight( \"high_alert\", 2, 1, 10, 200, 1000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStealthSightAwareness",
			"description": "Set the current stealth sight awareness state for this sentient",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "awareness",
					"description": "\"unaware\", \"low_alert\", \"high_alert\", \"combat\", or undefined to disable it (default disabled)",
					"mandatory": false
				},
				{
					"name": "decayEnabled",
					"description": "if true stealth sight will decay when other sentient is not in sight (default true)",
					"mandatory": false
				}
			],
			"example": "aiGuy SetStealthSightAwareness( \"unaware\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetStealthSightValue",
			"description": "Set the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)",
			"calledOn": "sentient",
			"parameters": [
				{
					"name": "otherSentient",
					"description": "other sentient you want to set the value on this sentient for",
					"mandatory": true
				},
				{
					"name": "newValue",
					"description": "The new stealth sight value",
					"mandatory": true
				}
			],
			"example": "aiGuy SetStealthSightValue( forOtherGuy, 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSteeringMode",
			"description": "Sets the steering mode for the actor.  Valid modes are \"normal steering\", \"slow steering\", \"vignette steering\".",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "steering mode",
					"description": "Mode to set.",
					"mandatory": true
				}
			],
			"example": "self SetSteeringMode( \"slow steering\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetThreatBias",
			"description": "Set threat bias of second group against first group",
			"calledOn": null,
			"parameters": [
				{
					"name": "against group",
					"description": "(string) threat bias group against.",
					"mandatory": true
				},
				{
					"name": "for group",
					"description": "(string) threat bias group for.",
					"mandatory": true
				},
				{
					"name": "threat bias",
					"description": "(int) threat bias value.",
					"mandatory": true
				}
			],
			"example": "SetThreatBias( \"axis\", \"flanking_team\", 120 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetThreatBiasAgainstAll",
			"description": "Set the threatbias a group has against all others",
			"calledOn": null,
			"parameters": [
				{
					"name": "group",
					"description": "(string) threat bias group name.",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "(int) threat bias value.",
					"mandatory": true
				}
			],
			"example": "SetThreatBiasAgainstAll( \"flanking_team\", 120 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetThreatBiasGroup",
			"description": "Set or clear threat bias group of an AI or player",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "threat_bias_group",
					"description": "(string) threat bias group name. If none, remove actor from current threat bias group",
					"mandatory": false
				}
			],
			"example": "SetThreatBiasGroup( \"flanking_team\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Shoot",
			"description": "Makes this actor shoot.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "accuracy modifier",
					"description": "(floating point number)",
					"mandatory": false
				},
				{}
			],
			"example": "guy shoot()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldFaceMotion",
			"description": "Determines if the AI should face the motion direction. Use self.faceMotion instead of this except when the AI is just beginning to move.",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ShouldFaceMotion()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldHoldGroundAgainstEnemy",
			"description": "Return true if enemy is within pathEnemyFightDist.",
			"calledOn": "actor",
			"parameters": [],
			"example": "if( behaviorTreeEntity ShouldHoldGroundAgainstEnemy() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldStartArrival",
			"description": "returns true/false if actor should start arriving at given node",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ShouldStartArrival()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldStartTraversal",
			"description": "returns true/false if actor should start traversal",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ShouldStartTraversal()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShouldUseCoverNode",
			"description": "returns true/false if actor is at is safe at cover node and use it as a cover",
			"calledOn": "actor",
			"parameters": [],
			"example": "self ShouldUseCoverNode()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartCoverArrival",
			"description": "Runs cover arrival animscript on an actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "start pos",
					"description": "the offset to start the arrival animation from",
					"mandatory": true
				},
				{
					"name": "yaw angles",
					"description": "the arrival angle",
					"mandatory": true
				}
			],
			"example": "soldier StartCoverArrival( pos, 45 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Teleport",
			"description": "Teleport the actor to a new position with the given origin and angles.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "(point) The actor's new position.",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "(vector) The actor's new angles.",
					"mandatory": false
				}
			],
			"example": "self Teleport( org, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ThreatBiasGroupExists",
			"description": "Check if a threat bias group exists",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "threat bias group name.",
					"mandatory": true
				}
			],
			"example": "ThreatBiasGroupExists( \"flanking_team\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TraverseMode",
			"description": "Set the traverse mode of this actor.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "traverse mode",
					"description": "(const string) Possible traverse modes are 'gravity', 'nogravity', or 'noclip'",
					"mandatory": true
				}
			],
			"example": "self TraverseMode( \"nogravity\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TrimPathtoAttack",
			"description": "Trims the path to attack.",
			"calledOn": "actor",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseCoverNode",
			"description": "Tells this actor to use the given cover node. This is invalid if the actor's keepclaimednode flag is set. Returns true or false depending on whether the actor can claim the node.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "path node",
					"description": "The path node to use as cover",
					"mandatory": true
				}
			],
			"example": "guy UseCoverNode( covernode )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UsePosition",
			"description": "Override where the actor should run to. This overrides the goal pos and the claimed node.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "position",
					"description": "The position for the actor to run to.",
					"mandatory": true
				},
				{
					"name": "arrivalfinalposition",
					"description": "The arrivalfinalposition if this is an arrival.",
					"mandatory": false
				}
			],
			"example": "self UsePosition( pos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseReacquireNode",
			"description": "Use the given reacquire node.",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "node",
					"description": "(path node) the node to use.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Abs",
			"description": "Returns the absolute value of a float",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "x = Abs( x )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AbsAngleClamp180",
			"description": "Returns abs angle value clamped between [0,180].",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles",
					"description": "Angle to be clamped",
					"mandatory": true
				}
			],
			"example": "deltaAngle = AbsAngleClamp180( currentAngle )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AbsAngleClamp360",
			"description": "Returns <angle> as a value in the range of 0 and 360 degrees.",
			"calledOn": null,
			"parameters": [
				{
					"name": "angle",
					"description": "An angle.",
					"mandatory": true
				}
			],
			"example": "new_angle = AbsAngleClamp360( boatAngles[2] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ACos",
			"description": "Returns an angle corresponding to a particular cosine value",
			"calledOn": null,
			"parameters": [
				{
					"name": "cos value",
					"description": "A cosine value",
					"mandatory": true
				}
			],
			"example": "upAngle = ACos( distanceratio )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AngleClamp180",
			"description": "Returns angle value clamped between [-180,180].",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles",
					"description": "Angle to be clamped",
					"mandatory": true
				}
			],
			"example": "deltaAngle = AngleClamp180( currentAngle )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AngleLerp",
			"description": "Returns <angle> lerped angle value.",
			"calledOn": null,
			"parameters": [
				{
					"name": "from",
					"description": "An angle.",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "An angle.",
					"mandatory": true
				},
				{
					"name": "fraction",
					"description": "A float from 0-1.",
					"mandatory": true
				}
			],
			"example": "180 = AngleLerp( 0, 360, 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnglesToForward",
			"description": "Returns the forward vector corresponding to a set of angles.",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles",
					"description": "A set of angles",
					"mandatory": true
				}
			],
			"example": "forward = AnglesToForward( forward )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnglesToRight",
			"description": "Returns the right vector corresponding to a set of angles.",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles",
					"description": "A set of angles",
					"mandatory": true
				}
			],
			"example": "right = AnglesToRight(angles)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnglesToUp",
			"description": "Returns the up vector corresponding to a set of angles.",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles",
					"description": "A set of angles",
					"mandatory": true
				}
			],
			"example": "up = AnglesToUp(angles)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ASin",
			"description": "Returns an angle corresponding to a particular sin value",
			"calledOn": null,
			"parameters": [
				{
					"name": "sin value",
					"description": "A sin value",
					"mandatory": true
				}
			],
			"example": "upAngle = ASin( upAmount )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ATan",
			"description": "Returns an angle corresponding to a particular tangential value",
			"calledOn": null,
			"parameters": [
				{
					"name": "tan value",
					"description": "A tangential value",
					"mandatory": true
				}
			],
			"example": "upAngle = ATan( height/distance )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Ceil",
			"description": "Returns the ceiling of floating point value <a>. This effectively rounds up Ceil(2.7) == 3, Ceil(3.9) == 4.",
			"calledOn": null,
			"parameters": [
				{
					"name": "a",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "rounded_down = Floor( val )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Closer",
			"description": "Tests which of two points is the closest. Returns true if point a is closer to the reference than point b",
			"calledOn": null,
			"parameters": [
				{
					"name": "reference",
					"description": "The base position",
					"mandatory": true
				},
				{
					"name": "point a",
					"description": "The first point",
					"mandatory": true
				},
				{
					"name": "point b",
					"description": "The second point",
					"mandatory": true
				}
			],
			"example": "if( Closer( center, models[j].origin , models[i].origin ))...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CombineAngles",
			"description": "Returns angles b reoriented by angles a.",
			"calledOn": null,
			"parameters": [
				{
					"name": "angles a",
					"description": "Angles representing the orientation in which to place <angles b>",
					"mandatory": true
				},
				{
					"name": "angles b",
					"description": "Angles which will be reoriented",
					"mandatory": true
				}
			],
			"example": "crateAnglesInWorld = CombineAngles( boatAngles, crateAnglesInBoat )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Cos",
			"description": "Returns the cos of an angle",
			"calledOn": null,
			"parameters": [
				{
					"name": "angle",
					"description": "An angle in degrees",
					"mandatory": true
				}
			],
			"example": "frac = Cos( degrees )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DiffTrack",
			"description": "Returns a lagged value between <from> and <to> based on <rate> and <deltaTime>",
			"calledOn": null,
			"parameters": [
				{
					"name": "to",
					"description": "Float, start of the range",
					"mandatory": true
				},
				{
					"name": "from",
					"description": "Float, end of the range",
					"mandatory": true
				},
				{
					"name": "rate",
					"description": "Floating point",
					"mandatory": true
				},
				{
					"name": "deltaTime",
					"description": "Time elapsed",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DiffTrackAngle",
			"description": "Returns a lagged angle between <from> and <to> based on <rate> and <deltaTime>. Properly accounts for wrapping 2pi",
			"calledOn": null,
			"parameters": [
				{
					"name": "to",
					"description": "Float, start of the range",
					"mandatory": true
				},
				{
					"name": "from",
					"description": "Float, end of the range",
					"mandatory": true
				},
				{
					"name": "rate",
					"description": "Floating point",
					"mandatory": true
				},
				{
					"name": "deltaTime",
					"description": "Time elapsed",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Distance",
			"description": "Returns the distance between two points",
			"calledOn": null,
			"parameters": [
				{
					"name": "point1",
					"description": "The first point",
					"mandatory": true
				},
				{
					"name": "point2",
					"description": "The second point",
					"mandatory": true
				}
			],
			"example": "dist = Distance( org, ai[i].origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Distance2D",
			"description": "Returns the distance between two points, ignores height difference.",
			"calledOn": null,
			"parameters": [
				{
					"name": "point1",
					"description": "The first point",
					"mandatory": true
				},
				{
					"name": "point2",
					"description": "The second point",
					"mandatory": true
				}
			],
			"example": "dist = Distance2D( org, ai[i].origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Distance2DSquared",
			"description": "Returns the squared distance between two points, ignores height difference.",
			"calledOn": null,
			"parameters": [
				{
					"name": "point1",
					"description": "The first point",
					"mandatory": true
				},
				{
					"name": "point2",
					"description": "The second point",
					"mandatory": true
				}
			],
			"example": "distsq = Distance2DSquared( org, ai[i].origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DistanceSquared",
			"description": "Returns the squared distance between two points - this is cheaper than the actual distance as it doesn't involve a square root",
			"calledOn": null,
			"parameters": [
				{
					"name": "point1",
					"description": "The first point",
					"mandatory": true
				},
				{
					"name": "point2",
					"description": "The second point",
					"mandatory": true
				}
			],
			"example": "dist2 = DistanceSquared(models[j].origin, center)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Float",
			"description": "Casts a string or an integer to a float",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "A string or integer number to cast to a float",
					"mandatory": true
				}
			],
			"example": "x = Float( floatValString )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Floor",
			"description": "Returns the floor of floating point value <a>. This effectively rounds down Floor(2.7) == 2, Floor(3.9) == 3.",
			"calledOn": null,
			"parameters": [
				{
					"name": "a",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "rounded_down = Floor( val )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForwardRotateAroundUpByAngle",
			"description": "returns a vector that is the result of angles1 forward vector rotated around its up by degrees",
			"calledOn": null,
			"parameters": [
				{},
				{}
			],
			"example": "v=ForwardRotateByAngles( player_angles, frustum_edge_angle )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMinBitCountForNum",
			"description": "Returns the minimum number of bits needed to express the provided integer",
			"calledOn": null,
			"parameters": [
				{
					"name": "uint",
					"description": "The integer a minimum bit count is needed for",
					"mandatory": true
				}
			],
			"example": "GetMinBitCountForNum( 15 ) returns 4",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Int",
			"description": "Casts a floating point number or a string to an integer",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "A string or floating point number to cast to an integer",
					"mandatory": true
				}
			],
			"example": "x = Int( self.HUDHealthHeight )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Length",
			"description": "Returns the length of the given vector",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector",
					"description": "A vector",
					"mandatory": true
				}
			],
			"example": "dist = Length(models[j].origin - center)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LengthSquared",
			"description": "Returns the squared vector length for the given vector - this is cheaper than the actual vector length as it doesn't involve a square root",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector",
					"description": "A vector",
					"mandatory": true
				}
			],
			"example": "dist2 = LengthSquared(models[j].origin - center)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LerpFloat",
			"description": "Returns a lerped value between <from> and <to> based on <time>",
			"calledOn": null,
			"parameters": [
				{
					"name": "from",
					"description": "Floating point value, start of the range",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "Floating point value, end of the range",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Floating point value in the range of 0 - 1",
					"mandatory": true
				}
			],
			"example": "val = LerpFloat( 0, 10, 0.5);\t// would return 5.0",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LerpVector",
			"description": "Returns a lerped vector value between <from> and <to> based on <time>",
			"calledOn": null,
			"parameters": [
				{
					"name": "from",
					"description": "Vector, start of the range",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "Vector, end of the range",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Floating point value in the range of 0 - 1",
					"mandatory": true
				}
			],
			"example": "val = LerpVector( (0,0,0), (5,5,5), 0.5);\t// would return (2.5, 2.5, 2.5)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Log",
			"description": "Returns the logarithm of a number to base 10",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "y = Log( x )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MapFloat",
			"description": "Returns a lerped value between <from> and <to> based on <time>. <time> is a value between <timeMin> and <timeMax>.",
			"calledOn": null,
			"parameters": [
				{
					"name": "timeMin",
					"description": "Floating point value, min time value",
					"mandatory": true
				},
				{
					"name": "timeMax",
					"description": "Floating point value, max time value",
					"mandatory": true
				},
				{
					"name": "from",
					"description": "Floating point value, start of the result range",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "Floating point value, end of the result range",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "Floating point value in the range from <timeMin> to <timeMax>",
					"mandatory": true
				}
			],
			"example": "val = MapFloat( 1, 2, 0, 10, 1.5); // would return 5.0",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Max",
			"description": "Returns whichever of <a> or <b> is larger.",
			"calledOn": null,
			"parameters": [
				{
					"name": "a",
					"description": "A float or integer value.",
					"mandatory": true
				},
				{
					"name": "b",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "largest = Max( val1, val2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Min",
			"description": "Returns whichever of <a> or <b> is smallest.",
			"calledOn": null,
			"parameters": [
				{
					"name": "a",
					"description": "A float or integer value.",
					"mandatory": true
				},
				{
					"name": "b",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "smallest = Min( val1, val2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PackRgba",
			"description": "Packs rgba into a single int.",
			"calledOn": null,
			"parameters": [
				{
					"name": "red",
					"description": "as a float 0.0-1.0",
					"mandatory": true
				},
				{
					"name": "green",
					"description": "as a float 0.0-1.0",
					"mandatory": true
				},
				{
					"name": "blue",
					"description": "as a float 0.0-1.0",
					"mandatory": true
				},
				{
					"name": "alpha",
					"description": "as a float 0.0-1.0",
					"mandatory": true
				}
			],
			"example": "Byte4PackRgba( 1.0, 1.0, 1.0, 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PointOnSegmentNearestToPoint",
			"description": "Given a line segment and a point P, this returns the point on the segment that is closest to P.",
			"calledOn": null,
			"parameters": [
				{
					"name": "SegmentA",
					"description": "One endpoint of the line segment",
					"mandatory": true
				},
				{
					"name": "SegmentB",
					"description": "Other endpoint of the line segment",
					"mandatory": true
				},
				{
					"name": "P",
					"description": "The point",
					"mandatory": true
				}
			],
			"example": "nearestPoint = PointOnSegmentNearestToPoint( A, B, P )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Pow",
			"description": "Return the value of base raised to exp power.",
			"calledOn": null,
			"parameters": [
				{
					"name": "exp",
					"description": "A float or integer value, <b>.\"",
					"mandatory": true
				}
			],
			"example": "c = pow( 2, 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RandomFloat",
			"description": "Returns a random floating point number r, where 0 <= r < max",
			"calledOn": null,
			"parameters": [
				{
					"name": "max",
					"description": "The maximum floating point size",
					"mandatory": true
				}
			],
			"example": "if ( RandomFloat( 100 ) > 50 ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RandomFloatRange",
			"description": "Returns a random floating point number r, where min <= r < max",
			"calledOn": null,
			"parameters": [
				{
					"name": "min",
					"description": "The minimum result",
					"mandatory": true
				},
				{
					"name": "max",
					"description": "The maximum result",
					"mandatory": true
				}
			],
			"example": "rand = RandomFloatRange( 3.0, 5.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RandomInt",
			"description": "Returns a random integer between 0 and max-1 inclusive",
			"calledOn": null,
			"parameters": [
				{
					"name": "max",
					"description": "The maximum integer size",
					"mandatory": true
				}
			],
			"example": "if ( RandomInt( 100 ) > 50 ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RandomIntRange",
			"description": "Returns a random integer r, where min <= r < max",
			"calledOn": null,
			"parameters": [
				{
					"name": "min",
					"description": "The minimum result",
					"mandatory": true
				},
				{
					"name": "max",
					"description": "The maximum result + 1",
					"mandatory": true
				}
			],
			"example": "rand = RandomIntRange( 3, 5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotatePoint",
			"description": "Returns <angle> lerped angle value.",
			"calledOn": null,
			"parameters": [
				{
					"name": "point",
					"description": "A point.",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "An angle.",
					"mandatory": true
				}
			],
			"example": "rotatedPoint = RotatePoint(point, angle )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RotatePointAroundAxis",
			"description": "returns a vector that is the result of point rotated around the axis vector by num degrees",
			"calledOn": null,
			"parameters": [
				{},
				{},
				{}
			],
			"example": "v = RotatePointAroundAxis( point, up, degrees )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Sin",
			"description": "Returns the sin of an angle",
			"calledOn": null,
			"parameters": [
				{
					"name": "angle",
					"description": "An angle in degrees",
					"mandatory": true
				}
			],
			"example": "frac = Sin( degrees )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Sqrt",
			"description": "Returns the square-root of floating point value <a>.",
			"calledOn": null,
			"parameters": [
				{
					"name": "a",
					"description": "A float or integer value.",
					"mandatory": true
				}
			],
			"example": "c = sqrt( (a*a) + (b*b) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Tan",
			"description": "Returns the tan of an angle",
			"calledOn": null,
			"parameters": [
				{
					"name": "angle",
					"description": "An angle in degrees",
					"mandatory": true
				}
			],
			"example": "frac = Tan( degrees )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorCross",
			"description": "Returns the cross product of two vectors",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector a",
					"description": "The first vector",
					"mandatory": true
				},
				{
					"name": "vector b",
					"description": "The second vector",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorDot",
			"description": "Returns the dot product of two vectors",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector a",
					"description": "The first vector",
					"mandatory": true
				},
				{
					"name": "vector b",
					"description": "The second vector",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorFromLineToPoint",
			"description": "Given a line and a point P, this returns a vector perpendicular to the line and pointing from the line to P.",
			"calledOn": null,
			"parameters": [
				{
					"name": "SegmentA",
					"description": "One point on the line",
					"mandatory": true
				},
				{
					"name": "SegmentB",
					"description": "Another point on the line",
					"mandatory": true
				},
				{
					"name": "P",
					"description": "The point",
					"mandatory": true
				}
			],
			"example": "myvector = VectorFromLineToPoint( A, B, P )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorLerp",
			"description": "Linear interpolates between two vectors.",
			"calledOn": null,
			"parameters": [
				{
					"name": "from",
					"description": "The vector whose value is used when fraction is 0",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "The vector whose value is used when fraction is 1",
					"mandatory": true
				},
				{
					"name": "fraction",
					"description": "The fraction of the way between vectors.  Values less than 0 or greater than 1 do linear extrapolation.",
					"mandatory": true
				}
			],
			"example": "color = VectorLerp(oldColor, newColor, timeElapsed / timeTotal)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorNormalize",
			"description": "Returns a normalized copy of this vector",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector",
					"description": "The vector to normalize",
					"mandatory": true
				}
			],
			"example": "difference = VectorNormalize(end - start)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectorProjection",
			"description": "Returns the vector projection of vector a onto vector b",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector a",
					"description": "The first vector",
					"mandatory": true
				},
				{
					"name": "vector b",
					"description": "The second vector",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VectortoAngles",
			"description": "Returns a set of angles corresponding to the given vector.",
			"calledOn": null,
			"parameters": [
				{
					"name": "vector",
					"description": "The vector to convert to angles",
					"mandatory": true
				}
			],
			"example": "angles = VectortoAngles(end - start)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActionButtonPressed",
			"description": "Check if the player is pressing the 'action' button. Use this for when the player might be in a scripted sequence but might still press the jump button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self ActionButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActionSlotFourButtonPressed",
			"description": "Check if the player is pressing the action slot 4 button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self ActionSlotFourButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActionSlotOneButtonPressed",
			"description": "Check if the player is pressing the action slot 1 button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self ActionSlotOneButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActionSlotThreeButtonPressed",
			"description": "Check if the player is pressing the action slot 3 button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self ActionSlotThreeButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ActionSlotTwoButtonPressed",
			"description": "Check if the player is pressing the action slot 2 button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self ActionSlotTwoButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AddToDamageIndicator",
			"description": "Add damage to damage indicator",
			"calledOn": "client",
			"parameters": [
				{
					"name": "dmg",
					"description": "The damage",
					"mandatory": true
				},
				{
					"name": "direction",
					"description": "The direction of hit",
					"mandatory": false
				}
			],
			"example": "self AddToDamageIndicator( int( armor_damage ), vDir)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AdsButtonPressed",
			"description": "Check if the player is pressing the 'ads' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self AdsButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowAds",
			"description": "Sets whether the player can switch to ADS",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player ads",
					"description": ": A boolean. true if the player can switch to ADS, and false otherwise.",
					"mandatory": true
				}
			],
			"example": "player AllowAds( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowCrouch",
			"description": "Sets whether the player can crouch",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player crouch",
					"description": ": A boolean. true if the player can crouch, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowCrouch( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowDoubleJump",
			"description": "Sets whether the player can double jump",
			"calledOn": "player",
			"parameters": [
				{
					"name": "on off",
					"description": ": A boolean. true if the player can double jump, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowDoubleJump( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowJump",
			"description": "Sets whether the player can jump",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player jump",
					"description": ": A boolean. True if the player can jump, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowJump(false)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowLean",
			"description": "Sets whether the player can lean",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player lean",
					"description": ": A boolean. true if the player can lean, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowLean( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowMelee",
			"description": "Sets whether the player can melee",
			"calledOn": "player",
			"parameters": [
				{
					"name": "melee",
					"description": ": A boolean. True if the player can melee, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowMelee(false)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowMeleePowerLeft",
			"description": "Sets whether the player can melee power left",
			"calledOn": "player",
			"parameters": [
				{
					"name": "melee",
					"description": ": A boolean. True if the player can melee power left, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowMeleePowerLeft(false)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowProne",
			"description": "Sets whether the player can go prone",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player prone",
					"description": ": A boolean. true if the player can go prone, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowProne( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowSlide",
			"description": "Sets whether the player can slide",
			"calledOn": "player",
			"parameters": [
				{
					"name": "on off",
					"description": ": A boolean. true if the player can slide, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowSlide( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowSpectateTeam",
			"description": "Set whether the player can spectate the given team.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "team",
					"description": "A string description of the team. Valid teams are 'axis', 'allies', 'none' or 'freelook'",
					"mandatory": true
				},
				{
					"name": "spectate",
					"description": "A boolean value describing whether this player can spectate on this team.",
					"mandatory": true
				}
			],
			"example": "self AllowSpectateTeam( \"axis\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowSprint",
			"description": "Sets whether the player can sprint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player sprint",
					"description": ": A boolean. True if the player can sprint, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowSprint(false)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowStand",
			"description": "Sets whether the player can stand up",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player stand",
					"description": ": A boolean. true if the player can stand, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowStand( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AllowWallRun",
			"description": "Sets whether the player can wall run",
			"calledOn": "player",
			"parameters": [
				{
					"name": "on off",
					"description": ": A boolean. true if the player can wallrun, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player AllowWallRun( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AnyAmmoForWeaponModes",
			"description": "Returns true if the weapon has any ammo left",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to check",
					"mandatory": true
				}
			],
			"example": "if ( !(self AnyAmmoForWeaponModes( weapon )) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ApplyKnockBack",
			"description": "Applies a knockback on a player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "amount",
					"description": "the amount of knockback to apply",
					"mandatory": true
				},
				{
					"name": "dir",
					"description": "the direction of knockback to apply",
					"mandatory": false
				}
			],
			"example": "player ApplyKnockBack( 10, dir )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AreControlsFrozen",
			"description": "Returns true if the controls are frozen",
			"calledOn": "player",
			"parameters": [],
			"example": "if( player AreControlsFrozen() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AttackButtonPressed",
			"description": "Check if the player is pressing the fire button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self AttackButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationAirstrikeSelection",
			"description": "Begin a location air strike selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationAirstrikeSelection( LOCATION_SELECTOR )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationArtillerySelection",
			"description": "Begin a location artillery selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationArtillerySelection( LOCATION_SELECTOR )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationComlinkSelection",
			"description": "Begin a location com link selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationComlinkSelection( LOCATION_SELECTOR, 1000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationMortarSelection",
			"description": "Begin a location mortar selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationMortarSelection( LOCATION_SELECTOR, 1500 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationNapalmSelection",
			"description": "Begin a location napalm selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationNapalmSelection( LOCATION_SELECTOR )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BeginLocationSelection",
			"description": "Begin a location selection",
			"calledOn": "player",
			"parameters": [
				{
					"name": "selection name",
					"description": "The selection name",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The radius of the selection",
					"mandatory": false
				}
			],
			"example": "self BeginLocationSelection( LOCATION_SELECTOR )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BoostButtonPressed",
			"description": "Check if the player is pressing the change seat (Y) button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self BoostButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "BotSetRandomCharacterCustomization",
			"description": "Equips this class number with the default class",
			"calledOn": "bot",
			"parameters": [],
			"example": "self BotSetRandomCharacterCustomization()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ButtonBitState",
			"description": "Return true if the button_bit(s) indicated are pressed (note:  there is no way to know exactly which buttons are pressed on the client, since everything is remapped into these bit values)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "button",
					"description": ": name of button to check \"BUTTON_BIT_ATTACK\" for example, optionally can include as many button names as desired.  Returns true if all buttons indicated are true.",
					"mandatory": true
				}
			],
			"example": "if ( self ButtonBitState( \"BUTTON_BIT_ATTACK\") ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ButtonPressed",
			"description": "Check if the host is pressing the button/key, \"BUTTON_A\", \"BUTTON_B\", \"K\", etc...",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self ButtonPressed( \"BUTTON_A\" ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CalcPlayerOptions",
			"description": "Calculate player options",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom class slot",
					"description": "The custom class slot",
					"mandatory": true
				}
			],
			"example": "playerRenderOptions = self CalcPlayerOptions( class_num )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CalcWeaponOptions",
			"description": "Calculates weapon options",
			"calledOn": "player",
			"parameters": [
				{
					"name": "custom class slot",
					"description": "The custom class slot",
					"mandatory": true
				},
				{
					"name": "weapon slot",
					"description": "primary weapon=0 or secondary weapon=1 or knife weapon=2",
					"mandatory": true
				}
			],
			"example": "primaryWeaponOptions = self CalcWeaponOptions( class_num, 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CameraActivate",
			"description": "Turns the script camera on or off.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "active",
					"description": "True to activate the camera, false to turn it off and return to 1st person view",
					"mandatory": true
				}
			],
			"example": "get_players()[0] CameraActivate( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CameraSetAngles",
			"description": "Sets the focus point of the script camera.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "position",
					"description": "Either an entity to focus the camera on or a vector defining the camera's focus point",
					"mandatory": false
				}
			],
			"example": "get_players()[0] CameraSetAngles( ( 1100, -23, 644 ) )get_players()[0] CameraSetAngles( my_entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CameraSetLookAt",
			"description": "Sets the focus point of the script camera.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "position",
					"description": "Either an entity to focus the camera on or a vector defining the camera's focus point",
					"mandatory": false
				}
			],
			"example": "get_players()[0] CameraSetLookAt( ( 1100, -23, 644 ) )get_players()[0] CameraSetLookAt( my_entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CameraSetPosition",
			"description": "Sets the position of the script camera.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "position",
					"description": "Either an entity to link the camera to or a vector defining the world position",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "The angles to set for the camera",
					"mandatory": false
				}
			],
			"example": "get_players()[0] CameraSetPosition( ( 1100, -23, 644 ) )get_players()[0] CameraSetPosition( my_entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanPlaceRiotshield",
			"description": "Try to place riotshield where the player is standing.  return an array containing placement \"result\", \"origin\", and \"angles",
			"calledOn": "player",
			"parameters": [],
			"example": "placement = level.player CanPlaceRiotshield()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanPlayerPlaceTurret",
			"description": "Try to place a Turret where the player is looking.  It'll return an array containing the placement \"result\", \"origin\", and \"angles\".",
			"calledOn": "player",
			"parameters": [],
			"example": "placement = level.player CanPlayerPlaceTurret()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CanPlayerPlaceVehicle",
			"description": "Try to place a vehicle in front of the player.  It'll return an array containing the placement \"result\", \"origin\", and \"angles\".",
			"calledOn": "player",
			"parameters": [
				{
					"name": "radius",
					"description": "Radius of the bounds check",
					"mandatory": true
				},
				{
					"name": "height",
					"description": "Height of the bounds check",
					"mandatory": true
				},
				{
					"name": "forward Distance",
					"description": "Distance away from player origin.",
					"mandatory": true
				},
				{
					"name": "up Distance",
					"description": "Distance up from player origin.",
					"mandatory": true
				},
				{
					"name": "sweep Distance",
					"description": "Distance to sweep downwards.",
					"mandatory": true
				},
				{
					"name": "min normal",
					"description": "Minimum hit normal needed to be pass.",
					"mandatory": true
				}
			],
			"example": "placement = level.player CanPlayerPlaceVehicle( 25, 45, 50, 40, 80, 0.7 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CantSeeEntities",
			"description": "Returns the set of entities that a player cannot see within a given angle, given a set of entities",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entArray",
					"description": "The entities to check against",
					"mandatory": true
				},
				{
					"name": "dotRange",
					"description": "The cosine of the angle representing your fov",
					"mandatory": true
				},
				{
					"name": "trace",
					"description": "Perform a trace for entities",
					"mandatory": true
				}
			],
			"example": "if( isplayer( self.enemy ) && self.enemy CantSeeEntities( entArray, 67 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CarryTurret",
			"description": "Links the auto turret to the player to carry around.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "turret",
					"description": "The turret entity",
					"mandatory": true
				},
				{
					"name": "offset",
					"description": "the offset from the player to place the turret",
					"mandatory": true
				},
				{
					"name": "angleOffset",
					"description": "the angle offset of the turret",
					"mandatory": true
				}
			],
			"example": "player CarryTurret( turret, offset, angleOffset )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ChangeSeatButtonPressed",
			"description": "Check if the player is pressing the change seat (Y) button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self ChangeSeatButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearDamageIndicator",
			"description": "Clear damage indicator",
			"calledOn": "client",
			"parameters": [],
			"example": "self ClearDamageIndicator()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearPerks",
			"description": "removes all perks for a player",
			"calledOn": "player",
			"parameters": [],
			"example": "player ClearPerks()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClonePlayer",
			"description": "clone the player's model for death animations.",
			"calledOn": "client",
			"parameters": [
				{
					"name": "deathAnimationDuration",
					"description": "the duration of the death animation",
					"mandatory": true
				},
				{
					"name": "killing weapon",
					"description": "weapon that killed the player",
					"mandatory": true
				},
				{
					"name": "attacker",
					"description": "attacker that killed the player",
					"mandatory": false
				}
			],
			"example": "body = self ClonePlayer(deathAnimDuration)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CloseInGameMenu",
			"description": "close the in game menu for this client.",
			"calledOn": "client",
			"parameters": [],
			"example": "player CloseInGameMenu()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CloseLUIMenu",
			"description": "Closes the given lui menu and returns true if it finds the menu and succeeds in closing it, false otherwise.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lui menu handle",
					"description": "handle to the lui menu.",
					"mandatory": true
				}
			],
			"example": "player CloseLUIMenu( menu )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CloseMenu",
			"description": "close the specified menu for this client.",
			"calledOn": "client",
			"parameters": [
				{
					"name": "menu index",
					"description": "The precached menu index of type \"menu\"",
					"mandatory": true
				}
			],
			"example": "player CloseMenu( game[ \"menu_changeclass\" ] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CreateFlashbackClone",
			"description": "clone the player's model for temporary flashback model",
			"calledOn": "client",
			"parameters": [],
			"example": "body = self CreateFlashbackClone()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DamageRiotShield",
			"description": "Apply damage to a player riot shield or other weapon that supports damage states.",
			"calledOn": "player",
			"parameters": [],
			"example": "newhealth = player DamageRiotShield( 100 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DeathStreakActive",
			"description": "Returns true if player's death streak is active",
			"calledOn": "player",
			"parameters": [],
			"example": "if( player DeathStreakActive() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableDeathStreak",
			"description": "Disable player's death streak",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableDeathStreak()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableInvulnerability",
			"description": "Makes player vulnerable to damage.  This is default behavior",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableInvulnerability()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableOffhandWeapons",
			"description": "Disable the player's offhand weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableOffhandWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableRoundStartDelay",
			"description": "Enable players weapon after round start delay",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableRoundStartDelay()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableUsability",
			"description": "Disables usability for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableUsability()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableWeaponCycling",
			"description": "Disable the player's weapon cycling",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableWeaponCycling()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableWeaponFire",
			"description": "Disable the player's weapon fire",
			"calledOn": "player",
			"parameters": [],
			"example": "player DisableWeaponFire(()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableWeapons",
			"description": "Disable the weapons of the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "quick",
					"description": "Set the Disable weapons quick flag",
					"mandatory": false
				}
			],
			"example": "self DisableWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DropItem",
			"description": "Drop an item with the given item name",
			"calledOn": "player",
			"parameters": [
				{
					"name": "item name",
					"description": "the name of the item to drop",
					"mandatory": true
				},
				{
					"name": "dropTag",
					"description": "If specified drop and snap the weapon to this tag",
					"mandatory": false
				}
			],
			"example": "self DropItem( current )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DropScavengerItem",
			"description": "Drop an item with the given item name. This item will be only available to those with the scavenger perk",
			"calledOn": "player",
			"parameters": [
				{
					"name": "item name",
					"description": "the name of the item to drop",
					"mandatory": true
				}
			],
			"example": "self DropScavengerItem( \"scavenger_item_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableDeathStreak",
			"description": "Enable player's death streak",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableDeathStreak()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableInvulnerability",
			"description": "Makes player invulnerable to damage",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableInvulnerability()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableOffhandWeapons",
			"description": "Enable the player's offhand weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableOffhandWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableRoundStartDelay",
			"description": "Disable the players weapon during round start",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableRoundStartDelay()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableUsability",
			"description": "Enables usability for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableUsability()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableWeaponCycling",
			"description": "Enable the player's weapon cycling",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableWeaponCycling()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableWeaponFire",
			"description": "Enable the player's weapon fire",
			"calledOn": "player",
			"parameters": [],
			"example": "player EnableWeaponFire()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnableWeapons",
			"description": "Enables the weapons of the player",
			"calledOn": "player",
			"parameters": [],
			"example": "self EnableWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EndLocationSelection",
			"description": "Ends location selection",
			"calledOn": "player",
			"parameters": [],
			"example": "self endLocationSelection()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FakeDamageFrom",
			"description": "Make the player take damage from the given direction",
			"calledOn": "player",
			"parameters": [
				{
					"name": "dir",
					"description": "The direction to take damage from",
					"mandatory": true
				}
			],
			"example": "self FakeDamageFrom(vDir)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "finishMeleeHit",
			"description": "Notifies the clients of the melee hit or miss",
			"calledOn": "client",
			"parameters": [
				{
					"name": "Attacker",
					"description": "The entity that is attacking.",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				},
				{
					"name": "Origin",
					"description": "(vector) The origin of the damage",
					"mandatory": true
				},
				{
					"name": "Direction",
					"description": "(vector) The direction of the damage",
					"mandatory": true
				},
				{
					"name": "bone index",
					"description": "Which bone was the closest to the hit",
					"mandatory": true
				},
				{
					"name": "shieldHit",
					"description": "Was the hit delivered against a shield",
					"mandatory": true
				},
				{
					"name": "hit",
					"description": "Was the hit successful or a swipe",
					"mandatory": true
				},
				{
					"name": "fromBehind",
					"description": "Was the hit from behind the victim",
					"mandatory": true
				}
			],
			"example": "self finishMeleeHit( eAttacker, sWeapon, vPoint, vDir, iBoneIndex, bHit )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FinishPlayerDamage",
			"description": "Does damage to a player - usually as part of the damage callback",
			"calledOn": "client",
			"parameters": [
				{
					"name": "Inflictor",
					"description": "The entity that causes the damage.(e.g. a turret)",
					"mandatory": true
				},
				{
					"name": "Attacker",
					"description": "The entity that is attacking.",
					"mandatory": true
				},
				{
					"name": "Damage",
					"description": "Integer specifying the amount of damage done",
					"mandatory": true
				},
				{
					"name": "Damage Flags",
					"description": "Integer specifying flags that are to be applied to the damage",
					"mandatory": true
				},
				{
					"name": "Means Of Death",
					"description": "Integer specifying the method of death",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				},
				{
					"name": "Point",
					"description": "Damage point",
					"mandatory": true
				},
				{
					"name": "Direction",
					"description": "(vector) The direction of the damage",
					"mandatory": true
				},
				{
					"name": "Hit Loc",
					"description": "The location of the hit",
					"mandatory": true
				},
				{
					"name": "Damage Origin",
					"description": "Where the damage originated from.",
					"mandatory": true
				},
				{
					"name": "Offset Time",
					"description": "The time offset for the damage",
					"mandatory": true
				},
				{
					"name": "bone index",
					"description": "Which bone was the closest to the hit",
					"mandatory": true
				},
				{
					"name": "Surface Normal",
					"description": "The normal of the surface impacted.",
					"mandatory": true
				}
			],
			"example": "self FinishPlayerDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, iBone, vDamageOrigin, psOffsetTime, vSurfaceNormal )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForceGrenadeThrow",
			"description": "Forces the player to throw a held grenade",
			"calledOn": "player",
			"parameters": [],
			"example": "player ForceGrenadeThrow()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForceOffHandEnd",
			"description": "Force the player to not use offhand weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "self forceoffhandend()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ForceSlick",
			"description": "Sets whether the player is forced to be on a slick surface",
			"calledOn": "player",
			"parameters": [
				{
					"name": "slick",
					"description": ": A boolean. True if the player is on a slick surface, and false otherwise",
					"mandatory": true
				}
			],
			"example": "player ForceSlick(true)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FragButtonPressed",
			"description": "Check if the player is pressing the frag button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self FragButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FreezeControls",
			"description": "Blocks or unblocks control input from this player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "freeze state",
					"description": ": true if the player's controls are frozen, false otherwise.",
					"mandatory": true
				}
			],
			"example": "player FreezeControls( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FreezeControlsAllowLook",
			"description": "Blocks or unblocks control input from this player, but allows the player to look around",
			"calledOn": "player",
			"parameters": [
				{
					"name": "freeze state",
					"description": ": true if the player's controls are frozen, false otherwise.",
					"mandatory": true
				}
			],
			"example": "level.player FreezeControlsAllowLook( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GamepadUsedLast",
			"description": "Check if the player is playing with a gamepad.",
			"calledOn": "player",
			"parameters": [],
			"example": "if( player GamepadUsedLast() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyModel",
			"description": "Gets the body model for this player as selected in character customization",
			"calledOn": "player",
			"parameters": [
				{
					"name": "modelType",
					"description": "The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON",
					"mandatory": false
				}
			],
			"example": "self GetCharacterBodyModel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyRenderOptions",
			"description": "Gets the body render options for this player",
			"calledOn": "player",
			"parameters": [],
			"example": "self GetCharacterBodyRenderOptions()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterBodyType",
			"description": "Gets the character body type for the player.",
			"calledOn": "player",
			"parameters": [],
			"example": "bodyIndex = self GetCharacterBodyType( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHeadModel",
			"description": "Gets the head model for this player",
			"calledOn": "player",
			"parameters": [],
			"example": "self GetCharacterHelmetModel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCharacterHelmetModel",
			"description": "Gets the helmet model for this player as selected in character customization",
			"calledOn": "player",
			"parameters": [
				{
					"name": "modelType",
					"description": "The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON",
					"mandatory": false
				}
			],
			"example": "self GetCharacterHelmetModel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetControllerUIModelValue",
			"description": "Gets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "ui model data path from controller",
					"description": "precached name string for the data which we're trying to get.",
					"mandatory": true
				}
			],
			"example": "player GetControllerUIModelValue( \"hudItems.regenDelayProgress\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentOffHand",
			"description": "Get the current offhand weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "weapon = self GetCurrentOffhand()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentWeapon",
			"description": "Gets the current player weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "currentweapon = player GetCurrentWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentWeaponAltWeapon",
			"description": "Gets the alt weapon for the players current weapon.  Returns \"none",
			"calledOn": "player",
			"parameters": [],
			"example": "currentweapon = player GetCurrentWeaponAltWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetCurrentWeaponSpinLerp",
			"description": "Gets the current weapon spin ",
			"calledOn": "player",
			"parameters": [],
			"example": "weapon_spin_lerp = self GetCurrentWeaponSpinLerp()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetEnemyDogTagModel",
			"description": "Get the enemy of the dog tag model currently associated character body",
			"calledOn": "entity",
			"parameters": [],
			"example": "friendly_model = player GetEnemyDogTagModel( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFractionMaxAmmo",
			"description": "Get fraction of the max ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to give max ammo to",
					"mandatory": true
				}
			],
			"example": "frac = players[i] GetFractionMaxAmmo( lethal_grenade )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFractionStartAmmo",
			"description": "Give fraction of start ammo to the player for the weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to give ammo to",
					"mandatory": true
				}
			],
			"example": "start = player GetFractionStartAmmo( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFriendlies",
			"description": "Returns an array of friendly players. The player called on is not included in the array.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bool",
					"description": "true, return only players that are alive, false return all players",
					"mandatory": false
				}
			],
			"example": "friends = self GetFriendlies()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFriendlyDogTagModel",
			"description": "Get the friendly of the dog tag model currently associated character body",
			"calledOn": "entity",
			"parameters": [],
			"example": "friendly_model = player GetFriendlyDogTagModel( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGunAngles",
			"description": "Get the player's gun angles",
			"calledOn": "player",
			"parameters": [],
			"example": "angles = player GetGunAngles()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHeroAbilityName",
			"description": "Returns the name of the weapon assigned to the currently selected body",
			"calledOn": "player",
			"parameters": [],
			"example": "weaponName = self GetHeroAbilityName()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHeroWeaponName",
			"description": "Returns the name of the weapon assigned to the currently selected body",
			"calledOn": "player",
			"parameters": [],
			"example": "weaponName = self GetHeroWeaponName()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInventoryHeldWeapon",
			"description": "Gets the player's inventory held weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "inventoryWeapon = player GetInventoryHeldWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetInventoryWeapon",
			"description": "Get the inventory weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "inventoryWeapon = self GetInventoryWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetIpAddress",
			"description": "Gets the ip address of the player",
			"calledOn": "player",
			"parameters": [],
			"example": "ipAddress = self GetIpAddress()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLeagueTeamID",
			"description": "Get the league team ID",
			"calledOn": "player",
			"parameters": [],
			"example": "id = player GetLeagueTeamID()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLightingState",
			"description": "Gets the current lighting state for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "ls = player GetLightingState()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLockOnLossRadius",
			"description": "Returns the lock on loss radius for the currently equipped heatseeking launcher.",
			"calledOn": "player",
			"parameters": [],
			"example": "radius = player GetLockOnRadius()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLockOnOrigin",
			"description": "gets the origin to use for the replay gun lockon on the entity",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bool",
					"description": ": true or false.",
					"mandatory": true
				}
			],
			"example": "player GetLockOnOrigin( entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLockOnRadius",
			"description": "Returns the lock on radius for the currently equipped heatseeking launcher.",
			"calledOn": "player",
			"parameters": [],
			"example": "radius = player GetLockOnRadius()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLockOnSpeed",
			"description": "Returns the lock on speed in miliseconds for the currently equipped heatseeking launcher.",
			"calledOn": "player",
			"parameters": [],
			"example": "speed = player GetLockOnSpeed()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLUIMenu",
			"description": "Returns a handle to a lui menu.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lui menu name",
					"description": "name of the menu.",
					"mandatory": true
				}
			],
			"example": "player GetLUIMenu( \"myMenu\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLUIMenuData",
			"description": "Gets the current value for the given data name.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lui menu handle",
					"description": "handle for the lui menu.",
					"mandatory": true
				},
				{
					"name": "lui menu data name",
					"description": "name of the data which had been set on the menu.",
					"mandatory": true
				}
			],
			"example": "player GetLUIMenuData( menu, \"title\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMpDialogName",
			"description": "Get the name of the mpdialog bundle of the currently associated character body",
			"calledOn": "entity",
			"parameters": [],
			"example": "mpDialogBundleName = player GetMpDialogName( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNormalizedCameraMovement",
			"description": "Get the player's camera movement normalized",
			"calledOn": "player",
			"parameters": [],
			"example": "v_stick = player GetNormalizedCameraMovement()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNormalizedMovement",
			"description": "Get the player's movement normalized",
			"calledOn": "player",
			"parameters": [],
			"example": "norm_move = self GetNormalizedMovement()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetOffHandSecondaryClass",
			"description": "Get whether the player is using a flash or smoke",
			"calledOn": "player",
			"parameters": [],
			"example": "offhand_secondary = self GetOffHandSecondaryClass()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPerks",
			"description": "Returns an array of all player perks. The array is size 0 if the player has no perks.",
			"calledOn": "player",
			"parameters": [],
			"example": "perks = player GetPerks()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerAngles",
			"description": "Get the player view angles",
			"calledOn": "player",
			"parameters": [],
			"example": "angles = player GetPlayerAngles()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerAttachmentCosmeticVariantIndexes",
			"description": "Get the player's held weapon acvi ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to get acvi from",
					"mandatory": true
				}
			],
			"example": "acvi = self GetPlayerAttachmentCosmeticVariantIndexes( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerCameraPos",
			"description": "Get the player's camera position",
			"calledOn": "player",
			"parameters": [],
			"example": "vieworg = player GetPlayerCameraPos()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerGenderType",
			"description": "Returns the gender string of the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "mode",
					"description": "SessionMode",
					"mandatory": true
				}
			],
			"example": "if ( self GetPlayerGenderType() == \"male\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerMovementState",
			"description": "Returns the player movement state for the match record.  ",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSelectedGesture",
			"description": "Get the equipped gesture ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "gestureType",
					"description": "The type of gesture to get",
					"mandatory": true
				}
			],
			"example": "gesture = player GetPlayerSelectedGesture( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerSelectedTaunt",
			"description": "Get the equipped taunt ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "tauntType",
					"description": "The type of taunt to get",
					"mandatory": true
				}
			],
			"example": "taunt = player GetPlayerSelectedTaunt( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerShowcaseWeapon",
			"description": "Get the showcase weapon of the given player",
			"calledOn": "player",
			"parameters": [],
			"example": "showcaseWeapon = player GetPlayerShowcaseWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPlayerViewHeight",
			"description": "Get the player's view height",
			"calledOn": "player",
			"parameters": [],
			"example": "height = player GetPlayerViewHeight()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getreplaygunlockonorigin",
			"description": "gets the origin to use for the replay gun lockon on the entity",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bool",
					"description": ": true or false.",
					"mandatory": true
				}
			],
			"example": "player GetLockOnOrigin( entity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSnapshotAckIndex",
			"description": "Get the snapshot acknowledgment index",
			"calledOn": "player",
			"parameters": [],
			"example": "num = self getsnapshotackindex()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSunShadowSplitDistance",
			"description": "Gets the current sun shadow split difference for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "distance = player GetSunShadowSplitDistance()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTargetScreenAngles",
			"description": "Get target screen view angles",
			"calledOn": "player",
			"parameters": [
				{
					"name": "targetpos",
					"description": "The position to get angles for.",
					"mandatory": true
				}
			],
			"example": "angles = self GetTargetScreenAngles( targetpos )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleBoostTime",
			"description": "Gets the vehicle's max boost time",
			"calledOn": "player",
			"parameters": [],
			"example": "boostTime = player GetVehicleBoostTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleBoostTimeLeft",
			"description": "Gets the vehicle's remaining boost time",
			"calledOn": "player",
			"parameters": [],
			"example": "boostTimeLeft = player GetVehicleBoostTimeLeft()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleFocusEntity",
			"description": "Gets the current vehicle focus entity for the player",
			"calledOn": "player",
			"parameters": [],
			"example": "focusEnt = player GetVehicleFocusEntity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleMinBoostTime",
			"description": "Gets the vehicle's min boost time needed in order to boost",
			"calledOn": "player",
			"parameters": [],
			"example": "minBoostTime = player GetVehicleMinBoostTime()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleOccupied",
			"description": "Returns the vehicle entity that the player occupies.  If player isn't in a vehicle then this causes an error.",
			"calledOn": "player",
			"parameters": [],
			"example": "self GetVehicleOccupied()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAcvi",
			"description": "Gets weapon options from held weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon",
					"mandatory": true
				}
			],
			"example": "primaryWeaponAcvi = self GetWeaponAcvi( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAmmoClip",
			"description": "Get the weapon's ammo count in clip",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to get ammo count from",
					"mandatory": true
				}
			],
			"example": "ammo = self GetWeaponAmmoClip( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAmmoFuel",
			"description": "Get the weapon's fuel count ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to get fuel count from",
					"mandatory": true
				}
			],
			"example": "fuel = self GetWeaponAmmoFuel( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponAmmoStock",
			"description": "Get the weapon's total ammo count ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to get ammo count from",
					"mandatory": true
				}
			],
			"example": "ammo = self GetWeaponAmmoStock( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponForWeaponRoot",
			"description": "Returns a weapon that the player is holding that has the same weapon root.  Returns undefined if the player is not holding the weapon.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to check",
					"mandatory": true
				}
			],
			"example": "weapon_with_attachments = player GetWeaponForWeaponRoot( <weapon> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponOptions",
			"description": "Get the weapon's render options ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to get options from",
					"mandatory": true
				}
			],
			"example": "weaponOptions = self GetWeaponOptions( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponsList",
			"description": "Gets an array of all weapons that the player has.  Alt-mode weapons by default are not included",
			"calledOn": "player",
			"parameters": [
				{
					"name": "include_alt_modes",
					"description": "1/True to include alt-mode weapons",
					"mandatory": false
				}
			],
			"example": "weapList = player GetWeaponsList()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWeaponsListPrimaries",
			"calledOn": "player",
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveDedicatedShadow",
			"description": "Sets the model lod bias",
			"calledOn": "entity",
			"parameters": [
				{
					"name": "entity",
					"description": "The entity to enable the dedicated shadow on",
					"mandatory": true
				}
			],
			"example": "player GiveDedicatedShadow( 8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveMaxAmmo",
			"description": "Give the weapon max ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to give ammo to",
					"mandatory": true
				}
			],
			"example": "self GiveMaxAmmo( primary )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveNextBaseWeapon",
			"description": "Give the player the next base weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "self GiveNextBaseWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveStartAmmo",
			"description": "Give the weapon initial ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to give ammo to",
					"mandatory": true
				}
			],
			"example": "self GiveStartAmmo( primary )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveWeapon",
			"description": "Give a weapon to the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to give",
					"mandatory": true
				},
				{
					"name": "options",
					"description": "The weapon options",
					"mandatory": false
				},
				{
					"name": "acvi",
					"description": "The attachment cosmetic variant index",
					"mandatory": false
				}
			],
			"example": "e_player GiveWeapon( w_spike_launcher )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GiveWeaponNextAttachment",
			"description": "Give the weapon the next attachment",
			"calledOn": "player",
			"parameters": [
				{
					"name": "attachment point",
					"description": "The attachment point name",
					"mandatory": true
				}
			],
			"example": "self giveweaponnextattachment( \"muzzle\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasAGrenadePulledBack",
			"description": "check is a client has a grenade (any type including special) currently pulled back",
			"calledOn": "player",
			"parameters": [],
			"example": "self HasAGrenadePulledBack( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasMaxPrimaryWeapons",
			"description": "Returns true if the player has maximum primary weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "if( self HasMaxPrimaryWeapons() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasPerk",
			"description": "test if player has a perk",
			"calledOn": "player",
			"parameters": [
				{
					"name": "perk name",
					"description": "the perk to check",
					"mandatory": true
				}
			],
			"example": "player HasPerk( \"specialty_gpsjammer\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasRiotShield",
			"description": "Return true if player has a riot shield in their inventory.",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( player HasRiotShield() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HasWeapon",
			"description": "Returns true if the player has the given weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to check",
					"mandatory": true
				},
				{
					"name": "ignore_attachments",
					"description": "Only check the root weapon, ignore all the attachments.",
					"mandatory": false
				}
			],
			"example": "if( e_player HasWeapon( w_spike_launcher, true ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "HideViewModel",
			"description": "Hide the player's current view model.",
			"calledOn": "player",
			"parameters": [],
			"example": "player HideViewModel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "InitialWeaponRaise",
			"description": "Setup weaponstate to force first raise animation",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon name",
					"description": "The weapon to try first raise anim with",
					"mandatory": true
				}
			],
			"example": "self InitialWeaponRaise( \"ak47\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "InventoryButtonPressed",
			"description": "Check if the player is pressing the inventory button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self InventoryButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsCarryingTurret",
			"description": "Check if player is carrying turret or not.",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsCarryingTurret()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsChargeShotPending",
			"description": "Returns true if player has a charge shot pending with a charge shot weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "if( self IsChargeShotPending() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDroppingWeapon",
			"description": "Returns true if the player is currently dropping their weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsDroppingWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFiring",
			"description": "Returns true if the player is currently meleeing",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsFiring()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGrappling",
			"description": "Returns true if the player is currently grappling",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsGrappling()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsHost",
			"description": "Returns true if the player is the host",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsHost()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsHostForBots",
			"description": "Returns true if the passed in entity is the host for bots",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsHostForBots()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInMoveMode",
			"description": "Returns true if the player is in either of the given move modes",
			"calledOn": "player",
			"parameters": [
				{
					"name": "move_mode_1",
					"description": "The move mode to check",
					"mandatory": true
				},
				{
					"name": "move_mode_2",
					"description": "The move mode to check",
					"mandatory": false
				}
			],
			"example": "if ( player IsInMoveMode( \"ufo\", \"noclip\" ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInVehicle",
			"description": "Returns whether or not this player is currently occupying a vehicle.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsInVehicle()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLocalToHost",
			"description": "Returns true if the player is on the same physical machine as the host",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsLocalToHost()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsLookingAt",
			"description": "Returns true if the player is looking at entity",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": "The entity to check",
					"mandatory": true
				}
			],
			"example": "if( isplayer( self.enemy ) && self.enemy islookingat( self ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsMeleeing",
			"description": "Returns true if the player is currently meleeing",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsMeleeing()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsPlayerOnSameMachine",
			"description": "Returns whether or not this player is on the same machine as the other player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "player",
					"description": "The player to test against",
					"mandatory": true
				}
			],
			"example": "if ( self IsPlayerOnSameMachine( player ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsReloading",
			"description": "Returns true if the player is currently reloading",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsReloading()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsRemoteControlling",
			"description": "Returns whether or not this player is currently occupying a remote controlled entity.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsRemoteControlling()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSwitchingWeapons",
			"description": "Returns true if the player is currently switching weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsSwitchingWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTalking",
			"description": "Returns true if the player is talking via voice chat",
			"calledOn": "player",
			"parameters": [],
			"example": "if( player IsTalking() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsThrowingGrenade",
			"description": "Returns true if the player is currently throwing a grenade",
			"calledOn": "player",
			"parameters": [],
			"example": "player IsThrowingGrenade()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsUsingOffHand",
			"description": "Returns true if player is using offhand weapon",
			"calledOn": "player",
			"parameters": [],
			"example": "if( self IsUsingOffHand() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWeaponOverheating",
			"description": "Is the players Weapon Overheating?",
			"calledOn": "player",
			"parameters": [
				{
					"name": "get heatval",
					"description": "If positive pass back the heatval of the weapon (0 to 100).",
					"mandatory": false
				},
				{
					"name": "weapon",
					"description": "If present check this specific weapon otherwise check the player's current weapon.",
					"mandatory": false
				}
			],
			"example": "self IsWeaponOverheating()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWeaponViewOnlyLinked",
			"description": "Returns whether or not this player is linked to an enity with weapon view only linking.",
			"calledOn": "player",
			"parameters": [],
			"example": "self IsWeaponViewOnlyLinked()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "JumpButtonPressed",
			"description": "Check if the player is pressing the 'jump' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self JumpButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkGuidedMissileCamera",
			"description": "set player eflags for the guided missile",
			"calledOn": "player",
			"parameters": [],
			"example": "player LinkGuidedMissileCamera()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "LinkToMissile",
			"description": "Links a player camera and controls to a missile",
			"calledOn": "player",
			"parameters": [
				{},
				{
					"name": "boost_enabled",
					"description": ": If true, the player can trigger missile boost",
					"mandatory": false
				},
				{
					"name": "brake_enabled",
					"description": ": If true, the player can trigger missile brake",
					"mandatory": false
				}
			],
			"example": "player LinkToMissile( rocket, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MeleeButtonPressed",
			"description": "Check if the player is pressing the melee button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self MeleeButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MurderLine",
			"description": "Get all the enemy players on the line between given points and murder them to death",
			"calledOn": "player",
			"parameters": [
				{
					"name": "from",
					"description": "The from position",
					"mandatory": true
				},
				{
					"name": "to",
					"description": "The to position",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon used",
					"mandatory": true
				}
			],
			"example": "player MurderLine( origin, endpos, \"kniferang_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NextPlayerRenderOption",
			"description": "Set the next player render option",
			"calledOn": "player",
			"parameters": [
				{
					"name": "optionName",
					"description": "The tag of the next option",
					"mandatory": true
				},
				{
					"name": "forward",
					"description": "The delta",
					"mandatory": true
				}
			],
			"example": "level.dev_cac_player NextPlayerRenderOption( tag, forward )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OffhandSpecialButtonPressed",
			"description": "Check if the player is pressing the gadget button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self OffhandSpecialButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OpenLUIMenu",
			"description": "Opens a lui menu( has to be precahced ) and returns a handle to it.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lui menu name",
					"description": "name of the menu.",
					"mandatory": true
				},
				{
					"name": "persistent",
					"description": "the menu will remain open even if the player dies.",
					"mandatory": false
				}
			],
			"example": "player OpenLUIMenu( \"myMenu\", true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OpenMenu",
			"description": "Open the menu with the given menu index",
			"calledOn": "player",
			"parameters": [
				{
					"name": "menu index",
					"description": "The menu index",
					"mandatory": true
				}
			],
			"example": "self openMenu( game[ \"menu_changeclass\" ] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "OpenMenuNoMouse",
			"description": "Open the menu with the given menu index",
			"calledOn": "player",
			"parameters": [
				{
					"name": "menu index",
					"description": "The menu index",
					"mandatory": true
				}
			],
			"example": "self OpenMenuNoMouse( game[ \"menu_changeclass\" ] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PickupAmmoEvent",
			"description": "Lets the client know a weapon was picked up",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self PickupAmmoEvent( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PickupWeaponEvent",
			"description": "Lets the client know a weapon was picked up",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": true
				}
			],
			"example": "self PickupWeaponEvent( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PingPlayer",
			"description": "Flashes a player on their teammate's compasses",
			"calledOn": "player",
			"parameters": [],
			"example": "self PingPlayer()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayBombDefuse",
			"description": "Play the players bomb defuse animation",
			"calledOn": "player",
			"parameters": [],
			"example": "self PlayBombDefuse()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayBombPlant",
			"description": "Play the players bomb plant animation",
			"calledOn": "player",
			"parameters": [],
			"example": "self PlayBombPlant()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayClientAirstrike",
			"description": "Plays the client sided part of the airstrike/bombrun",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The position of airstrike",
					"mandatory": true
				},
				{
					"name": "yaw",
					"description": "The yaw",
					"mandatory": true
				},
				{
					"name": "teamFaction",
					"description": "The team faction",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team",
					"mandatory": true
				},
				{
					"name": "owner",
					"description": "The owner of airstike",
					"mandatory": true
				},
				{
					"name": "exittype",
					"description": "The exit type",
					"mandatory": true
				},
				{
					"name": "height",
					"description": "The height",
					"mandatory": true
				}
			],
			"example": "PlayClientAirstrike( pos, yaw, \"marines\", \"axis\", owner, \"left\", height )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayClientNapalm",
			"description": "Plays the client sided part of the Napalm",
			"calledOn": null,
			"parameters": [
				{
					"name": "position",
					"description": "The position of Napalm",
					"mandatory": true
				},
				{
					"name": "yaw",
					"description": "The yaw",
					"mandatory": true
				},
				{
					"name": "teamFaction",
					"description": "The team faction",
					"mandatory": true
				},
				{
					"name": "team",
					"description": "The team",
					"mandatory": true
				},
				{
					"name": "owner",
					"description": "The owner of Napalm",
					"mandatory": true
				},
				{
					"name": "exittype",
					"description": "The exit type",
					"mandatory": true
				},
				{
					"name": "height",
					"description": "The height",
					"mandatory": true
				}
			],
			"example": "PlayClientNapalm( startPos, plane.yaw, \"vietcong\", \"axis\", plane.owner, \"left\", height )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerADS",
			"description": "Gets the player weapon position fraction",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self PlayerADS() > 0.3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayerKnockback",
			"description": "Turn knockback on and off for a player",
			"calledOn": "actor",
			"parameters": [
				{
					"name": "true/false",
					"description": "if true, client affected by knockback",
					"mandatory": true
				}
			],
			"example": "self PlayerKnockback( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayHitMarker",
			"description": "Plays a hit marker event",
			"calledOn": "player",
			"parameters": [
				{
					"name": "sound name",
					"description": "The name of the sound or hash",
					"mandatory": true
				},
				{
					"name": "damage state",
					"description": "How damaged the victim is",
					"mandatory": false
				},
				{
					"name": "perk feedback",
					"description": "If the victim had any perks active that modified the hit marker",
					"mandatory": false
				},
				{
					"name": "is dead",
					"description": "If the victim has died from this hit marker and needs a red flash",
					"mandatory": false
				}
			],
			"example": "self PlayHitMarker( \"evt_squad_activate\", 3, \"flakjacket\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PlayLocalSound",
			"description": "Plays a sound locally",
			"calledOn": "player",
			"parameters": [
				{
					"name": "sound name",
					"description": "The name of the sound or hash",
					"mandatory": true
				}
			],
			"example": "self playlocalsound( \"evt_squad_activate\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PrimaryButtonPressedLocal",
			"description": "Check if the local player is pressing the primary button (BUTTON_A)",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self PrimaryButtonPressedLocal() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PrimeMovie",
			"description": "Starts priming the cinematic movie to be played.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "moviename",
					"description": "movie name",
					"mandatory": true
				}
			],
			"example": "self PrimeMovie( \"mymovie\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReloadButtonPressed",
			"description": "Check if the player is pressing the 'usereload' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self reloadButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReloadWeaponAmmo",
			"description": "Set the weapon's ammoclip from the ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to be reloaded",
					"mandatory": true
				}
			],
			"example": "self ReloadWeaponAmmo( <weapon> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoteControlTurret",
			"description": "Remote control into a turret",
			"calledOn": "player",
			"parameters": [
				{
					"name": "turret",
					"description": "the remote controlled turret.",
					"mandatory": true
				}
			],
			"example": "player RemoteControlTurret( turret )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RemoteControlTurretOff",
			"description": "Stops remote controlling a turret",
			"calledOn": "player",
			"parameters": [
				{
					"name": "turret",
					"description": "the remote controlled turret.",
					"mandatory": true
				}
			],
			"example": "player RemoteControlTurretOff( turret )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetAnimations",
			"description": "Reset player animations after a body type change",
			"calledOn": "player",
			"parameters": [],
			"example": "self ResetAnimations())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetCharacterCustomization",
			"description": "Resets all of the character customization to what is in the player stats",
			"calledOn": "player",
			"parameters": [],
			"example": "self ResetCharacterCustomization()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetFlashBack",
			"description": "Resets the players flashback history",
			"calledOn": "player",
			"parameters": [],
			"example": "self resetflashback()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetSpreadOverride",
			"description": "Reset the player's aim spread to 255",
			"calledOn": "player",
			"parameters": [],
			"example": "self ResetSpreadOverride()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Revive",
			"description": "Revive the player",
			"calledOn": "player",
			"parameters": [],
			"example": "self Revive())",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RevivePlayer",
			"description": "Callback from script to get player out of last stand, increases health, removes damage timer, should clear screen of damageFX",
			"calledOn": "client",
			"parameters": [],
			"example": "self RevivePlayer()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SayAll",
			"description": "Write a client chat message from this client to everybody",
			"calledOn": "player",
			"parameters": [
				{
					"name": "message",
					"description": "A localizable message to send to all players",
					"mandatory": true
				}
			],
			"example": "self SayAll( saytext )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SayTeam",
			"description": "Write a client chat message from this client to everybody on their team",
			"calledOn": "player",
			"parameters": [
				{
					"name": "message",
					"description": "A localizable message to send to all players on the player's team.",
					"mandatory": true
				}
			],
			"example": "self SayTeam( sayText )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SecondaryButtonPressedLocal",
			"description": "Check if the local player is pressing the secondary button (BUTTON_B)",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self SecondaryButtonPressedLocal() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SecondaryOffhandButtonPressed",
			"description": "Check if the player is pressing the secondary offhand button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self SecondaryOffhandButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetActionSlot",
			"description": "Sets action slot for the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "slot",
					"description": "The action slot",
					"mandatory": true
				},
				{
					"name": "action slot type",
					"description": "The type of slot. can be \"weapon\"/\"altMode\"/\"\"",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "The weapon to set",
					"mandatory": false
				}
			],
			"example": "self SetActionSlot( 4, \"weapon\", level.DEAD_CONTROL_WEAPON )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetArenaPoints",
			"description": "Sets the player's arena points",
			"calledOn": "player",
			"parameters": [
				{
					"name": "point",
					"description": "points",
					"mandatory": true
				}
			],
			"example": "player SetArenaPoints( 19 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBlockWeaponPickup",
			"description": "Blocks the player from picking up other weapons while using this weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to set block for",
					"mandatory": true
				},
				{
					"name": "enabled",
					"description": "True if weapon pickup should be blocked",
					"mandatory": true
				}
			],
			"example": "self setBlockWeaponPickup( killstreakWeapon, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCarryingObject",
			"description": "Enable or disable the player carrying object flag. Disables doublejump and juke",
			"calledOn": "player",
			"parameters": [
				{
					"name": "onoff",
					"description": "True to enable, false otherwise",
					"mandatory": true
				}
			],
			"example": "self SetCarryingObject( true );  // disables doublejump and juke",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCharacterBodyStyle",
			"description": "Sets the character body style for the current body type.  Resets all colors for the body style to default.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "character body type index",
					"description": "The index of the character body type",
					"mandatory": true
				}
			],
			"example": "self SetCharacterBodyStyle( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCharacterBodyType",
			"description": "Sets the character body type for the player.  Resets all other customization to default for the new body type.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "character body type index",
					"description": "The index of the character body type",
					"mandatory": true
				},
				{
					"name": "character head type index",
					"description": "The index of the character head type",
					"mandatory": false
				}
			],
			"example": "self SetCharacterBodyType( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCharacterHelmetStyle",
			"description": "Sets the character body style for the current helmet type.  Resets all colors for the helmet style to default.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "character body type index",
					"description": "The index of the character body type",
					"mandatory": true
				}
			],
			"example": "self SetCharacterHelmetStyle( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientCGObjectiveText",
			"description": "Sets the objective text only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "text",
					"description": "The text to set",
					"mandatory": true
				}
			],
			"example": "self SetClientCGObjectiveText( util::getObjectiveScoreText( self.pers[\"team\"] ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientCompass",
			"description": "Sets compass dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "self SetClientCompass( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientDrawTalk",
			"description": "Sets cg_drawTalk dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "self SetClientDrawTalk( 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientFocalLength",
			"description": "Sets cg_focalLength dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The focal length value to set (float)",
					"mandatory": true
				}
			],
			"example": "self SetClientFocalLength( 23.3622 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientHUDHardcore",
			"description": "Sets ui_hud_hardcore dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "self SetClientHUDHardcore( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientMiniScoreboardHide",
			"description": "Sets miniscoreboardhide dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "enable",
					"description": "True/1 to hide, false/0 otherwise",
					"mandatory": true
				}
			],
			"example": "players[i] SetClientMiniScoreboardHide( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientNumLives",
			"description": "Sets scr_numLives dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "numLives",
					"description": "The numlives to set",
					"mandatory": true
				}
			],
			"example": "self SetClientNumLives( level.numLives )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientPlayerPushAmount",
			"description": "Sets playerPushAmount dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "amount",
					"description": "The push amount",
					"mandatory": true
				}
			],
			"example": "self SetClientPlayerPushAmount( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientPlayerSprintTime",
			"description": "Sets player_sprintTime dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "time",
					"description": "The spring time",
					"mandatory": true
				}
			],
			"example": "self SetClientPlayerSprintTime( level.playerSprintTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientScriptMainMenu",
			"description": "Sets g_scriptMainMenu dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "self SetClientScriptMainMenu( game[\"menu_class\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientThirdPerson",
			"description": "Set the client to be third person",
			"calledOn": "player",
			"parameters": [
				{
					"name": "onoff",
					"description": "1 to set, 0 otherwise",
					"mandatory": true
				}
			],
			"example": "self SetClientThirdPerson( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientThirdPersonAngle",
			"description": "Sets cg_thirdPerson dvar only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "angle",
					"description": "The angle to set",
					"mandatory": true
				}
			],
			"example": "self SetClientThirdPersonAngle( 354 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClientUIVisibilityFlag",
			"description": "Sets a HUD visibility flag only on this client",
			"calledOn": "player",
			"parameters": [
				{
					"name": "flagName",
					"description": "The name of the flag",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "e_player SetClientUIVisibilityFlag( \"hud_visible\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetControllerUIModelValue",
			"description": "Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "ui model data path from controller",
					"description": "precached name string for the data which we're trying to set.",
					"mandatory": true
				},
				{
					"name": "ui model value",
					"description": "value for the data which we're trying to set on the controller.",
					"mandatory": true
				}
			],
			"example": "player SetControllerUIModelValue( \"hudItems.regenDelayProgress\", 0.2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCurrentSpectatorClient",
			"description": "Set the given client as a spectator",
			"calledOn": "player",
			"parameters": [
				{
					"name": "client",
					"description": "The client to set spectator",
					"mandatory": true
				}
			],
			"example": "self SetCurrentSpectatorClient( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCurrentWeaponSpinLerp",
			"description": "Set the current weapon's spin ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "spin",
					"description": "The spin value",
					"mandatory": true
				}
			],
			"example": "self SetCurrentWeaponSpinLerp( 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDisabledTargetHint",
			"description": "Set target not selected hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetDisabledTargetHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetElectrifiedState",
			"description": "Sets the player into the electrified state for 3rd person anim purposes. Different from SetElectrified() which plays the postfx",
			"calledOn": "player",
			"parameters": [
				{
					"name": "electrified",
					"description": ": bool whether the player should be in this state.",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEnterTime",
			"description": "Sets the player's session enter time",
			"calledOn": "player",
			"parameters": [
				{
					"name": "time",
					"description": "The time to set",
					"mandatory": true
				}
			],
			"example": "self setEnterTime( getTime() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetEverHadWeaponAll",
			"description": "Set the EverHadAllPlayerHeldWeapons flag of the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "flag",
					"description": "True to set the flag",
					"mandatory": true
				}
			],
			"example": "self SetEverHadWeaponAll( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHighlighted",
			"description": "Highlight the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "onoff",
					"description": "True to highlight, false otherwise",
					"mandatory": true
				}
			],
			"example": "self SetHighlighted( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInventoryHeldWeapon",
			"description": "Sets the player's inventoryHeldWeapon.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The held weapon to be set as inventoryHeldWeapon. Use undefined to clear the inventoryHeldWeapon.",
					"mandatory": true
				}
			],
			"example": "player SetInventoryHeldWeapon( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetInventoryWeapon",
			"description": "Set the inventory weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to set",
					"mandatory": true
				}
			],
			"example": "self SetInventoryWeapon( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLowReady",
			"description": "set the player into low ready weapon state. ",
			"calledOn": null,
			"parameters": [
				{
					"name": "enable",
					"description": "true to set this state",
					"mandatory": true
				}
			],
			"example": "self SetLowReady(true)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLUIMenuData",
			"description": "Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "lui menu handle",
					"description": "handle to the lui menu opened.",
					"mandatory": true
				},
				{
					"name": "lui menu data name",
					"description": "precached name string for the data which we're trying to set.",
					"mandatory": true
				},
				{
					"name": "lui menu data value",
					"description": "value for the data which we're trying to set on the menu.",
					"mandatory": true
				}
			],
			"example": "player SetLUIMenuData( menu, \"title\", \"Some Title\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetModelLodBias",
			"description": "Sets the model lod bias",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bias",
					"description": "bias. Setting of 0 reverts to the model lod bias.",
					"mandatory": true
				}
			],
			"example": "player SetModelLodBias( 8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNoLOSOnTargetsHint",
			"description": "Set target not selected hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetNoLOSOnTargetsHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNoTargetsHint",
			"description": "Set target not selected hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetNoTargetsHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "setOffhandPrimaryClass",
			"description": "Set whether the player is using a grenade or gear.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "name",
					"description": "the weapon name",
					"mandatory": true
				}
			],
			"example": "player setOffhandPrimaryClass( \"claymore_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetOffhandSecondaryClass",
			"description": "Set whether the player is using a flash or smoke grenade.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "name",
					"description": "the weapon name",
					"mandatory": true
				}
			],
			"example": "player SetOffhandSecondaryClass( \"concussion_grenade_mp\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetOffhandVisible",
			"description": "Enable or disable visibility of the offhand weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "onoff",
					"description": "True/1 to enable, false otherwise",
					"mandatory": true
				}
			],
			"example": "self SetOffhandVisible( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetOrigin",
			"description": "Set the player's origin",
			"calledOn": "player",
			"parameters": [
				{
					"name": "origin",
					"description": "The origin to set",
					"mandatory": true
				}
			],
			"example": "player SetOrigin( v_origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetParagonIconId",
			"description": "Sets the player's paragon icon id",
			"calledOn": "player",
			"parameters": [
				{
					"name": "paragon icon id",
					"description": "the paragon rank id",
					"mandatory": true
				}
			],
			"example": "player SetParagonIconId( 1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetParagonRank",
			"description": "Sets the player's paragon rank",
			"calledOn": "player",
			"parameters": [
				{
					"name": "paragon rank id",
					"description": "the paragon rank id",
					"mandatory": true
				}
			],
			"example": "player SetParagonRank( 1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPerk",
			"description": "give the specified perk",
			"calledOn": "player",
			"parameters": [
				{
					"name": "perk name",
					"description": "the perk to give",
					"mandatory": true
				}
			],
			"example": "player SetPerk( \"specialty_gpsjammer\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlacementHint",
			"description": "Sets the placement hint string that will be displayed for this player.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "onoff",
					"description": "true if the hint should say that the weapon can be placed, false if not",
					"mandatory": true
				}
			],
			"example": "player SetPlacementHint( turret.canBePlaced )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerAngles",
			"description": "Set the player's view angles",
			"calledOn": "player",
			"parameters": [
				{
					"name": "angles",
					"description": "The view angles to set",
					"mandatory": true
				}
			],
			"example": "player SetPlayerAngles( v_angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerRenderOptions",
			"description": "Sets the player render options",
			"calledOn": "player",
			"parameters": [
				{
					"name": "options",
					"description": "The player render options",
					"mandatory": true
				}
			],
			"example": "self SetPlayerRenderOptions( playerRenderOptions );\t",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRank",
			"description": "Sets the player's rank and prestige level",
			"calledOn": "player",
			"parameters": [
				{
					"name": "rank id",
					"description": "the rank id",
					"mandatory": true
				},
				{
					"name": "prestige level",
					"description": "The prestige level",
					"mandatory": false
				}
			],
			"example": "player SetRank( 1, 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRiotshieldFailHint",
			"description": "Set riot shield fail hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetRiotshieldFailHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpawnWeapon",
			"description": "Set the weapon that this player will spawn with",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon name",
					"description": "The name of the weapon to spawn with",
					"mandatory": true
				}
			],
			"example": "self SetSpawnWeapon( \"ak47\" )during prematch period or grace period in mp)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpreadOverride",
			"description": "Set the player's aim spread ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set",
					"mandatory": true
				}
			],
			"example": "self SetSpreadOverride( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSprintCooldown",
			"description": "Set the player's sprint cooldown duration",
			"calledOn": "player",
			"parameters": [
				{
					"name": "duration",
					"description": "The duration to set",
					"mandatory": true
				}
			],
			"example": "self SetSprintCooldown( 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSprintDuration",
			"description": "Set the player's sprint duration",
			"calledOn": "player",
			"parameters": [
				{
					"name": "duration",
					"description": "The duration to set",
					"mandatory": true
				}
			],
			"example": "self SetSprintDuration( 4 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSunShadowSplitDistance",
			"description": "Sets the sun shadow split distance for the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "distance",
					"description": "split distance. Setting of 0 reverts to the default split distance.",
					"mandatory": true
				}
			],
			"example": "player SetSunShadowSplitDistance( 200 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTacticalWheel",
			"description": "Sets whether this player will be able to use the cybercom tactical wheel or not",
			"calledOn": "player",
			"parameters": [
				{
					"name": "enabled",
					"description": "turn on or off",
					"mandatory": true
				}
			],
			"example": "player SetTacticalWheel( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetAlreadyInUseHint",
			"description": "Set  target already in use failure hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetTargetAlreadyInUseHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetAlreadyTargetedHint",
			"description": "Set target already being targeted hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetTargetAlreadyTargetedHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetedEntityEndTime",
			"description": "Set targeted entity end time, for use on the client side in the UI. ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "endtime",
					"description": "The end time of the targeted entity",
					"mandatory": true
				}
			],
			"example": "self SetTargetedEntityEndTime( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetedMissilesRemaining",
			"description": "Set targeted entity missiles remaining, for use on the client side in the UI. ",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "missilesRemaining",
					"description": "The amount of missiles remaining to destroy the target",
					"mandatory": true
				}
			],
			"example": "self SetTargetedMissilesRemaining( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetingAbortedHint",
			"description": "Set targeting aborted hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetDisabledTargetHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetOORHint",
			"description": "Set out of range failure hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetTargetOORHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetWrongTypeHint",
			"description": "Set target validity failure hint",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": ": Weapon to use for the event",
					"mandatory": false
				}
			],
			"example": "self SetTargetWrongTypeHint()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleDamageMeter",
			"description": "Sets the vehicle damage meter",
			"calledOn": "player",
			"parameters": [
				{
					"name": "damage",
					"description": "the amount of damage normalized 0..1",
					"mandatory": true
				}
			],
			"example": "player SetRefEndTime( killstreaEndTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleDrivableDuration",
			"description": "Sets the drivable duration for the players vehicle (intended for use with client side display purposes)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "duration",
					"description": "the drivable duration in milliseconds",
					"mandatory": true
				}
			],
			"example": "player SetVehicleDrivableDuration( killstreakDuration )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleDrivableEndTime",
			"description": "Sets the vehicle drivable end time.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "end time",
					"description": "the drivable end time in milliseconds",
					"mandatory": true
				}
			],
			"example": "player SetVehicleDrivableEndTime( killstreakEndTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleFocusEntity",
			"description": "Sets the focus entity for a player driven vehicle (currently only supported by helicopters).  This will attempt to make the vehicle orient towards the focus target.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "focus entity",
					"description": "The entity to focus on",
					"mandatory": true
				}
			],
			"example": "player SetVehicleFocusEntity( focusEntity )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleLockedOnByEnt",
			"description": "Sets the vehicle locked on by entity",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": "an entity that acquired a missile lock on the player's vehicle",
					"mandatory": true
				}
			],
			"example": "player SetVehicleLockedOnByEnt( mostDangerousEnemyWithLockOn )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleWeaponWaitDuration",
			"description": "Sets the weapon wait duration for the players vehicle (intended for use with client side display purposes)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "duration",
					"description": "the weapon reload (or recharge) duration in milliseconds",
					"mandatory": true
				}
			],
			"example": "player SetVehicleWeaponWaitDuration( reloadDuration )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleWeaponWaitEndTime",
			"description": "Sets the vehicle weapon wait end time.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "end time",
					"description": "the weapon wait end time in milliseconds",
					"mandatory": true
				}
			],
			"example": "player SetVehicleWeaponWaitEndTime( weaponReloadEndTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVelocity",
			"description": "Set the velocity of the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "velocity",
					"description": "The velocity to set",
					"mandatory": true
				}
			],
			"example": "self setvelocity(force)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetViewClamp",
			"description": "Set the view clamp for the player, only works during animscripted for now.  Ranges are relative to tag_camera.  Left, Right, Top, Bottom",
			"calledOn": "player",
			"parameters": [],
			"example": "player SetViewClamp( 50, 50, 30, 30 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponAmmoClip",
			"description": "Set the weapon's ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon",
					"mandatory": true
				},
				{
					"name": "ammo",
					"description": "The ammo count",
					"mandatory": true
				}
			],
			"example": "self SetWeaponAmmoClip( weapon, weapon.clipSize )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponAmmoFuel",
			"description": "Set the weapon ammo fuel",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon",
					"mandatory": true
				},
				{
					"name": "fuel",
					"description": "The ammo fuel amount",
					"mandatory": true
				}
			],
			"example": "self SetWeaponAmmoFuel( weapon, weapondata[\"fuel\"] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponAmmoStock",
			"description": "Set the weapon's ammo",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon",
					"mandatory": true
				},
				{
					"name": "ammo",
					"description": "The new ammo count",
					"mandatory": true
				}
			],
			"example": "reviver SetWeaponAmmoStock( level.weaponReviveTool, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponFriendlyHacking",
			"description": "Set the weapon lockon completion percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "isFriendlyHacking",
					"description": "Set to true if a friendly is hacking the target",
					"mandatory": true
				}
			],
			"example": "self SetWeaponFriendlyTargetLocked( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponFriendlyTargeting",
			"description": "Set the weapon lockon completion percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "isFriendlyTargeting",
					"description": "Set to true if a friendly is targetting",
					"mandatory": true
				}
			],
			"example": "self SetWeaponFriendlyTargeting( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponFriendlyTargetLocked",
			"description": "Set the weapon lockon completion percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "isFriendlyTargetLocked",
					"description": "Set to true if a friendly is target locked",
					"mandatory": true
				}
			],
			"example": "self SetWeaponFriendlyTargetLocked( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponHackPercent",
			"description": "Set the weapon hack completion percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "heat",
					"description": "The heat percent to set",
					"mandatory": true
				}
			],
			"example": "self SetWeaponHackPercent( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponHeatPercent",
			"description": "Set the weapon heat percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "heat",
					"description": "The heat percent to set",
					"mandatory": true
				}
			],
			"example": "self SetWeaponHeatPercent( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponLockOnPercent",
			"description": "Set the weapon lockon completion percentage",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon (player should have this weapon)",
					"mandatory": true
				},
				{
					"name": "heat",
					"description": "The heat percent to set",
					"mandatory": true
				}
			],
			"example": "self SetWeaponLockOnPercent( weapon, 0.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWeaponOverheating",
			"description": "Set the players Weapon Overheating value",
			"calledOn": "player",
			"parameters": [
				{
					"name": "overheat",
					"description": "Whether the weapon is overheating.",
					"mandatory": true
				},
				{
					"name": "heatval",
					"description": "The new heatval of the weapon (0 to 100).",
					"mandatory": true
				},
				{
					"name": "weapon",
					"description": "If present set this specific weapon otherwise set the player's current weapon.",
					"mandatory": false
				}
			],
			"example": "self SetWeaponOverheating( weapondata[\"overheat\"], weapondata[\"heat\"], weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ShowViewModel",
			"description": "Show the player's current view model.",
			"calledOn": "player",
			"parameters": [],
			"example": "player ShowViewModel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SortHeldWeapons",
			"description": "Sort the playerState heldWeapons to remove empty spaces",
			"calledOn": "player",
			"parameters": [],
			"example": "e_player SortHeldWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SpawnSpectator",
			"description": "Spawns the player, does not send any notifies",
			"calledOn": "player",
			"parameters": [
				{
					"name": "origin",
					"description": "origin to spawn",
					"mandatory": true
				},
				{
					"name": "angles",
					"description": "angles to spawn",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SprintButtonPressed",
			"description": "Check if the player is pressing the 'sprint' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self SprintButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SprintUpRequired",
			"description": "Force the player to release the sprint button before sprinting.",
			"calledOn": "player",
			"parameters": [],
			"example": "self SprintUpRequired()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StanceButtonPressed",
			"description": "Check if the player is pressing the 'stance' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self StanceButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartCameraTween",
			"description": "Start a camera tween, call this right before a camera pop to do a blend.",
			"calledOn": null,
			"parameters": [
				{
					"name": "time",
					"description": "How long to do the blend.\"",
					"mandatory": true
				}
			],
			"example": "player StartCameraTween( 0.5 );",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartRevive",
			"description": "Starts the revive sequence on a player. <reviver> is the one administering aid to the player this is called on.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "reviver",
					"description": "the player reviving the player this is called on",
					"mandatory": true
				}
			],
			"example": "playerInLastStand StartRevive( rescuer )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopCarryTurret",
			"description": "UnLinks the auto turret from the player and sets it on the ground.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "turret",
					"description": "turret entity",
					"mandatory": true
				},
				{
					"name": "origin",
					"description": "The new origin of turret",
					"mandatory": false
				},
				{
					"name": "angles",
					"description": "The new angles of turret",
					"mandatory": false
				}
			],
			"example": "player StopCarryTurret( turret, origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopLocalSound",
			"description": "Stops the local sound",
			"calledOn": "player",
			"parameters": [
				{
					"name": "sound name",
					"description": "The name of the sound",
					"mandatory": true
				}
			],
			"example": "targetent StopLocalSound( level.missileDroneSoundStart )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopRevive",
			"description": "Stops the revive behavior on a player when the revive did not complete. <reviver> is the one administering aid to the player this is called on.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "reviver",
					"description": "the player reviving the player this is called on",
					"mandatory": true
				}
			],
			"example": "playerInLastStand StopRevive( rescuer )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Suicide",
			"description": "Kills the player immediately as a suicide",
			"calledOn": "player",
			"parameters": [],
			"example": "self suicide()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchToOffHand",
			"description": "Switch to the offhand weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "Weapon to switch to",
					"mandatory": true
				}
			],
			"example": "self SwitchToOffhand( primaryOffhand )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchToWeapon",
			"description": "Switch to a different weapon or cycle weapons if no weapon is given",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon object",
					"description": "The weapon to switch to",
					"mandatory": false
				}
			],
			"example": "level.player SwitchToWeapon( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchToWeaponImmediate",
			"description": "Switch to a different weapon or cycle weapons if no weapon is given without playing the dropping animation for current weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon object",
					"description": "The weapon to switch to",
					"mandatory": false
				}
			],
			"example": "level.player SwitchToWeaponImmediate( weapon )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TakeAllWeapons",
			"description": "Makes the player take all weapons",
			"calledOn": "player",
			"parameters": [],
			"example": "player TakeAllWeapons()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TakeWeapon",
			"description": "Take the weapon",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon",
					"description": "The weapon to take",
					"mandatory": true
				},
				{
					"name": "ignore_attachments",
					"description": "Only check the root weapon, ignore all the attachments.",
					"mandatory": false
				}
			],
			"example": "e_player TakeWeapon( w_spike_launcher )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ThrowButtonPressed",
			"description": "Check if the player is pressing the 'throw' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self ThrowButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TurnedHuman",
			"description": "Called when client is turned back to human",
			"calledOn": "client",
			"parameters": [],
			"example": "self TurnedHuman()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UndoLastStand",
			"description": "Undo the last stand for the client",
			"calledOn": "client",
			"parameters": [],
			"example": "self UndoLastStand()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnlinkFromMissile",
			"description": "Unlinks a player camera from a missile",
			"calledOn": "player",
			"parameters": [],
			"example": "player UnlinkFromMissile()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnlinkGuidedMissileCamera",
			"description": "clear player eflags for the guided missile",
			"calledOn": "player",
			"parameters": [],
			"example": "player UnlinkGuidedMissileCamera()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UnSetPerk",
			"description": "takes the specified perk from the player",
			"calledOn": "player",
			"parameters": [
				{
					"name": "perk name",
					"description": "the perk to unset",
					"mandatory": true
				}
			],
			"example": "player UnSetPerk( \"specialty_gpsjammer\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UpdateWeaponOptions",
			"description": "Update weapon options for a weapon that the player has",
			"calledOn": "player",
			"parameters": [
				{
					"name": "weapon name",
					"description": "The weapon name to give to the player",
					"mandatory": true
				},
				{
					"name": "weapon options",
					"description": "options value computed using calcweaponoptions call",
					"mandatory": false
				}
			],
			"example": "player UpdateWeaponOptions( \"m1garand\", player calcWeaponOptions() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseButtonPressed",
			"description": "Check if the player is pressing the use button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self UseButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VehicleMoveUpButtonPressed",
			"description": "Check if the player is pressing the 'stance' button.",
			"calledOn": "player",
			"parameters": [],
			"example": "while( self StanceButtonPressed() )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockCount",
			"description": "returns the number of active lock objects (i.e. those with at least lock started or lock set active)",
			"calledOn": "player",
			"parameters": [],
			"example": "player WeaponLockCount()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockDetect",
			"description": "Sets the tartget as detected.  Will clear any existing hard lock.  Use WeaponLockStart() to start lock.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": ": An entity.",
					"mandatory": true
				},
				{
					"name": "slot",
					"description": ":  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)",
					"mandatory": false
				}
			],
			"example": "player WeaponLockDetect( enemyGuy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockFinalize",
			"description": "Locks player's weapon onto an entity.  Implies WeaponLockStart(), so this may be called to jump to a hard lock.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": ": An entity.",
					"mandatory": true
				},
				{
					"name": "slot",
					"description": ":  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)",
					"mandatory": false
				}
			],
			"example": "player WeaponLockFinalize( enemyGuy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockFree",
			"description": "Clears player's weapon lock.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "slot",
					"description": "The weapon slot. Default is 0",
					"mandatory": false
				}
			],
			"example": "player WeaponLockClear()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockNoClearance",
			"description": "When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that there is an obstruction.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bool",
					"description": ": true or false.",
					"mandatory": true
				},
				{
					"name": "slot",
					"description": "The weapon slot. Default is 0",
					"mandatory": false
				}
			],
			"example": "player WeaponLockNoClearance( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockRemoveSlot",
			"description": "removes the given slot values and compresses the remaining slots  (i.e. 1,2,3 with 2 removed becomes 1,3,blank)",
			"calledOn": "player",
			"parameters": [
				{
					"name": "slot",
					"description": "The weapon slot. Default is 0",
					"mandatory": true
				}
			],
			"example": "player WeaponLockGetFlags()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockStart",
			"description": "Begins player's weapon lockon sequence (hud effects, etc).  Will clear any existing hard lock.  Use WeaponLockFinalize() to complete lock.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "entity",
					"description": ": An entity.",
					"mandatory": true
				},
				{
					"name": "slot",
					"description": ":  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)",
					"mandatory": false
				}
			],
			"example": "player WeaponLockStart( enemyGuy )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponLockTargetTooClose",
			"description": "When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that they are too close.",
			"calledOn": "player",
			"parameters": [
				{
					"name": "bool",
					"description": ": true or false.",
					"mandatory": true
				},
				{
					"name": "slot",
					"description": "The weapon slot. Default is 0",
					"mandatory": false
				}
			],
			"example": "player WeaponLockTargetTooClose( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponPlayEjectBrass",
			"description": "Play the eject brass FX for a weapon.",
			"calledOn": "player",
			"parameters": [],
			"example": "player WeaponPlayEjectBrass()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "WeaponSwitchButtonPressed",
			"description": "Check if the player is pressing the weapon switch button",
			"calledOn": "player",
			"parameters": [],
			"example": "if ( self WeaponSwitchButtonPressed() ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ChangeFontScaleOverTime",
			"description": "Set a hud element to transition in fontScale over time.  Normally setting the fontScale of an element causes an immediate visual change. However, if the fontScale gets set within <time> after calling ChangeFontScaleOverTime, then the hud element will transition to the new fontScale over the remaining <time>.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "time",
					"description": "The time to scale the element font in seconds",
					"mandatory": true
				}
			],
			"example": "level.introstring1 ChangeFontScaleOverTime( 1.2 );  level.introstring1.fontScale = 0.3;  // This will transition the fontScale from whatever it was before to the new value of 0.3 over 1.2 seconds.",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearTargetEnt",
			"description": "Clear this waypoint from targetting an entity.",
			"calledOn": "hud_element",
			"parameters": [],
			"example": "waypoint ClearTargetEnt()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Destroy",
			"description": "Remove this Hud element altogether.",
			"calledOn": "hud_element",
			"parameters": [],
			"example": "self.bombstopwatch Destroy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FadeOverTime",
			"description": "Set a hud element to transition in color (or alpha) over time.  Normally setting the color (or alpha) of an element causes an immediate visual change. However, if the color (or alpha) gets set within <time> after calling fadeOverTime, then the hud element will transition to the new color over the remaining <time>.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "time",
					"description": "The time to fade the element in seconds",
					"mandatory": true
				}
			],
			"example": "level.introstring1 FadeOverTime( 1.2 );  level.introstring1.alpha = 0.3;  // This will transition the alpha from whatever it was before to the new value of 0.3 over 1.2 seconds.",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTextWidth",
			"description": "Returned the width of the text in the hudelem.",
			"calledOn": "hud_element",
			"parameters": [],
			"example": "width = elem GetTextWidth()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MoveOverTime",
			"description": "Set a hud element to move over time.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "time",
					"description": "The time to move the element in seconds",
					"mandatory": true
				}
			],
			"example": "newStr MoveOverTime( timer )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewClientHudElem",
			"description": "Create a new hud element for a particular client",
			"calledOn": null,
			"parameters": [
				{
					"name": "client",
					"description": "The client for whom the hud element is created.",
					"mandatory": true
				}
			],
			"example": "self.kc_topbar = NewClientHudElem(self)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewDamageIndicatorHudElem",
			"description": "Create a new hud element for a particular client",
			"calledOn": null,
			"parameters": [
				{
					"name": "client",
					"description": "The client for whom the hud element is created.",
					"mandatory": true
				}
			],
			"example": "self.kc_topbar = NewClientHudElem(self)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewDebugHudElem",
			"calledOn": null,
			"parameters": [],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewHudElem",
			"description": "Create a new hud element",
			"calledOn": null,
			"parameters": [],
			"example": "overlay = NewHudElem()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewScoreHudElem",
			"description": "Create a new score hud element for a particular client",
			"calledOn": null,
			"parameters": [
				{
					"name": "client",
					"description": "The client for whom the hud element is created.",
					"mandatory": true
				}
			],
			"example": "self.hud_rankscroreupdate = NewScoreHudElem(self)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "NewTeamHudElem",
			"description": "Create a new hud element for a particular team",
			"calledOn": null,
			"parameters": [
				{
					"name": "team",
					"description": "The team for whom the hud element is created. Must be 'axis', 'allies' or 'spectator'",
					"mandatory": true
				}
			],
			"example": "level.progressbar_allies_neutralize = NewTeamHudElem( \"axis\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Reset",
			"description": "Reset a HUD element to its default state.",
			"calledOn": "hud_element",
			"parameters": [],
			"example": "element Reset()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ScaleOverTime",
			"description": "Set a hud element to scale over time.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "time",
					"description": "The time to scale the element in seconds",
					"mandatory": true
				},
				{
					"name": "width",
					"description": "The new width of the material.",
					"mandatory": true
				},
				{
					"name": "height",
					"description": "The new height of the material.",
					"mandatory": true
				}
			],
			"example": "other.progressbar ScaleOverTime( level.planttime, level.barsize, 8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClock",
			"description": "Set a clock HUD element to count down over a time period.",
			"calledOn": "hud_clock_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time in seconds to count down",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.",
					"mandatory": true
				},
				{
					"name": "material",
					"description": "The material for the hud clock",
					"mandatory": true
				},
				{
					"name": "width",
					"description": "The width of the material.",
					"mandatory": false
				},
				{
					"name": "height",
					"description": "The height of the material.",
					"mandatory": false
				}
			],
			"example": "level.bombstopwatch SetClock( 5, 60, \"hudStopwatch\", 64, 64 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetClockUp",
			"description": "Set a clock HUD element to count up over a time period.",
			"calledOn": "hud_clock_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time in seconds to count up",
					"mandatory": true
				},
				{
					"name": "full time",
					"description": "The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.",
					"mandatory": true
				},
				{
					"name": "material",
					"description": "The material for the hud clock",
					"mandatory": true
				},
				{
					"name": "width",
					"description": "The width of the material.",
					"mandatory": false
				},
				{
					"name": "height",
					"description": "The height of the material.",
					"mandatory": false
				}
			],
			"example": "level.bombstopwatch SetClockUp( 5, 60, \"hudStopwatch\", 64, 64 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetCOD7DecodeFX",
			"description": "Set the hudelem string to display with a decode effect.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "decodeTime",
					"description": "Time for each letter to decode.",
					"mandatory": true
				},
				{
					"name": "decayStart",
					"description": "Time to wait before starting the text decay effect.",
					"mandatory": true
				},
				{
					"name": "decayDuration",
					"description": "How long to spend decaying.",
					"mandatory": true
				}
			],
			"example": "elem SetCOD7DecodeFX( 2000, 600 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGameTypeString",
			"description": "Set the game type string for the game",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "game type",
					"description": "A string containing the game type",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMapNameString",
			"description": "Set the map name string",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "map name",
					"description": "A string containing the map name",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPerks",
			"description": "Sets a hud element to be a perks element.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "client",
					"description": "client we should be showing the perks of",
					"mandatory": true
				}
			],
			"example": "hudelement SetPerks( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlayerNameString",
			"description": "Set the player name string for a HUD element",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "player",
					"description": "A player entity",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPulseFX",
			"description": "Set the hudelem string to display with a \"Pulse\" effect.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "speed",
					"description": "Time (in milliseconds) each letter takes to type out.",
					"mandatory": true
				},
				{
					"name": "decayStart",
					"description": "Time to wait before starting the string's decay effect.",
					"mandatory": true
				},
				{
					"name": "decayDuration",
					"description": "How long to spend decaying.",
					"mandatory": true
				}
			],
			"example": "elem SetPulseFX( 40, 2000, 600 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRedactFX",
			"description": "Set the hudelem string to display with a redact effect.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "decayStart",
					"description": "Time to wait before starting the text decay effect.",
					"mandatory": true
				},
				{
					"name": "decayDuration",
					"description": "How long to spend decaying.",
					"mandatory": true
				},
				{
					"name": "redactDecayStart",
					"description": "Time to wait before starting the redact decay effect.",
					"mandatory": true
				},
				{
					"name": "redactDecayDuration",
					"description": "How long to spend decaying.",
					"mandatory": true
				}
			],
			"example": "elem SetRedactFX( 2000, 600, 3000, 400 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetShader",
			"description": "Set the material for this Hud Element",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "materialname",
					"description": "A the name of the material to set",
					"mandatory": true
				},
				{
					"name": "width",
					"description": "The width of the material.",
					"mandatory": false
				},
				{
					"name": "height",
					"description": "The height of the material.",
					"mandatory": false
				}
			],
			"example": "waypoint SetShader( \"playbook_objective_stop\", 15, 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetEnt",
			"description": "Set the entity that this waypoint should target.  In MP, entity should already be a broadcasting entity, as with Objective_OnEntity().",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "entity",
					"description": "Entity to Target",
					"mandatory": true
				}
			],
			"example": "waypoint SetTargetEnt( level.axis.bombcarrier )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTenthsTimer",
			"description": "Set a timer HUD element to count down in tenths of a second",
			"calledOn": "hud_timer_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time",
					"mandatory": true
				}
			],
			"example": "self.kc_timer SetTenthsTimer( self.archivetime - delay )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTenthsTimerUp",
			"description": "Set a timer HUD element to count up in tenths of a second",
			"calledOn": "hud_timer_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time",
					"mandatory": true
				}
			],
			"example": "self.kc_timer SetTenthsTimerUp( self.archivetime - delay )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetText",
			"description": "Set HUD text for this element.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "text",
					"description": "A localized text reference",
					"mandatory": true
				}
			],
			"example": "level.introstring1 SetText(string1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTimer",
			"description": "Set a timer HUD element to count down",
			"calledOn": "hud_timer_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time",
					"mandatory": true
				}
			],
			"example": "level.reinforcement_hud SetTimer( level.counter )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTimerUp",
			"description": "Set a timer HUD element to count up",
			"calledOn": "hud_timer_element",
			"parameters": [
				{
					"name": "time",
					"description": "The new timer time",
					"mandatory": true
				}
			],
			"example": "level.reinforcement_hud SetTimerUp( level.counter )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTypewriterFX",
			"description": "Set the hudelem string to display with a redact effect.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "letterTime",
					"description": "Time it take for each letter to type in.",
					"mandatory": true
				},
				{
					"name": "decayStart",
					"description": "Time to wait before starting the text decay effect.",
					"mandatory": true
				},
				{
					"name": "decayDuration",
					"description": "How long to spend decaying.",
					"mandatory": true
				}
			],
			"example": "elem SetTypewriterFX( 100, 600, 3000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetValue",
			"description": "Set a value HUD element to a given value.",
			"calledOn": "hud_value_element",
			"parameters": [
				{
					"name": "value",
					"description": "The value to set the element to",
					"mandatory": true
				}
			],
			"example": "level.reinforcement_hud SetValue( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWarGameData",
			"description": "Creates a WAR specific HUD progress element",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "momentumProgress",
					"description": ", <momentumMultiplier>, <momentumBlitzkriegTime>",
					"mandatory": true
				}
			],
			"example": "hudelement SetWarGameData( 0, 1, 30 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetWayPoint",
			"description": "Sets a hud element to be a waypoint.",
			"calledOn": "hud_element",
			"parameters": [
				{
					"name": "constantSize",
					"description": "boolean describing whether the hud element remains the same size",
					"mandatory": true
				},
				{
					"name": "offscreenMaterialName",
					"description": "Material to draw when waypoint is offscreen.",
					"mandatory": false
				},
				{
					"name": "isDistanceShown",
					"description": "boolean turning on/off player distance to waypoint display above the waypoint.",
					"mandatory": false
				},
				{
					"name": "no offscreen",
					"description": "boolean turning on/off arrow indicators when element is offscreen.",
					"mandatory": false
				}
			],
			"example": "newdeathicon SetWayPoint( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "array",
			"description": "create an array",
			"calledOn": null,
			"parameters": [
				{
					"name": "args",
					"description": "one or more args to add to the array",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayCombine",
			"description": "combine two arrays into and returns one new array",
			"calledOn": null,
			"parameters": [
				{
					"name": "array1",
					"description": "array to operate on",
					"mandatory": true
				},
				{
					"name": "array2",
					"description": "array to operate on",
					"mandatory": true
				},
				{
					"name": "allowdupes",
					"description": "if true then allow duplicate entries, otherwise prune them out when combining",
					"mandatory": true
				},
				{
					"name": "preserve_keys",
					"description": "if true then preserve the keys (only for string keys) otherwise renumber when combining",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayCopy",
			"description": "returns a copy of an array",
			"calledOn": null,
			"parameters": [
				{
					"name": "array1",
					"description": "array to operate on",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayGetClosest",
			"description": "Returns the entity/vector that is closest to the <origin> from the <array>.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The origin to get closest from",
					"mandatory": true
				},
				{
					"name": "array",
					"description": "The array to search in",
					"mandatory": true
				},
				{
					"name": "dist",
					"description": "The minimum distance to check when finding closest (has to be positive)",
					"mandatory": false
				}
			],
			"example": "ent = ArrayGetClosest( player.origin, a_enemies )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayGetFarthest",
			"description": "Returns the entity/vector that is farthest to the <origin> from the <array>.",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The origin to get farthest from",
					"mandatory": true
				},
				{
					"name": "array",
					"description": "The array to search in",
					"mandatory": true
				},
				{
					"name": "dist",
					"description": "The maximum distance when finding farthest (has to be positive)",
					"mandatory": false
				}
			],
			"example": "ent = ArrayGetFarthest( player.origin, a_enemies )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayInsert",
			"description": "insert a value into an array at a given index",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to operate on",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "value to insert",
					"mandatory": true
				},
				{
					"name": "index",
					"description": "index at which to insert the value (must be an integer) - moves existing entries as required",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayIntersect",
			"description": "Returns an array of values that are present in both arrays.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array1",
					"description": "An Array",
					"mandatory": true
				},
				{
					"name": "array2",
					"description": "An Array",
					"mandatory": true
				},
				{
					"name": "matchKeys",
					"description": "Optionally returns an array of matching key/value pairs from the two input arrays (preserving the keys).",
					"mandatory": false
				}
			],
			"example": "newArray = ArrayIntersect( array1, array2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayRemoveIndex",
			"description": "Remove a value from an array at a given index",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to operate on",
					"mandatory": true
				},
				{
					"name": "index",
					"description": "index of value to remove",
					"mandatory": true
				},
				{
					"name": "preserve_keys",
					"description": "defaults to false, if true then it preserves the keys - otherwise creates integer keys",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ArrayRemoveValue",
			"description": "Remove a value from an array (may affect multiple indexes)",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to operate on",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "value to remove (may be undefined)",
					"mandatory": true
				},
				{
					"name": "preserve_keys",
					"description": "defaults to false, if true then it preserves the keys - otherwise creates integer keys",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Assert",
			"description": "Assert that the given statement is correct. The function will throw a script error if this is false.",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "statement that is asserted to be correct",
					"mandatory": true
				},
				{
					"name": "desc",
					"description": "string describing the nature of the assert",
					"mandatory": false
				}
			],
			"example": "Assert( enemyInSight == true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AssertMsg",
			"description": "Throws a script error with the given message.",
			"calledOn": null,
			"parameters": [
				{
					"name": "message",
					"description": "error message",
					"mandatory": true
				}
			],
			"example": "AssertMsg( \"Unhandled enemy type.\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "associativeArray",
			"description": "creates an associativeArray",
			"calledOn": null,
			"parameters": [
				{
					"name": "key_i",
					"description": "the string key for the next value",
					"mandatory": false
				},
				{
					"name": "value_i",
					"description": "the value for the previous key",
					"mandatory": false
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ErrorMsg",
			"description": "Throws a non-fatal script error with the given message.",
			"calledOn": null,
			"parameters": [
				{
					"name": "message",
					"description": "error message",
					"mandatory": true
				}
			],
			"example": "ErrorMsg( \"Unhandled enemy type.\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetArrayKeys",
			"description": "Returns an array consisting of the keys of the input array.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "Input array",
					"mandatory": true
				}
			],
			"example": "result = GetArrayKeys( array )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachmentTableIndex",
			"description": "Returns the attachment table index for the attachment name",
			"calledOn": null,
			"parameters": [
				{
					"name": "attachmentRef",
					"description": "Attachment Reference",
					"mandatory": true
				}
			],
			"example": "attachmentIndex = GetAttachmentTableIndex( \"reflex\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDvarFloat",
			"description": "Gets the value of a dvar.",
			"calledOn": null,
			"parameters": [
				{
					"name": "dvar",
					"description": "The dvar name as a string or hash.",
					"mandatory": true
				},
				{
					"name": "default_value",
					"description": "The value to be returned if the dvar doesn't exist, must be an float.",
					"mandatory": false
				}
			],
			"example": "GetDvarFloat( \"r_eyesAdjust\", 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDvarInt",
			"description": "Gets the value of a dvar.",
			"calledOn": null,
			"parameters": [
				{
					"name": "dvar",
					"description": "The dvar name as a string or hash.",
					"mandatory": true
				},
				{
					"name": "default_value",
					"description": "The value to be returned if the dvar doesn't exist, must be an integer.",
					"mandatory": false
				}
			],
			"example": "GetDvarInt( \"r_eyesAdjust\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDvarString",
			"description": "Gets the value of a dvar.",
			"calledOn": null,
			"parameters": [
				{
					"name": "dvar",
					"description": "The dvar name as a string or hash.",
					"mandatory": true
				},
				{
					"name": "default_value",
					"description": "The value to be returned if the dvar doesn't exist, must be a string.",
					"mandatory": false
				}
			],
			"example": "GetDvarString( \"r_eyesAdjust\", \"yes\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDvarVector",
			"description": "Gets the value of a dvar.",
			"calledOn": null,
			"parameters": [
				{
					"name": "dvar",
					"description": "The dvar name as a string or hash.",
					"mandatory": true
				},
				{
					"name": "default_value",
					"description": "The value to be returned if the dvar doesn't exist, must be an vector.",
					"mandatory": false
				}
			],
			"example": "GetDvarVector( \"r_eyesAdjust\", (1,0,0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetFirstArrayKey",
			"description": "Returns the first key of the input array.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "Input array",
					"mandatory": true
				}
			],
			"example": "key = GetFirstArrayKey( array )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetItemIndexFromRef",
			"description": "Returns the item index for the specified item reference",
			"calledOn": null,
			"parameters": [
				{
					"name": "itemRef",
					"description": "Item Reference",
					"mandatory": true
				}
			],
			"example": "itemIndex = GetItemIndexFromRef( <itemRef> )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetLastArrayKey",
			"description": "Returns the last key of the input array.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "Input array",
					"mandatory": true
				}
			],
			"example": "key = GetLastArrayKey( array )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNextArrayKey",
			"description": "Returns the next key of the input array, after the specified key.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "Input array",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "The given key",
					"mandatory": true
				}
			],
			"example": "key = GetNextArrayKey( array, key )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPrevArrayKey",
			"description": "Returns the prev key of the input array, before the specified key.",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "Input array",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "The given key",
					"mandatory": true
				}
			],
			"example": "key = GetPrevArrayKey( array, key )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSubStr",
			"description": "Returns the substring of characters >= <start index> and < <end index>. <end index> is optional.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The input string",
					"mandatory": true
				},
				{
					"name": "start index",
					"description": "The start index of the substring",
					"mandatory": true
				},
				{
					"name": "end index",
					"description": "The end index of the substring",
					"mandatory": false
				}
			],
			"example": "name = getSubStr( playerwarp_string, 8 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsArray",
			"description": "Checks whether this entity/variable is an array",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a array",
					"mandatory": true
				}
			],
			"example": "if ( isarray ( gun_owner )) ... ",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsClass",
			"description": "Checks whether this entity/variable is a class object",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a class",
					"mandatory": true
				}
			],
			"example": "if ( isclass(self)) ... ",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFloat",
			"description": "Checks whether this entity/variable is a float",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a float",
					"mandatory": true
				}
			],
			"example": "if ( IsFloat( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsFunctionPtr",
			"description": "Checks whether given variable is of type Function Pointer in script, useful to differentiate between Var and FuncPtr in Script.",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable to test",
					"mandatory": true
				}
			],
			"example": "if ( IsFunctionPtr( myFuncPtr ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInArray",
			"description": "searches an array to determine if a given value is present in that array",
			"calledOn": null,
			"parameters": [
				{
					"name": "array",
					"description": "array to search",
					"mandatory": true
				},
				{
					"name": "value",
					"description": "value to search for",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInt",
			"description": "Checks whether this entity/variable is an int",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be an int",
					"mandatory": true
				}
			],
			"example": "if ( IsInt( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsString",
			"description": "Checks whether this entity/variable is a string",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a string",
					"mandatory": true
				}
			],
			"example": "if ( isstring ( gun_owner )) ... ",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsStruct",
			"description": "Checks whether this variable is a struct object",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a struct",
					"mandatory": true
				}
			],
			"example": "if ( isstruct(self)) ... ",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsSubStr",
			"description": "Returns true/false if <substring> is a substring of <string>. Case sensitive.",
			"calledOn": null,
			"parameters": [],
			"example": "has_str = IsSubStr( \"my_string\", \"str\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "istring",
			"description": "Casts a string to an istring",
			"calledOn": null,
			"parameters": [
				{
					"name": "value",
					"description": "A string to cast to an istring",
					"mandatory": true
				}
			],
			"example": "x = istring( String )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVec",
			"description": "Checks whether this entity/variable is a vector",
			"calledOn": null,
			"parameters": [
				{
					"name": "variable",
					"description": "variable that may or may not be a vector",
					"mandatory": true
				}
			],
			"example": "if ( IsVec( gun_owner ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsWeapon",
			"description": "Checks whether this is a weapon object",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon_object",
					"description": "An parameter that may be a weapon object",
					"mandatory": true
				}
			],
			"example": "if ( IsWeapon( current_weapon ) ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeLocalizedString",
			"description": "Make a localized string of the given string",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The string to translate",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "sprintf",
			"description": "Replaces field specifiers in a string with values passed in, returns result string format specifiers take the form of {[n]} in the source string where [n] indicates which value to print, e.g. 0 is the first user arg",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The string to translate",
					"mandatory": true
				},
				{
					"name": "args",
					"description": "zero or more arguments",
					"mandatory": false
				}
			],
			"example": "sprintf(\"{0} is the first string\",\"first\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrEndsWith",
			"description": "Returns true/false if <string> ends with <substring>. Case sensitive.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "String to search",
					"mandatory": true
				},
				{
					"name": "substring",
					"description": "Substring to search with.",
					"mandatory": true
				}
			],
			"example": "ends_with = StrEndsWith( \"my_string\", \"_string\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrIsFloat",
			"description": "Check if a string is a float.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": ": The string to check.",
					"mandatory": true
				}
			],
			"example": "StrIsFloat( \"1.2\" ); // true",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrIsInt",
			"description": "Check if a string is an int.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": ": The string to check.",
					"mandatory": true
				}
			],
			"example": "StrIsInt( \"1\" ); // true",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrIsNumber",
			"description": "Check if a string is a number.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": ": The string to check.",
					"mandatory": true
				}
			],
			"example": "StrIsNumber( \"1.2\" ); // true",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrStartsWith",
			"description": "Returns true/false if <string> starts with <substring>. Case sensitive.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "String to search",
					"mandatory": true
				},
				{
					"name": "substring",
					"description": "Substring to search with.",
					"mandatory": true
				}
			],
			"example": "starts_with = StrStartsWith( \"my_string\", \"my_\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrStrip",
			"description": "Strip whitespace from right and left side of string.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": ": The string to strip.",
					"mandatory": true
				}
			],
			"example": "StrStrip( \"    hq_cleared   \" ); // 'hq_cleared'",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrTok",
			"description": "Tokenizes <string> by the delimiters <delim>. Returns the array of string tokens.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The input string",
					"mandatory": true
				},
				{
					"name": "delim",
					"description": "The delimiter to tokenize by",
					"mandatory": true
				}
			],
			"example": "my_string_array = StrTok( \"my_string; my_string_2\", \"; \" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StrTok2",
			"description": "Tokenizes <string> by a single delimiter string.  doesn't treat the delimiter string as a series of characters, but as a string",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "The input string",
					"mandatory": true
				},
				{
					"name": "delim",
					"description": "The delimiter to tokenize by",
					"mandatory": true
				},
				{
					"name": "case_sensitive",
					"description": "true if test is case sensitive",
					"mandatory": false
				}
			],
			"example": "my_string_array = StrTok2( \"my_string foo; my_string_2\", \"foo; \" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookup",
			"description": "look up a row in a table and pull out a particular column from that row",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				},
				{
					"name": "search column num",
					"description": "The column number of the stats table to search through",
					"mandatory": true
				},
				{
					"name": "search value",
					"description": "The value to use when searching the <search column num>",
					"mandatory": true
				},
				{
					"name": "return value column num",
					"description": "The column number value to return after we find the correct row",
					"mandatory": true
				}
			],
			"example": "TableLookup( \"mp/statstable.csv\", 0, \"INDEX_KILLS\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupColumnCount",
			"description": "look up the number of columns in a table",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				}
			],
			"example": "TableLookup( \"mp/statstable.csv\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupColumnForRow",
			"description": "look up a particular row and column in a table",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				},
				{
					"name": "search row num",
					"description": "The row number of the string table to search through",
					"mandatory": true
				},
				{
					"name": "search column num",
					"description": "The column number of the string table to search through",
					"mandatory": true
				}
			],
			"example": "TableLookupColumnForRow( \"gamedata/tables/mp/exampleStringTable.csv\", 101, 7 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupFindCoreAsset",
			"description": "Find core asset index for a stringtable",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				}
			],
			"example": "TableLookupRowNum( \"mp/statstable.csv\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupIString",
			"description": "look up a row in a table and pull out a particular column from that row",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				},
				{
					"name": "search column num",
					"description": "The column number of the stats table to search through",
					"mandatory": true
				},
				{
					"name": "search value",
					"description": "The value to use when searching the <search column num>",
					"mandatory": true
				},
				{
					"name": "return value column num",
					"description": "The column number value to return after we find the correct row",
					"mandatory": true
				}
			],
			"example": "TableLookupIString( \"mp/statstable.csv\", 0, \"INDEX_KILLS\", 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupRow",
			"description": "Return an array of strings for the columns in that row",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				},
				{
					"name": "row num",
					"description": "The row num of the row in table to return",
					"mandatory": true
				}
			],
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupRowCount",
			"description": "look up the number of rows in a table",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				}
			],
			"example": "TableLookup( \"mp/statstable.csv\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TableLookupRowNum",
			"description": "look up a row number in a table",
			"calledOn": null,
			"parameters": [
				{
					"name": "filename",
					"description": "The table to look up",
					"mandatory": true
				},
				{
					"name": "search column num",
					"description": "The column number of the stats table to search through",
					"mandatory": true
				},
				{
					"name": "search value",
					"description": "The value to use when searching the <search column num>",
					"mandatory": true
				}
			],
			"example": "TableLookupRowNum( \"mp/statstable.csv\", 0, \"INDEX_KILLS\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Throw",
			"description": "force a script exception (from a builtin call)",
			"calledOn": null,
			"parameters": [],
			"example": "throw( )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ToLower",
			"description": "Converts <string> to a lower case string which is returned.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "(string) Base string",
					"mandatory": true
				}
			],
			"example": "my_string = ToLower( \"MY_STRING\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ToUpper",
			"description": "Converts <string> to a upper case string which is returned.",
			"calledOn": null,
			"parameters": [
				{
					"name": "string",
					"description": "(string) Base string",
					"mandatory": true
				}
			],
			"example": "my_string = ToUpper( \"lower\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "AttachPath",
			"description": "Attaches this vehicle to the given path.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "node",
					"description": "A node on the path to attach.",
					"mandatory": true
				}
			],
			"example": "bomber AttachPath( aBomberPaths[i] )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CancelAIMove",
			"description": "Tell the vehicle to stop moving towards its current goal position.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "eTank CancelAIMove()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearDefaultPitch",
			"description": "Clears the desired default pitch for a vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "level.heli cleardefaultpitch()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearGoalYaw",
			"description": "Clear the goal yaw direction for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "level.flak1 ClearGoalYaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearGunnerTarget",
			"description": "Clear the target for the vehicle turret.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "Which gun, 0-3.",
					"mandatory": false
				}
			],
			"example": "eTank ClearGunnerTarget(0)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearLookAtEnt",
			"description": "Clear the entity or origin the vehicle is orienting towards.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "heli clearLookAtEnt()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearTargetYaw",
			"description": "Clear the target yaw direction for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "level.flak1 cleartargetyaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearTurretTarget",
			"description": "Clear the target for the vehicle turret.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "turret index",
					"description": "0 for turret, 1-4 for gunners",
					"mandatory": false
				}
			],
			"example": "eTank ClearTurretTarget()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ClearVehGoalPos",
			"description": "Clears the target position for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "tank ClearVehGoalPos()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "CreateTrack",
			"description": "Set the node enabled or disabled for vehicle pathfinding.  SetVehGoalPos will now return true or false if it can find a path.",
			"calledOn": null,
			"parameters": [
				{}
			],
			"example": "CreateTrack( track_node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableDriverFiring",
			"description": "Enables or disables the driver's vehicle turret",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "tank DisableDriverFiring( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DisableGunnerFiring",
			"description": "Enable or disable gunner firing",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "The gunner to disable/enable",
					"mandatory": true
				},
				{
					"name": "onoff",
					"description": "true to disable, false otherwise",
					"mandatory": true
				}
			],
			"example": "tank DisableGunnerFiring( 1, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DrawTrajectory",
			"description": "Draws the vehicles trajectory.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "show",
					"description": "Whether to draw trajectory or not",
					"mandatory": true
				}
			],
			"example": "plane DrawTrajectory( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "DrivePath",
			"description": "Starts the vehicle driving this path and uses the vehicle physics, not locked to the spline, can only achieve turns that the physics can handle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "node index",
					"description": "A node on the path to attach.",
					"mandatory": false
				},
				{
					"name": "allow free drive",
					"description": "This give the player free driving but script notifies when passing nodes on a vehcile spline",
					"mandatory": false
				}
			],
			"example": "huey DrivePath( start_node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FinishVehicleDamage",
			"description": "Does damage to an vehicle - usually as part of the damage callback",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "Inflictor",
					"description": "The entity that causes the damage.(e.g. a turret)",
					"mandatory": true
				},
				{
					"name": "Attacker",
					"description": "The entity that is attacking.",
					"mandatory": true
				},
				{
					"name": "Damage",
					"description": "Integer specifying the amount of damage done",
					"mandatory": true
				},
				{
					"name": "Damage Flags",
					"description": "Integer specifying flags that are to be applied to the damage",
					"mandatory": true
				},
				{
					"name": "Means Of Death",
					"description": "Integer specifying the method of death",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				},
				{
					"name": "Point",
					"description": "Point of damage",
					"mandatory": true
				},
				{
					"name": "Direction",
					"description": "(vector) The direction of the damage",
					"mandatory": true
				},
				{
					"name": "Hit Loc",
					"description": "The location of the hit",
					"mandatory": true
				},
				{
					"name": "Offset Time",
					"description": "The time offset for the damage",
					"mandatory": true
				},
				{
					"name": "DamageFromUnderneath",
					"description": "If the hit is underneath the vehicle",
					"mandatory": true
				},
				{
					"name": "modelIndex",
					"description": "which model in the dobj was hit",
					"mandatory": true
				},
				{
					"name": "partIndex",
					"description": "which bone was hit",
					"mandatory": true
				},
				{
					"name": "damageteammates",
					"description": "Whether to damage teammates or not",
					"mandatory": true
				}
			],
			"example": "self FinishVehicleDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, psOffsetTime, damageUnderneathVehicle, modelindex, partname, damageteammates )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FinishVehicleRadiusDamage",
			"description": "Does damage to an vehicle - usually as part of the damage callback",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "Inflictor",
					"description": "The entity that causes the damage.(e.g. a turret)",
					"mandatory": true
				},
				{
					"name": "Attacker",
					"description": "The entity that is attacking.",
					"mandatory": true
				},
				{
					"name": "Damage",
					"description": "Integer specifying the amount of damage done",
					"mandatory": true
				},
				{
					"name": "Inner Damage",
					"description": "Integer specifying the amount of inner damage done",
					"mandatory": true
				},
				{
					"name": "Outer Damage",
					"description": "Integer specifying the amount of outer damage done",
					"mandatory": true
				},
				{
					"name": "Damage Flags",
					"description": "Integer specifying flags that are to be applied to the damage",
					"mandatory": true
				},
				{
					"name": "Means Of Death",
					"description": "Integer specifying the method of death",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				},
				{
					"name": "Point",
					"description": "(vector) The Point of the damage",
					"mandatory": true
				},
				{
					"name": "Radius",
					"description": "(float) The radius of the damage",
					"mandatory": true
				},
				{
					"name": "ConeRadius",
					"description": "(float) The radius of the cone damage",
					"mandatory": true
				},
				{
					"name": "ConeDirection",
					"description": "(vector) The direction of the cone damage",
					"mandatory": true
				},
				{
					"name": "Offset Time",
					"description": "The time offset for the damage",
					"mandatory": true
				}
			],
			"example": "self FinishVehicleRadiusDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, fRadius, fConeRadius, fConeDir, psOffsetTime )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FireWeapon",
			"description": "Fire the vehicle's weapon",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "turret_index",
					"description": "turret index, 0 being main turret, 1~4 being gunners",
					"mandatory": false
				},
				{
					"name": "target ent",
					"description": "A target entity for guided missiles",
					"mandatory": false
				},
				{
					"name": "target offset",
					"description": "Only used for projectile and bomb weapons",
					"mandatory": false
				},
				{
					"name": "attacker",
					"description": "real attacker who should take credit of this shot",
					"mandatory": false
				}
			],
			"example": "m_vehicle FireWeapon( 0, m_e_target, v_target_offset )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Flip180",
			"description": "Flips this vehicle 180 (for going forwards / backwards along a path)",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "huey Flip180()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "FreeVehicle",
			"description": "Frees this vehicle instance.  It will unlink any players occupying the vehicle. It will change the vehicle into a vehicle corpse.  It will send a death notify on the vehicle.  Once called the vehicle cannot move anymore.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self FreeVehicle()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAllVehicleNodes",
			"description": "Gets all of the vehicle nodes in a level",
			"calledOn": null,
			"parameters": [],
			"example": "nodes = GetAllVehicleNodes()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAngularVelocity",
			"description": "Gets the current angular velocity.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetAngularVelocity()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetAttachPos",
			"description": "Returns the origin and angles if the vehicle were to be attached to the path.  The origin and angles are returned as a vector array of size 2.  Origin is 1st and angles is 2nd.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "node index",
					"description": "A node on the path to attach.",
					"mandatory": true
				}
			],
			"example": "pos = self GetAttachPos( node )origin = pos[0]angles = pos[1]",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetBrake",
			"description": "Gets the brake value of a nitrous physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "jeep getbrake()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetDefaultAcceleration",
			"description": "Gets the acceleration value set in GDT.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "accel = self GetDefaultAcceleration()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "getgoalspeedMPH",
			"description": "Gets the goal speed in miles per hour.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetGoalSpeedMPH()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGoalYaw",
			"description": "Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "level.flak1 GetGoalYaw()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGunnerTargetEnt",
			"description": "Gets the target entity for this gunner position.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "Which gun, 0-3.",
					"mandatory": true
				}
			],
			"example": "target = huey GetGunnerTurretEnt( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetGunnerTargetVec",
			"description": "Get the target position for this vehicle turret gunner.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "which gun 0-3",
					"mandatory": true
				}
			],
			"example": "endpt = GetGunnerTargetVec( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHandBrake",
			"description": "Gets the hand brake value of a nitrous physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "jeep gethandbrake()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHeliHeightLock",
			"description": "Locks the heli to the height mesh",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "if ( vehicle GetHeliHeightLock( ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetHeliHeightLockHeight",
			"description": "Gets the mesh height at a given point.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "point",
					"description": "The point to check at",
					"mandatory": true
				}
			],
			"example": "maxheight = GetHeliHeightLockHeight( point )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetMaxSpeed",
			"description": "Get the max speed of a vehicle. By default gets the script setting",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "get gdt",
					"description": "true to get the gdt setting and not the script set.",
					"mandatory": false
				}
			],
			"example": "heli GetMaxSpeed( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetNumVehicles",
			"description": "Gets the number of vehicles entities in the level",
			"calledOn": null,
			"parameters": [],
			"example": "vehicleCount = GetNumVehicles()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetOccupantSeat",
			"description": "Get the seat index occupied by the given player.  -1 if player isn't in vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "player",
					"description": "The player to get the seat index for",
					"mandatory": true
				}
			],
			"example": "isDriver = 0 == vehicle GetOccupantSeat( player )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathFixedOffset",
			"description": "Gets a fixed offset from the path for a specific vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "offset = huey GetPathFixedOffset()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPathVariableOffset",
			"description": "Gets a variable offset from the path for a specific vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "offset = huey GetPathVariableOffset()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetPhysAcceleration",
			"description": "Gets the vehicles acceleration vector.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "accel = plane GetPhysAccel()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetScriptBrake",
			"description": "Gets the script brake value of a nitrous physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "jeep getscriptbrake()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSeatFiringAngles",
			"description": "Retrieve the angles specifying the direction in which bullets, projectiles, etc. will be emitted from the weapon when it is fired.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat index",
					"description": "The seat to firing angles for",
					"mandatory": true
				}
			],
			"example": "turretBarrelAngles = tank GetSeatFiringAngles( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSeatFiringOrigin",
			"description": "Retrieve the location at the end of the barrel where bullets, projectiles, etc. are emitted when the gun is fired.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat index",
					"description": "The seat to firing origin for",
					"mandatory": true
				}
			],
			"example": "turretBarrelOrigin = tank GetSeatFiringOrigin( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSeatOccupant",
			"description": "Get the entity occupying the given seat index.  Undefined if the seat is empty.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat",
					"description": "0 driver, 1-4 gunners, 5-10 passengers",
					"mandatory": true
				}
			],
			"example": "driver = vehicle GetSeatOccupant( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpeed",
			"description": "Gets the current speed in inches per second.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetSpeed()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSpeedMPH",
			"description": "Gets the current speed in miles per hour.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetSpeedMPH()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetSteering",
			"description": "Returns the steer factor of the vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetSteering()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetThrottle",
			"description": "Returns the throttle factor of the vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "self GetThrottle()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTimeFromVehicleNodeToNode",
			"description": "The time it would take to go from start node to end node if traveling the spline speed.",
			"calledOn": null,
			"parameters": [
				{
					"name": "start_node",
					"description": "The start node of the path",
					"mandatory": true
				},
				{
					"name": "end_node",
					"description": "The end node of the path",
					"mandatory": true
				}
			],
			"example": "time = GetTimeFromVehicleNodeToNode( start_node, end_node )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretHeatValue",
			"description": "Get the current heat value for a vehicle weapon.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "which gun 0-3",
					"mandatory": true
				}
			],
			"example": "heat = self GetTurretHeatValue( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretLimitsYaw",
			"description": "Get the furthest relative yaw angles the turret can aim, all numbers are positive",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "turret index",
					"description": "0 for turret, 1-4 for gunners",
					"mandatory": false
				}
			],
			"example": "limit = veh GetTurretLimits( 1 ); limitMin = -limit[0]; limitMax = limit[1]",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetTurretTargetVec",
			"description": "Get the target position for this vehicle turret or gunner.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "turret index",
					"description": "0 for turret, 1-4 for gunners",
					"mandatory": false
				}
			],
			"example": "endpt = GetTurretTargetVec( 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehDamageMultiplier",
			"description": "Gets the damage multiplier that applies to the damage type.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "damageType",
					"description": "The type of damage being applied to the vehicle",
					"mandatory": true
				}
			],
			"example": "vehicle GetVehDamageMultiplier( damgType )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleAvoidance",
			"description": "Locks the heli to the height mesh",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "if ( vehicle GetVehicleAvoidance() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleAvoidanceNodes",
			"description": "Get the positions for nearby avoidance nodes.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "radius",
					"description": "A radius to filter out nodes returned.",
					"mandatory": true
				}
			],
			"example": "nodes = plane GetVehicleAvoidanceNodes( radius )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleNode",
			"description": "Gets a vehicle node with the given name, key pair",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "(string) The name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "(string) The key that name goes with",
					"mandatory": true
				}
			],
			"example": "node = getvehiclenode(self.target, \"targetname\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleNodeArray",
			"description": "Gets an array of vehicle nodes that have the given name, key pair",
			"calledOn": null,
			"parameters": [
				{
					"name": "name",
					"description": "(string) The name to search for",
					"mandatory": true
				},
				{
					"name": "key",
					"description": "(string) The key that name goes with",
					"mandatory": true
				}
			],
			"example": "nodes = GetVehicleNodeArray(self.target, \"targetname\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehicleOwner",
			"description": "Returns the owner of this particular vehicle.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "eFlak88user = eFlak88 GetVehicleOwner()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetVehOccupants",
			"description": "Get the occupants of this vehicle in an entity array.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "ridersarray = vehicle getvehoccupants()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "GetWheelSurface",
			"description": "Returns the surface type of the given wheel as a string.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "wheel",
					"description": "The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'",
					"mandatory": true
				}
			],
			"example": "surface = self GetWheelSurface( side )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsDriverFiring",
			"description": "Checks if this driver is firing the vehicle turret",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "if( tank IsDriverFiring() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsGunnerFiring",
			"description": "Checks if this gun is currently firing.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "The gunner to check",
					"mandatory": true
				}
			],
			"example": "if( tank IsGunnerFiring( 1 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsInsideHeliHeightLock",
			"description": "Returns true if Helicopter is inside height mesh",
			"calledOn": null,
			"parameters": [],
			"example": "if ( IsInsideHeliHeightLock() )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "isremotecontrol",
			"description": "Query whether this vehicle is usable by players",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "if ( vehicle isvehicleusable(  ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsTurretReady",
			"description": "Query whether this vehicle's turret is ready for firing",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "while ( level.playertank IsTurretReady() != true ) ...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleImmuneToDamage",
			"description": "This checks the vehicle GDT settings related to bulletdamage, grenadedamage, etc.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "Damage Flags",
					"description": "Integer specifying flags that are to be applied to the damage",
					"mandatory": true
				},
				{
					"name": "Means Of Death",
					"description": "Integer specifying the method of death",
					"mandatory": true
				},
				{
					"name": "Weapon",
					"description": "The weapon number of the weapon used to inflict the damage",
					"mandatory": true
				}
			],
			"example": "if ( vehicle IsVehicleImmuneToDamage( flags, mod, weapon ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleManualControl",
			"description": "check if vehicle hkai behavior is enabled. Not to be confused with UseVehicle()",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "vehicle IsVehicleManualControl()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleSeatOccupied",
			"description": "same as useby except you can specify a seat, 0 driver, 1-4 gunners, 5-10 passengers",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat",
					"description": "0 driver, 1-4 gunners, 5-10 passengers",
					"mandatory": true
				}
			],
			"example": "lvt IsVehicleSeatOccupied( 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleTurretOverheating",
			"description": "Returns true if the vehicle turret weapon is overheating, else returns false.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "which gun 0-3",
					"mandatory": true
				}
			],
			"example": "if( self IsVehicleTurretOverheating( 1 ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "IsVehicleUsable",
			"description": "Query whether this vehicle is usable by players",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "if ( vehicle isvehicleusable(  ) )...",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "JoltBody",
			"description": "Jolts the vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "jolt position",
					"description": "The position of the jolt",
					"mandatory": true
				},
				{
					"name": "intensity",
					"description": "The intensity of the jolt",
					"mandatory": true
				},
				{
					"name": "speedFrac",
					"description": "A speed fraction to apply to the jolt. Most be betweeon 0 and 1.",
					"mandatory": false
				},
				{
					"name": "deceleration",
					"description": "The deceleration to apply to this vehicle in miles per hour per second.",
					"mandatory": false
				}
			],
			"example": "self JoltBody( (self.origin + (0,0,64)), 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeVehicleUnusable",
			"description": "Sets this vehicle to be not usable by the player",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "car MakeVehicleUnusable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "MakeVehicleUsable",
			"description": "Sets this vehicle to be usable by the player",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "nFlak makeVehicleUsable()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathFixedOffset",
			"description": "Sets a fixed offset for this vehicle to travel on a vehicle path.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "offset",
					"description": "The offset to apply. A vector in the form (forward, right, up)",
					"mandatory": true
				}
			],
			"example": "huey PathFixedOffset( (0, -200, 0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathFixedOffsetClear",
			"description": "Clears the vehicles fixed offset.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "huey PathFixedOffsetClear()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathMove",
			"description": "Moves the entire path for this vehicle to the specific origin and angles.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "node index",
					"description": "Which node to move to the new location (it moves the whole path not just this node).",
					"mandatory": true
				},
				{
					"name": "new origin",
					"description": "The new position",
					"mandatory": true
				},
				{
					"name": "new angles",
					"description": "The new angles",
					"mandatory": true
				}
			],
			"example": "huey PathMove( node, origin, angles )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathMoveClear",
			"description": "Clears the moved path for this vehicle.  If not cleared then all paths taken will be moved.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "huey PathMoveClear()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathVariableOffset",
			"description": "Sets a variable offset for this vehicle to travel on a vehicle path.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "offset",
					"description": "The offset to apply. A vector in the form (forward, right, up)",
					"mandatory": true
				},
				{
					"name": "time",
					"description": ", The interval at which to choose new offsets",
					"mandatory": true
				}
			],
			"example": "huey PathVariableOffset( (0, 50, 0), 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "PathVariableOffsetClear",
			"description": "Clears the vehicles variable offset.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "huey PathVariableOffsetClear()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "RecalcSplinePaths",
			"description": "Recalcs all the nodes int the map",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "tank2 RecalcSplinePaths()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReconnectVehicleNodes",
			"description": "Reconnect vehicle nodes",
			"calledOn": null,
			"parameters": [],
			"example": "ReconnectVehicleNodes()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResetVehicleFromDropDeploy",
			"description": "Reset vehicle properties from drop deploy so that it may behave as normal.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "raps ResetVehicleFromDropDeploy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ResumeSpeed",
			"description": "Sets the vehicle to resume its path speed.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "acceleration",
					"description": "The acceleration to apply to this vehicle in miles per hour per second.",
					"mandatory": false
				}
			],
			"example": "level.tank ResumeSpeed( 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "ReturnPlayerControl",
			"description": "After controlling a vehicle from script using something like setvehgoalpos(), if the vehicle is being driven by a player, you call this function to return control of the vehicle to the player.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "cobra returnplayercontrol()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SeatGetWeapon",
			"description": "Returns the weapon name for the specified seat.  Undefined if there isn't a weapon. Only driver and gunner seats can have weapons.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat index",
					"description": "The seat to get weapon for",
					"mandatory": true
				}
			],
			"example": "weaponname = vehicle SeatGetWeapon( 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAcceleration",
			"description": "Sets the acceleration for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "acceleration",
					"description": "The acceleration of the vehicle in miles per hour per second",
					"mandatory": true
				}
			],
			"example": "self SetAcceleration( 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAirResistance",
			"description": "Sets the speed at which air resistance maxes out.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "max air resistance speed",
					"description": "speed at which air resistance maxes out (MPH)",
					"mandatory": true
				}
			],
			"example": "self SetAirResistance( 60 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetAngularVelocity",
			"description": "Sets the angular velocity of a vehicle in degs/s.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "angular velocity",
					"description": "The angular velocity to set",
					"mandatory": true
				}
			],
			"example": "self SetAngularVelocity( (0, 90, 0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBrake",
			"description": "Turns off/on the hand brake of a nitrous physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "bool",
					"description": "True or 1 to turn on the brake, false or 0 otherwise",
					"mandatory": true
				}
			],
			"example": "jeep setbrake(1)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetBuoyancyOffset",
			"description": "set buoyancy offset that changes the height an individual vehicle floats in water",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "offset",
					"description": "A height offset from water surface.",
					"mandatory": true
				}
			],
			"example": "crocodile SetBuoyancyOffset( 20 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDamageStage",
			"description": "Set the damage stage of the helicopter",
			"calledOn": null,
			"parameters": [
				{
					"name": "stage",
					"description": "the damage stage to set",
					"mandatory": true
				}
			],
			"example": "self setdamagestage( 3 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDeceleration",
			"description": "Sets the deceleration for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "deceleration",
					"description": "The deceleration of the vehicle in miles per hour per second",
					"mandatory": true
				}
			],
			"example": "self SetDeceleration( 5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDefaultPitch",
			"description": "Set the desired default pitch for a vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "pitch",
					"description": "Set the default pitch",
					"mandatory": true
				}
			],
			"example": "level.heli setdefaultpitch(10)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetDrivePathPhysicsScale",
			"description": "This scales all of the necessary parameters that will help a vehicle drive a path better.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "scale",
					"description": "The scale to set",
					"mandatory": false
				}
			],
			"example": "boat SetDrivePathPhysicsScale( 3.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGoalYaw",
			"description": "Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "integer",
					"description": "The yaw direction of the target: 0 to 360 integer value",
					"mandatory": true
				}
			],
			"example": "level.flak1 SetGoalYaw( int_value )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGunnerTargetEnt",
			"description": "Set the target entity for this vehicle gunner.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "target entity",
					"description": "The target.",
					"mandatory": true
				},
				{
					"name": "target offset",
					"description": "The target offset.",
					"mandatory": false
				},
				{
					"name": "gunner index",
					"description": "Which gun, 0-3.",
					"mandatory": false
				}
			],
			"example": "eLiberator SetGunnerTargetEnt( eFlaktarget, (0,0,0), 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGunnerTargetVec",
			"description": "Set the target position for this vehicle turret gunner.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "target position",
					"description": "vecter to aim at/ the position of the target",
					"mandatory": true
				},
				{
					"name": "gunner index",
					"description": "which gun 0-3",
					"mandatory": false
				}
			],
			"example": "level.flak1 SetGunnerTargetVec( vec1, 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetGunnerTurretOnTargetRange",
			"description": "Set the range at which the gunner_turret_on_target notify will occur.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "gunner index",
					"description": "Which gun, 0-3.",
					"mandatory": true
				},
				{
					"name": "range",
					"description": "In degrees",
					"mandatory": false
				}
			],
			"example": "boat SetGunnerTurretOnTargetRange( 0, 15 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHeliDogfighting",
			"description": "Sets the vehicle (intended for VTOLs only) to be in dogfighting mode (dogfights with the vehicle's focus entity)",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "true to enable dogfighting, false otherwise",
					"mandatory": true
				}
			],
			"example": "vehicle SetHeliDogfighting( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHeliHeightCap",
			"description": "Pulls the heli back down below the height mesh",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "true to enable, false otherwise",
					"mandatory": true
				}
			],
			"example": "vehicle SetHeliHeightCap( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHeliHeightLock",
			"description": "Locks the heli to the height mesh",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "true to enable lock, false otherwise",
					"mandatory": true
				}
			],
			"example": "vehicle SetHeliHeightLock( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHeliHeightPatchEnabled",
			"description": "Enabled or disables the specified heli height lock path",
			"calledOn": null,
			"parameters": [
				{
					"name": "targetname",
					"description": "All heli height lock patches with this target name",
					"mandatory": true
				},
				{
					"name": "enabled",
					"description": "Turn it on or off",
					"mandatory": true
				},
				{
					"name": "player",
					"description": "If defined, only modify the setting for that player",
					"mandatory": false
				}
			],
			"example": "SetHeliHeightPatchEnabled( \"area51\", 0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetHoverParams",
			"description": "Set the hovering parameters.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "radius",
					"description": "The hovering range.",
					"mandatory": true
				},
				{
					"name": "speed",
					"description": "Speed to hover at (MPH)",
					"mandatory": false
				},
				{
					"name": "accel",
					"description": "Acceleration to hover at (MPH/s)",
					"mandatory": false
				}
			],
			"example": "self SetHoverParams( 50, 1, 0.5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetJitterParams",
			"description": "Set the jitter parameters. Set everything to 0 to stop jittering. Vehicle ignores jitter parameters when on ground",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "range vector",
					"description": "The jitter range vector.",
					"mandatory": true
				},
				{
					"name": "min period",
					"description": "Minimum time in seconds to switch jitter direction. Default 0.5 sec",
					"mandatory": false
				},
				{
					"name": "max period",
					"description": "Maximum time in seconds to switch jitter direction. Default 1.0 sec",
					"mandatory": false
				}
			],
			"example": "self SetJitterParams( (0,0,20), 0.5, 1.5 ); // Jitter up or down randomly within 20 units, switching every 0.5 to 1.5 seconds",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLookAtEnt",
			"description": "Set the entity this vehicle will orient towards.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "entity",
					"description": "The target.",
					"mandatory": true
				}
			],
			"example": "eFlak88 setLookAtEnt( eFlaktarget )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetLookAtOrigin",
			"description": "Set the origin this vehicle will orient towards.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "entity",
					"description": "The target.",
					"mandatory": true
				}
			],
			"example": "heli setLookAtOrigin( org )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMantleEnabled",
			"description": "Sets the mantle enabled flag on the vehicle",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "True to set the mantle enabled, false otherwise",
					"mandatory": true
				}
			],
			"example": "vehicle SetMantleEnabled( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMaxAccelerationScale",
			"description": "Sets the max acceleration scale for this physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "scale",
					"description": "The acceleration scale of the physics vehicle",
					"mandatory": true
				}
			],
			"example": "self SetMaxAccelerationScale( 2.6 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMaxPitchRoll",
			"description": "Sets max pitch and roll angle for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "pitch",
					"description": "Max pitch angle",
					"mandatory": true
				},
				{
					"name": "roll",
					"description": "Max roll angle",
					"mandatory": true
				}
			],
			"example": "self SetMaxPitchRoll( 30, 30 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMaxSpeedScale",
			"description": "Sets the max speed scale for this physics vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "scale",
					"description": "The max speed scale of the physics vehicle",
					"mandatory": true
				}
			],
			"example": "self SetMaxSpeedScale( 2.6 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetMinDesiredTurnYaw",
			"description": "The vehicle will not update its desired yaw until the min turn yaw is reached. Set it to 0 to clear it.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "yaw",
					"description": "The min desired turn yaw to set",
					"mandatory": true
				}
			],
			"example": "quadtank SetMinDesiredTurnYaw( 45 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetNearGoalNotifyDist",
			"description": "Set distance near goal at which near_goal notification should be sent once.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "dist",
					"description": "Distance to goal position",
					"mandatory": true
				}
			],
			"example": "tank setNearGoalNotifyDist( 50 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPathTransitionTime",
			"description": "Set the time it takes for a vehicle to lerp on to a spline.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "time",
					"description": "The transition time",
					"mandatory": true
				}
			],
			"example": "boat SetPathTransitionTime( 1.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPhysAcceleration",
			"description": "Sets the vehicles acceleration vector.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "acceleration",
					"description": "The vehicle acceleration",
					"mandatory": true
				}
			],
			"example": "plane SetPhysAcceleration( ( 0, 0, -1600) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPhysAngles",
			"description": "Sets the angles on the phys structure",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "angles vector",
					"description": "The desired angles.",
					"mandatory": true
				}
			],
			"example": "self SetPhysAngles( VectorToAngles( desired_forward ) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlaneBarrelRoll",
			"description": "Set the goal Roll direction for this plane. PLANE_ON_CURVE has priority over ROLL if this is not set.",
			"calledOn": "plane",
			"parameters": [
				{
					"name": "number",
					"description": "The number of rolls",
					"mandatory": true
				},
				{
					"name": "time",
					"description": "The goal roll time",
					"mandatory": false
				}
			],
			"example": "level.plane SetPlaneBarrelRoll( 1, 5.0f )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetPlaneGoalPos",
			"description": "Set the target position, speed, angles for this vehicle.",
			"calledOn": "plane",
			"parameters": [
				{
					"name": "goal position",
					"description": "The goal position",
					"mandatory": true
				}
			],
			"example": "plane Setplanegoalpos( ( 200, 200, 200 ), ( 30, 0, 90 ), 170.0 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetRotorSpeed",
			"description": "Sets the helicopters rotor speed.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "speed",
					"description": "The rotor speed, 0 is stopped 1 is full speed.",
					"mandatory": true
				}
			],
			"example": "heli SetRotorSpeed( 0.2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSeatOccupied",
			"description": "Sets this seat to be occupied/disabled (for players.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "seat",
					"description": "0 driver, 1-4 gunners, 5-10 passengers",
					"mandatory": true
				},
				{
					"name": "onoff",
					"description": "true to enable, false otherwise",
					"mandatory": false
				}
			],
			"example": "vehicle SetSeatOccupied( 2, true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpeed",
			"description": "Sets the speed and acceleration for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "speed",
					"description": "The speed of the vehicle in miles per hour",
					"mandatory": true
				},
				{
					"name": "acceleration",
					"description": "The acceleration of the vehicle in miles per hour per second",
					"mandatory": false
				},
				{
					"name": "deceleration",
					"description": "Deceleration. If not specified, set to be equal to half of accleration",
					"mandatory": false
				}
			],
			"example": "self SetSpeed( 60, 15, 5 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSpeedImmediate",
			"description": "Sets the speed and acceleration for this vehicle instantaneously. Direction will be toward the goal direction if there is a goal, otherwise the current direction.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "speed",
					"description": "The speed of the vehicle in miles per hour",
					"mandatory": true
				},
				{
					"name": "acceleration",
					"description": "The acceleration of the vehicle in miles per hour per second",
					"mandatory": false
				},
				{
					"name": "deceleration",
					"description": "Deceleration. If not specified, set to be equal to half of accleration",
					"mandatory": false
				}
			],
			"example": "self setspeedimmediate(60, 15, 5)",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetSwitchNode",
			"description": "Sets a switch node for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "source node",
					"description": "The switch source node",
					"mandatory": true
				},
				{
					"name": "dest node",
					"description": "The switch destination node.",
					"mandatory": true
				}
			],
			"example": "tank2 SetSwitchNode( tank2snode1, tank2snode2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTargetYaw",
			"description": "Set the target yaw direction for this vehicle. Goal yaw has priority over target yaw.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "yaw",
					"description": "The yaw direction of the target",
					"mandatory": true
				}
			],
			"example": "level.flak1 SetTargetYaw( vec1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurningAbility",
			"description": "If this is higher, helicopters can make sharper turns to match goal positions better.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "turning ability",
					"description": "Between 0.001 and 1.0. Defaults to 0.5",
					"mandatory": true
				}
			],
			"example": "self SetTurningAbility( 0.9 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretTargetEnt",
			"description": "Set the target entity for this vehicle turret.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "target entity",
					"description": "The target.",
					"mandatory": true
				},
				{
					"name": "target offset",
					"description": "The target offset.",
					"mandatory": false
				}
			],
			"example": "eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretTargetRelativeAngles",
			"description": "Set the target entity for this vehicle turret.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "relative angles",
					"description": "The target angle",
					"mandatory": true
				},
				{
					"name": "turret index",
					"description": "0 for turret, 1-4 for gunners",
					"mandatory": false
				}
			],
			"example": "eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetTurretTargetVec",
			"description": "Set the target position for this vehicle turret.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "target position",
					"description": "The position of the target",
					"mandatory": true
				}
			],
			"example": "level.flak1 SetTurretTargetVec( vec1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehGoalPos",
			"description": "Set the target position for this vehicle. Returns true if it can find a path.  If it fails to find a path the vehicle will be stopped.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "goalpos",
					"description": "The goal position",
					"mandatory": true
				},
				{
					"name": "stopAtGoal",
					"description": "Whether the vehicle should slow down to stop at the goal position",
					"mandatory": false
				},
				{
					"name": "usepath",
					"description": "set to 1 to use pathfinding",
					"mandatory": false
				}
			],
			"example": "tank SetVehGoalPos( (0, 0, 0), 1 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleAvoidance",
			"description": "Turns on and off vehicle avoidance",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "True to enable avoidance, false otherwise",
					"mandatory": true
				},
				{
					"name": "radius",
					"description": "The avoidance radius",
					"mandatory": false
				},
				{
					"name": "priority",
					"description": "Vehicles will avoid everything that is the same priority or higher.  Default priority is 1.",
					"mandatory": false
				}
			],
			"example": "vehicle SetVehicleAvoidance( true, 50 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleForDropDeploy",
			"description": "Set vehicle properties so that it can be dropped into a map.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "raps SetVehicleForDropDeploy()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleManualControl",
			"description": "Turns on and off vehicle hkai behavior. Not to be confused with UseVehicle()",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "enabled",
					"description": "True to enable vehicle  hkai behavior, false otherwise",
					"mandatory": true
				}
			],
			"example": "vehicle SetVehicleManualControl( true )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehicleType",
			"description": "Sets the vehicles type.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "type",
					"description": "The type name",
					"mandatory": true
				}
			],
			"example": "plane SetVehicleType(\"f35_vtol\")",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehMaxSpeed",
			"description": "overrides the max speed for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "speed",
					"description": "The speed to set",
					"mandatory": true
				}
			],
			"example": "self SetVehMaxSpeed( 45 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehVelocity",
			"description": "Sets the linear velocity on a vehicle/s.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "velocity",
					"description": "The vehicle velocity",
					"mandatory": true
				}
			],
			"example": "self SetVehVelocity( (45, 0, 0) )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetVehWeapon",
			"description": "Set the vehicle's weapon",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "weapon name",
					"description": "The name of the weapon",
					"mandatory": true
				}
			],
			"example": "chopper setVehWeapon( \"AGM_114\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SetYawSpeed",
			"description": "Sets the yaw speed for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "speed",
					"description": "The speed of the vehicle in angles per second",
					"mandatory": true
				},
				{
					"name": "acceleration",
					"description": "The acceleration of the vehicle in angles per second^2",
					"mandatory": true
				},
				{
					"name": "deceleration",
					"description": "Deceleration. If not specified, set to be equal to acceleration",
					"mandatory": false
				}
			],
			"example": "self SetYawSpeed( 120, 60 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StartPath",
			"description": "Starts the vehicle following this path.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "bomber StartPath()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "StopFireWeapon",
			"description": "Stop firing the vehicle's main weapon",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "nFlak StopFireWeapon()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "SwitchStartNode",
			"description": "Swaps the start node for this vehicle.",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "source node",
					"description": "The start source node",
					"mandatory": true
				},
				{
					"name": "dest node",
					"description": "The start destination node.",
					"mandatory": true
				}
			],
			"example": "tank2 SwitchStartNode( tank2snode1, tank2snode2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "TakePlayerControl",
			"description": "You call this function to take control away from a player.",
			"calledOn": "vehicle",
			"parameters": [],
			"example": "cobra TakePlayerControl()",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "UseVehicle",
			"description": "same as useby except you can specify a seat, 0 driver, 1-4 gunners",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "user entity",
					"description": "The player to use the vehicle",
					"mandatory": true
				},
				{
					"name": "seat",
					"description": "0 driver, 1-4 gunners, 5-10 passengers",
					"mandatory": true
				}
			],
			"example": "lvt usevehicle( player, 2 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "VehDriverAimAtCrosshairs",
			"description": "Enables or disables the driver turret aiming at the crosshairs (aiming at the crosshairs overrides all other aim targets and is the default behavior)",
			"calledOn": "vehicle",
			"parameters": [
				{
					"name": "AimAtCrosshairs",
					"description": "True to aim the turret at the crosshairs",
					"mandatory": true
				}
			],
			"example": "vehicle VehDriverAimAtCrosshairs( false )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "EnumerateWeapons",
			"description": "Return an array of weapon names for the weapons of weapon type in fastfile",
			"calledOn": null,
			"parameters": [
				{
					"name": "weapon type",
					"description": "The type of weapon to return(weapon or weaponfull)",
					"mandatory": true
				}
			],
			"example": "a_weapons = EnumerateWeapons( \"weapon\" )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_CreateAttractorEnt",
			"description": "Creates a missile attractor at the origin of an entity",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity that is to be an attractor",
					"mandatory": true
				},
				{
					"name": "strength",
					"description": "The strength of the attractor (maximum acceleration it can apply to a missile)",
					"mandatory": true
				},
				{
					"name": "affectdist",
					"description": "The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.",
					"mandatory": true
				},
				{
					"name": "affectAllProjectiles",
					"description": "If set it will affect all projectiles inculding grenades and guided missiles.",
					"mandatory": false
				},
				{
					"name": "alert range",
					"description": "If set it send notify when missile breaches range(but will not repulse).",
					"mandatory": false
				}
			],
			"example": "attractor = Missile_CreateAttractorEnt( enemy_chopper, 10000, 6000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_CreateAttractorOrigin",
			"description": "Creates a missile attractor at the given location",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The center of the attractor",
					"mandatory": true
				},
				{
					"name": "strength",
					"description": "The strength of the attractor (maximum acceleration it can apply to a missile)",
					"mandatory": true
				},
				{
					"name": "affectDist",
					"description": "The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.",
					"mandatory": true
				},
				{
					"name": "affectAllProjectiles",
					"description": "If set it will affect all projectiles inculding grenades and guided missiles.",
					"mandatory": false
				},
				{
					"name": "alert range",
					"description": "If set it send notify when missile breaches range(but will not repulse).",
					"mandatory": false
				}
			],
			"example": "attractor = Missile_CreateAttractorOrigin( (100, 350, 10), 10000, 6000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_CreateRepulsorEnt",
			"description": "Creates a missile repulsor at the origin of an entity",
			"calledOn": null,
			"parameters": [
				{
					"name": "entity",
					"description": "The entity that is to be a repulsor",
					"mandatory": true
				},
				{
					"name": "strength",
					"description": "The strength of the repulsor (maximum acceleration it can apply to a missile)",
					"mandatory": true
				},
				{
					"name": "affectDist",
					"description": "The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.",
					"mandatory": true
				},
				{
					"name": "affectAllProjectiles",
					"description": "If set it will affect all projectiles inculding grenades and guided missiles.",
					"mandatory": false
				},
				{
					"name": "alert range",
					"description": "If set it send notify when missile breaches range(but will not repulse).",
					"mandatory": false
				}
			],
			"example": "repulsor = Missile_CreateRepulsorEnt( enemy_chopper, 10000, 6000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_CreateRepulsorOrigin",
			"description": "Creates a missile Repulsor at the given location",
			"calledOn": null,
			"parameters": [
				{
					"name": "origin",
					"description": "The center of the Repulsor",
					"mandatory": true
				},
				{
					"name": "strength",
					"description": "The strength of the Repulsor (maximum acceleration it can apply to a missile)",
					"mandatory": true
				},
				{
					"name": "affectDist",
					"description": "The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.",
					"mandatory": true
				},
				{
					"name": "affectAllProjectiles",
					"description": "If set it will affect all projectiles inculding grenades and guided missiles.",
					"mandatory": false
				},
				{
					"name": "alert range",
					"description": "If set it send notify when missile breaches range(but will not repulse).",
					"mandatory": false
				}
			],
			"example": "repulsor = Missile_CreateRepulsorOrigin( (100, 350, 10), 10000, 6000 )",
			"flags": [
				"autogenerated"
			]
		},
		{
			"name": "Missile_DeleteAttractor",
			"description": "Deletes a missile attractor or repulsor",
			"calledOn": null,
			"parameters": [
				{
					"name": "attractor",
					"description": "The attractor or repulsor",
					"mandatory": true
				}
			],
			"example": "Missile_DeleteAttractor( attractor )",
			"flags": [
				"autogenerated"
			]
		}
	]
}