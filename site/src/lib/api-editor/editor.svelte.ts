import type { ScrFunction, ScrLibrary } from '$lib/models/library';
import { getContext, setContext } from 'svelte';
import { FunctionEditor } from './function-editor.svelte';

/**
 * Main editor class that manages the entire API library editing session.
 */
export class Editor {
	library = $state<ScrLibrary>() as ScrLibrary;
	functions = $state<Map<string, FunctionEditor>>(new Map());

	/** Reactive statistics about function verification and validation status */
	readonly stats = $derived.by(() => {
		let autogeneratedCount = 0;
		let invalidCount = 0;
		let verifiedCount = 0;
		let editedCount = 0;
		let badVerificationCount = 0;

		for (const fn of this.functions.values()) {
			if (fn.isUnverified) {
				autogeneratedCount++;
			}
			if (fn.isInvalid) {
				invalidCount++;
				if (fn.isVerified) {
					badVerificationCount++;
				}
			}
			if (fn.isVerified) {
				verifiedCount++;
			}
			if (fn.edited) {
				editedCount++;
			}
		}

		return {
			autogeneratedCount,
			invalidCount,
			verifiedCount,
			editedCount,
			badVerificationCount
		};
	});

	private constructor(library: ScrLibrary) {
		this.updateLibrary(library);
	}

	/**
	 * Updates the editor with a new library definition.
	 */
	updateLibrary(library: ScrLibrary) {
		this.library = library;
		this.functions = new Map();

		for (const fn of library.api) {
			this.functions.set(fn.name.toLowerCase(), new FunctionEditor(fn));
		}
	}

	/**
	 * Exports the current state of the library.
	 * If any functions have been edited, increments the revision and updates the revisedOn date.
	 */
	exportLibrary(): ScrLibrary {
		const edited = Array.from(this.functions.values()).some((fn) => fn.edited);
		const newApi = Array.from(this.functions.values()).map((fn) => fn.function);

		let newRevision = this.library.revision;
		let newRevisedOn = this.library.revisedOn;

		if (edited) {
			newRevision++;
			newRevisedOn = new Date();
		}

		return {
			...this.library,
			api: newApi,
			revision: newRevision,
			revisedOn: newRevisedOn
		};
	}

	/**
	 * Creates an Editor instance from a loaded library.
	 */
	static fromLibrary(library: ScrLibrary): Editor {
		return new Editor(library);
	}

	/**
	 * Gets the FunctionEditor for a given function name.
	 */
	getFunction(name: string | undefined): FunctionEditor | undefined {
		if (!name) {
			return undefined;
		}
		return this.functions.get(name.toLowerCase());
	}
}

const EDITOR_CTX_KEY = Symbol('editor');

export function setEditorContext(editor: Editor) {
	setContext(EDITOR_CTX_KEY, editor);
}

export function getEditorContext(): Editor {
	const editor = getContext<Editor>(EDITOR_CTX_KEY);
	if (!editor) {
		throw new Error('Editor context not found');
	}
	return editor;
}
