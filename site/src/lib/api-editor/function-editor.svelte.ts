import type { ScrDataType, ScrFunction, ScrReturnValue } from '$lib/models/library';
import { validateFunction } from './validation';

/**
 * Wraps an individual function with editor state and validation.
 */
export class FunctionEditor {
	function: ScrFunction = $state() as any;
	private readonly _originalFunction: string;

	/** List of validation error messages for this function */
	readonly validationErrors = $derived(validateFunction(this.function));

	/** Whether this function's definition passes validation */
	readonly isValid = $derived(this.validationErrors.length === 0);

	/** Whether this function is verified (has 'verified' flag) */
	readonly isVerified = $derived(this.function?.flags.includes('verified') ?? false);

	/** Whether this function is unverified (does not have 'verified' flag) */
	readonly isUnverified = $derived(!this.isVerified);

	/** Whether this function is invalid (fails validation) */
	readonly isInvalid = $derived(!this.isValid);

	readonly edited = $derived.by(() => {
		if (!this.function || !this._originalFunction) return false;
		return JSON.stringify(this.function) !== this._originalFunction;
	});

	constructor(fn: ScrFunction) {
		this.function = fn;
		this._originalFunction = JSON.stringify(fn);
	}

	setName(name: string) {
		this.function.name = name;
	}

	setDescription(description: string) {
		this.function.description = description || null;
	}

	setExample(example: string) {
		this.function.example = example || null;
	}

	toggleFlag(flag: string) {
		if (this.function.flags.includes(flag)) {
			this.function.flags = this.function.flags.filter((f) => f !== flag);
		} else {
			let newFlags = [...this.function.flags, flag];
			// Enforce mutual exclusivity for autogenerated and verified
			if (flag === 'verified') {
				newFlags = newFlags.filter((f) => f !== 'autogenerated');
			} else if (flag === 'autogenerated') {
				newFlags = newFlags.filter((f) => f !== 'verified');
			}
			this.function.flags = newFlags;
		}
	}

	// --- Returns editing methods ---

	private ensureReturns(overloadIndex: number): ScrReturnValue {
		const overload = this.function.overloads[overloadIndex];
		overload.returns ??= { void: true };
		return overload.returns;
	}

	setReturnsVoid(overloadIndex: number, isVoid: boolean) {
		const returns = this.ensureReturns(overloadIndex);
		if (isVoid) {
			// Clear type info when setting to void
			returns.void = true;
			returns.type = null;
			returns.name = null;
			returns.description = null;
		} else {
			returns.void = false;
		}
		// Trigger reactivity by reassigning the overloads array
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsType(overloadIndex: number, type: ScrDataType | null) {
		const returns = this.ensureReturns(overloadIndex);
		returns.type = type;
		returns.void = false;
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsName(overloadIndex: number, name: string) {
		const returns = this.ensureReturns(overloadIndex);
		returns.name = name || null;
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsDescription(overloadIndex: number, description: string) {
		const returns = this.ensureReturns(overloadIndex);
		returns.description = description || null;
		this.function.overloads = [...this.function.overloads];
	}
}
