import type { ScrFunction } from '$lib/models/library';
import { validateFunction } from './validation';

/**
 * Wraps an individual function with editor state and validation.
 */
export class FunctionEditor {
	function: ScrFunction = $state() as any;
	private readonly _originalFunction: string;

	/** List of validation error messages for this function */
	readonly validationErrors = $derived(validateFunction(this.function));

	/** Whether this function's definition passes validation */
	readonly isValid = $derived(this.validationErrors.length === 0);

	/** Whether this function is verified (has 'verified' flag) */
	readonly isVerified = $derived(this.function?.flags.includes('verified') ?? false);

	/** Whether this function is unverified (does not have 'verified' flag) */
	readonly isUnverified = $derived(!this.isVerified);

	/** Whether this function is invalid (fails validation) */
	readonly isInvalid = $derived(!this.isValid);

	readonly edited = $derived.by(() => {
		if (!this.function || !this._originalFunction) return false;
		return JSON.stringify(this.function) !== this._originalFunction;
	});

	constructor(fn: ScrFunction) {
		this.function = fn;
		this._originalFunction = JSON.stringify(fn);
	}

	setName(name: string) {
		this.function.name = name;
	}

	toggleFlag(flag: string) {
		if (this.function.flags.includes(flag)) {
			this.function.flags = this.function.flags.filter((f) => f !== flag);
		} else {
			let newFlags = [...this.function.flags, flag];
			// Enforce mutual exclusivity for autogenerated and verified
			if (flag === 'verified') {
				newFlags = newFlags.filter((f) => f !== 'autogenerated');
			} else if (flag === 'autogenerated') {
				newFlags = newFlags.filter((f) => f !== 'verified');
			}
			this.function.flags = newFlags;
		}
	}
}
