import type { ScrFunction, ScrFunctionOverload } from '$lib/models/library';

/**
 * Validates a function definition and returns a list of error messages.
 * 
 * Stricter rules apply if the function has the 'verified' flag.
 */
export function validateFunction(fn: ScrFunction): string[] {
	const errors: string[] = [];
	const isVerified = fn.flags.includes('verified');

	errors.push(...validateName(fn));
	errors.push(...validateFlags(fn));
	errors.push(...validateDescription(fn));

	fn.overloads.forEach((overload, index) => {
		const prefix = fn.overloads.length > 1 ? `Overload ${index + 1}: ` : '';
		errors.push(...validateOverload(overload, isVerified, prefix));
	});

	return errors;
}

function validateName(fn: ScrFunction): string[] {
	const errors: string[] = [];
	if (fn.name && fn.name[0] !== fn.name[0].toUpperCase()) {
		errors.push('Name: should be approx. PascalCase.');
	}
	return errors;
}

function validateFlags(fn: ScrFunction): string[] {
	const errors: string[] = [];
	if (fn.flags.includes('autogenerated') && fn.flags.includes('verified')) {
		errors.push('Flags: cannot be both autogenerated and verified.');
	}
	return errors;
}

function validateDescription(fn: ScrFunction): string[] {
	const errors: string[] = [];
	if (!fn.description || fn.description === 'No description.') {
		errors.push('Description: missing or default.');
	}
	return errors;
}

function validateOverload(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];

	errors.push(...validateCalledOn(overload, isVerified, prefix));
	errors.push(...validateParameters(overload, isVerified, prefix));
	errors.push(...validateReturns(overload, isVerified, prefix));

	return errors;
}

function validateCalledOn(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	if (overload.calledOn) {
		if (!overload.calledOn.name || overload.calledOn.name === 'unknown') {
			errors.push(`${prefix}Called on entity: unknown name.`);
		}
		if (isVerified) {
			if (!overload.calledOn.description) {
				errors.push(`${prefix}Called on entity: description missing.`);
			}
			if (!overload.calledOn.type?.dataType) {
				errors.push(`${prefix}Called on entity: type missing.`);
			}
		}
	}
	return errors;
}

function validateParameters(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	overload.parameters.forEach((param, pIndex) => {
		const pName = param.name || 'unknown';
		const pLabel = `Parameter ${pIndex + 1}`;

		if (pName === 'unknown') {
			errors.push(`${prefix}${pLabel}: unknown name.`);
		}

		if (isVerified) {
			if (!param.description) {
				errors.push(`${prefix}${pLabel}: description missing.`);
			}
			if (!param.type?.dataType) {
				errors.push(`${prefix}${pLabel}: type missing.`);
			}
		}
	});
	return errors;
}

function validateReturns(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	if (isVerified) {
		if (!overload.returns) {
			errors.push(`${prefix}Return value section: missing.`);
		} else if (!overload.returns.void && !overload.returns.type?.dataType) {
			errors.push(`${prefix}Return value: type missing.`);
		}
	}
	return errors;
}
