/**
	GSCode Language Extension for Visual Studio Code
    Copyright (C) 2022 Blakintosh

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import { LibraryFunction } from "./LibraryFunction";
import { LibraryFunctionParameter } from "./LibraryFunctionParameter";
import { LibraryCompletionItemLabel } from "./LibraryCompletionItemLabel";
import * as vscode from "vscode";
import { FunctionFlag } from "../util/GSCUtil";

/**
 * Class that will store the built in functions that GSC/CSC provide.
 */
export class Library {
	// Used for completion suggestions
	static gscFunctionArray: Array<vscode.CompletionItem>;
	static cscFunctionArray: Array<vscode.CompletionItem>;
	// Use for fast lookup (e.g. for hover)
	static gscFunctionMap: Map<String, LibraryFunction>;
	static cscFunctionMap: Map<String, LibraryFunction>;

	/**
	 * Loads all GSC built in functions to the provider
	 */
	static init(): void {
		this.gscFunctionArray = new Array<vscode.CompletionItem>();
		this.cscFunctionArray = new Array<vscode.CompletionItem>();
		this.gscFunctionMap = new Map<String, LibraryFunction>();
		this.cscFunctionMap = new Map<String, LibraryFunction>();

		/* If you are editing this list please pay careful attention to use each parameter correctly, they are as follows: 
		 name (This is what will get an autocompletion suggestion)
		 description (The description for this function)
		 calledOn (What entity this should be called on, otherwise null if this does not apply)
		 parameters (An array containing the parameters of this function)
		 isGSC (Whether this should be accessible in a GSC file)
		 isCSC (Whether this should be accessible in a CSC file)
		 example (An example of this function in use if it applies, if there are no examples, omit this parameter)
		 flag (Due to Treyarch API errors, flags can specify the nature of this function. By default the AutoGenerated flag is set.)
		 	- If the function works and you've verified its parameters are correct (and any grammatical issues etc. have been fixed), remove the flag parameter.
			- If the function is explicitly marked as deprecated in its docs, change the flag to Deprecated.
			- If the function isn't the above but doesn't work anyway, change the flag to Broken.
			- If the function has utility in stock BO3 but is effectively useless for modders, change the flag to Useless.
		BEFORE UNSETTING AUTOGENERATED YOU SHOULD TEST THAT THE CURRENT DOCUMENTATION WORKS. NOT ALL FUNCTION DOCS ARE CORRECT.

		For the sake of organisation
		- After manual verification, move the function into its respective "Manually verified" area in this file, in alphabetical order
		- Follow PascalCase naming conventions for the function name. (e.g. IPrintLnBold, not iprintlnbold or iPrintLnBold)
		- If a function is available in both GSC and CSC but has different parameters or functionality, split them into two add calls
		- Please make all descriptions use sentence structure.
		GitHub forks that commit function verification/correction will be accepted as long as they follow the above conventions
		 */

		/**
		 * Function verification/correction credits: -
		 */

		// Manually verified: Both
		this.addFunction(new LibraryFunction("SpawnStruct", `Creates a struct instance, which can have properties applied on it.`, null, [], true, true, `obj = SpawnStruct(); obj.foo = bar;`)); // Verified & corrected 06/06/2022

		// Manually verified: GSC
		this.addFunction(new LibraryFunction("GetPlayers", `Returns an array of the currently connected players.  Used internally to the script call get_players().`, null, [new LibraryFunctionParameter("team", `Specific team to get the players of. Valid values are "allies", "axis", "neutral" & "all".`, false)], true, false, `players = GetPlayers()`)); // Verified 06/06/2022
		this.addFunction(new LibraryFunction("IPrintLn", `Writes a line to the bottom left corner of the screen.`, null, [new LibraryFunctionParameter("text", `Text to be written.`, true)], true, false, `IPrintLn( "Where have all the cowboys gone?" )`)); // Verified 06/06/2022
		this.addFunction(new LibraryFunction("IPrintLnBold", `Writes a line to the center of the screen.`, null, [new LibraryFunctionParameter("text", `Text to be written.`, true)], true, false, `IPrintLnBold( "Mitchell!" )`)); // Verified 06/06/2022
		this.addFunction(new LibraryFunction("IsWeaponOverheating", `Returns whether the player's weapon is overheating, or the current heat level of the player's weapon.`, "player", [new LibraryFunctionParameter("get heatval", `If positive, the function returns the heat percent of the weapon (0 to 100).`, false), new LibraryFunctionParameter("weapon", `Specific weapon to check the heat of, otherwise the player's current weapon.`, false)], true, false, `self IsWeaponOverheating()`)); // Verified 16/07/2022
		
		// Manually verified: CSC
		this.addFunction(new LibraryFunction("IPrintLnBold", `Writes a line to the bottom left corner of the screen.`, null, [new LibraryFunctionParameter("text", `Text to be written.`, true)], false, true, `IPrintLnBold( "Mitchell!" )`)); // Verified 06/06/2022
		this.addFunction(new LibraryFunction("IsWeaponOverheating", `Returns whether the player's weapon is overheating, or the current heat level of the player's weapon.`, "player", [new LibraryFunctionParameter("localClientNum", `The local client number of the player.`, true), new LibraryFunctionParameter("get heatval", `If positive, the function returns the heat percent of the weapon (0 to 100).`, false), new LibraryFunctionParameter("weapon", `Specific weapon to check the heat of, otherwise the player's current weapon.`, false)], false, true, `self IsWeaponOverheating()`)); // Verified 16/07/2022
		

		// Auto-generated: Either
		this.addFunction(new LibraryFunction("ActivateClientExploder", `Activates a client side exploderThis is sent as a reliable command, and will not work with killcam or demos.`, null, [new LibraryFunctionParameter("exploder id", `id of exploder to activate`, true)], true, false, `ActivateClientExploder( 101 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActivateClientRadiantExploder", `Activates a client side radiant exploder`, null, [new LibraryFunctionParameter("exploder id", `string id of exploder to activate`, true)], true, false, `ActivateClientRadiantExploder( "light_switch" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActorIKEnabled", `Determines whether this actor can use IK functions. Returns true if IK is available, otherwise false.`, "actor", [], true, false, `if (guy ActorIKEnabled()) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddAwarenessIndicator", `Draw an awareness indicator`, null, [new LibraryFunctionParameter("pos", `awareness location`, true), new LibraryFunctionParameter("material", `awareness material`, true)], false, true, `AddAwarenessIndicator(ai.origin, "hit_material_green" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddBonusCardStat", `Sets the indicated stat for that bonus card`, "player", [new LibraryFunctionParameter("bonuscard", `Bonus Card define from _bonuscards.gsh`, true), new LibraryFunctionParameter("statname", `The name of the stat you wish to set`, true), new LibraryFunctionParameter("statincrease", `The amount you would like to increase the stat`, true), new LibraryFunctionParameter("currentclassnum", `The loadout the player is using`, true)], true, false, `self AddBonusCardStat( BONUSCARD_OVERKILL, "kills", 1, self.class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddDemoBookmark", `adds the information to the demo bookmarking system`, null, [new LibraryFunctionParameter("type", `the type of bookmark`, true), new LibraryFunctionParameter("time", `the time of recording the bookmark`, true), new LibraryFunctionParameter("client1", `the client related to the bookmark`, true), new LibraryFunctionParameter("client2", `other client which is associated with the bookmark`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("entityNumber", `The entity number`, true), new LibraryFunctionParameter("eType", `Entity type`, true), new LibraryFunctionParameter("birthTime", `Birth Time`, true), new LibraryFunctionParameter("overrideEntityCamera", `Whether to override Entity Camera`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `AddDemoBookmark( bookmark_string, gettime(), self GetEntityNumber(), 255, 0, inflictorEntNum, inflictorEntType, inflictorBirthTime, false, self.grenade_multiattack_ent GetEntityNumber() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddEntityInfluencer", `Adds a new influencer of <name> attached to <entity>`, null, [new LibraryFunctionParameter("name", `valid spawn influencer preset name.`, true), new LibraryFunctionParameter("entity", `Attached to entity.  Goes away when entity is deleted. Unless a time is set.`, true), new LibraryFunctionParameter("team mask", `teams that this influencer will affect`, true)], true, false, `influencer_id = AddEntityInfluencer( name, player, allies_mask )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddFriendlyScrambler", `Adds new friendly scrambler to the compass`, "player", [new LibraryFunctionParameter("x", `X coord (float)`, true), new LibraryFunctionParameter("y", `Y coord (float)`, true), new LibraryFunctionParameter("handle", `will be used to remove the scrambler (integer)`, true)], false, true, `player AddFriendlyScrambler( scrambler.origin[0], scrambler.origin[1], scrambler.handle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddInfluencer", `Adds a new influencer of <name> at <origin>`, null, [new LibraryFunctionParameter("name", `valid spawn influencer preset name.`, true), new LibraryFunctionParameter("origin", `center point of the influencer`, true), new LibraryFunctionParameter("team mask", `teams that this influencer will affect`, true)], true, false, `influencer_id = AddInfluencer( name, origin, allies_mask )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddOrientedInfluencer", `Adds a new influencer of <name> at <origin> and <angles>`, null, [new LibraryFunctionParameter("name", `valid spawn influencer preset name.`, true), new LibraryFunctionParameter("origin", `center point of the influencer`, true), new LibraryFunctionParameter("angles", `angles of entity`, true), new LibraryFunctionParameter("team mask", `teams that this influencer will affect`, true)], true, false, `influencer_id = AddOrientedInfluencer( name, origin, angles, allies_mask )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddSensorGrenadeArea", `Adds new sensor grenade radius indicator to the compass`, "player", [new LibraryFunctionParameter("position", `origin`, true), new LibraryFunctionParameter("handle", `will be used to remove the sensor`, true)], false, true, `player AddSensorGrenadeArea( sensor.origin, sensor.handle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddSpawnPoints", `Adds spawnpoints to the spawn system`, null, [new LibraryFunctionParameter("team", `The team`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `AddSpawnPoints( "allies", "mp_tdm_spawn" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddTestClient", `Adds a test client to the map and returns a reference to that client.`, null, [], true, false, `ent[i] = AddTestClient()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddToInterestPool", `Add a script event to the sentient's interest pool.`, null, [new LibraryFunctionParameter("value", `Amount the event adds to the pool. (integer)`, true), new LibraryFunctionParameter("priority", `How important is the event. (integer)`, true), new LibraryFunctionParameter("lifespan", `Time the event stays in the pool. (float)`, true), new LibraryFunctionParameter("point of interest", `Position the AI will investigate. (vector3)`, true), new LibraryFunctionParameter("originator", `Entity that caused the event.`, true), new LibraryFunctionParameter("unique", `Only one of this type can exist in the pool. (integer)`, false)], true, false, `point = self AddToInterestPool( 500, 10, 5, ai.origin, ai )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddZombieBoxWeapon", `Adds a zombie box weapon`, null, [new LibraryFunctionParameter("weapon", `The weapon to add`, true), new LibraryFunctionParameter("weaponModelName", `The model name of the weapon`, true), new LibraryFunctionParameter("isDualWield", `True if the weapon is dual wield, false otherwise`, true)], false, true, `AddZombieBoxWeapon( weapon, weapon.worldModel, weapon.isDualWield )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AimAtEntityIK", `Set this actor to aim at the specified entity. Call this function without any entity specified to turn it off.`, "actor", [new LibraryFunctionParameter("otherguy", `the other guy to aim at`, false)], true, false, `guy AimAtEntityIK( otherguy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AimAtPosIK", `Set this actor to aim at the specified position. Call this function without any position specified to turn it off.`, "actor", [new LibraryFunctionParameter("pos", `the position to aim at`, false)], true, false, `guy AimAtPosIK( pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AimingAtFriendly", `Returns true if localclient 0 has crosshairs on friendly`, null, [], false, true, `isFriend = AimingAtFriendly()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllClientsPrint", `Cause all clients to print the localized version of this string.`, null, [new LibraryFunctionParameter("string", `the string to print`, true)], true, false, `AllClientsPrint( "Game Complete" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllocateSoundRandoms", `Allocate a pool of random sounds`, null, [new LibraryFunctionParameter("num randoms", `number of randoms`, true)], false, true, `AllocateSoundRandoms(randoms.size - nScriptThreadedRandoms)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowActionSlotInput", `always allow action slot input`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you to enable the action slots`, true)], false, true, `AllowActionSlotInput(localclientnum)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowedStances", `Sets the list of the actor's allowed stances.`, "actor_or_player", [new LibraryFunctionParameter("stance", `(string) A stance, can be 'prone', 'crouch', 'stand'. Any number of stances may be added.`, true)], true, false, `self AllowedStances( "crouch", "prone" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowRoundAnimation", `sets the allow round animation flag to enabled or disabled`, null, [new LibraryFunctionParameter("flag", `1 to allow, 0 to disallow`, true)], false, true, `AllowRoundAnimation( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowScoreboard", `allow scoreboard or not`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you to enable the action slots`, true)], false, true, `AllowScoreboard(localclientnum)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowTacticalInsertion", `If false, disallows tactical insertions in the bounding area of this entity. Allows tactical insertions otherwise`, "entity", [new LibraryFunctionParameter("allow", `true or false`, true)], true, false, `my_trigger AllowTacticalInsertion( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllWeaponAttachmentsUnlocked", `Are all the weapon attachments unlocked for this weapon?`, null, [new LibraryFunctionParameter("weapon", `weapon`, true)], true, false, `player AllWeaponAttachmentsUnlocked( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnimHasNotetrack", `queries the given animation for a note track`, null, [new LibraryFunctionParameter("animation", `an animation`, true), new LibraryFunctionParameter("note track", `a constant string with the name of the note track`, true)], true, false, `if ( IsDefined( facialanim ) && AnimHasNotetrack( facialanim, "dialogue" ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnimMappingSearch", `Searches animation mapping table to return a animation name when given a animation mapping alias name.`, "actor", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `self AnimMappingSearch("anim_arrive_cover_left_crouch")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnimRelative", `Runs an animscript on an entity.`, "entity", [new LibraryFunctionParameter("notify", `The notify to send`, true), new LibraryFunctionParameter("origin", `The starting position of the anim script`, true), new LibraryFunctionParameter("angles", `The starting angle of the anim script`, true), new LibraryFunctionParameter("animation", `The animation`, true), new LibraryFunctionParameter("mode", `Valid modes are "normal" and "deathplant"`, false), new LibraryFunctionParameter("root", `The root animation`, false)], true, false, `driver AnimRelative( "germantruck_driver_closedoor", org , angles, driver.closedooranim )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnimScripted", `Runs an animscript on an entity.`, "entity", [new LibraryFunctionParameter("notify", `The notify to send`, true), new LibraryFunctionParameter("origin", `The starting position of the anim script`, true), new LibraryFunctionParameter("angles", `The starting angle of the anim script`, true), new LibraryFunctionParameter("animation", `The animation`, true), new LibraryFunctionParameter("mode", `Valid modes are "normal" and "deathplant"`, false), new LibraryFunctionParameter("root", `The root animation`, false), new LibraryFunctionParameter("rate", `The playback rate of animation`, false), new LibraryFunctionParameter("blend", `The blend time for the animation`, false), new LibraryFunctionParameter("lerp", `The lerp time for an aligned animation`, false), new LibraryFunctionParameter("animation time", `The starting animation time in 0-1 range`, false), new LibraryFunctionParameter("is_scene_animation", `Should be true for player scene animations or scripted animations where the player has no control, can be ignored for non-players`, false), new LibraryFunctionParameter("showPlayerWeaponInFirstPerson", `determines if the first person player should have his weapon during cinematics`, false)], true, false, `driver AnimScripted( "germantruck_driver_closedoor", org , angles, driver.closedooranim )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Announcement", `Sends an announcement to all clients.`, null, [new LibraryFunctionParameter("string", `The announcement.`, true), new LibraryFunctionParameter("duration", `How long, in seconds, to display the announcement.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ApplyBallisticTarget", `Launch a vehicle with just enough force at a target.`, "entity", [new LibraryFunctionParameter("targetPos", `The position to launch the vehicle towards`, true)], true, false, `dropRaps ApplyBallisticTarget( (50,50,10) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AreAllMissionsAtScore", `Returns true if all missions are at the score specified`, "player", [new LibraryFunctionParameter("score", `A score that all missions must be at to return true (integer)`, true)], true, false, `is_score_achieved = self AreAllMissionsAtScore( 10000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AreMeshesStreamed", `Returns true if this entity's meshes are streamed in`, "entity", [], false, true, `thing areMeshesStreamed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("arenagetcurrentseason", `Returns the current arena season`, null, [], true, false, `ArenaGetCurrentSeason()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArenaGetSlot", `Returns the current arena slot`, null, [], true, false, `ArenaGetSlot()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AreTexturesLoaded", `Check to see if start-of-level textures are loaded - if they're not, the streamer forces a black screen.`, null, [], true, false, `while( !areTexturesLoaded() ) { wait(0.05); }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AreTexturesStreamed", `Returns true if this entity's textures are streamed in`, "entity", [], false, true, `thing areTexturesStreamed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArraySort", `Returns a sorted array of entities by closest or farthest distance from <origin>`, null, [new LibraryFunctionParameter("array", `array to sort`, true), new LibraryFunctionParameter("origin", `the origin from which to compare`, true), new LibraryFunctionParameter("closest", `if set to true the array will be sorted by distance closest to <origin>, if false by distance farthest from <origin>`, false), new LibraryFunctionParameter("max", `if set then only the first <max> count of entities will be returned`, false), new LibraryFunctionParameter("range", `if set then only the entities within <range> will be considered`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArraySortClosest", `Returns a sorted array of entities by closest from <origin>`, null, [new LibraryFunctionParameter("array", `array to sort`, true), new LibraryFunctionParameter("origin", `the origin from which to compare`, true), new LibraryFunctionParameter("<maxReturnCount", `if set then only the first <max> count of entities will be returned`, false), new LibraryFunctionParameter("minDist", `if set then only the entities further than <minDist> will be considered`, false), new LibraryFunctionParameter("maxDist", `if set then only the entities closer then <maxDist will be considered`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArtilleryIconLocation", `Set the artillery icon location`, null, [new LibraryFunctionParameter("position", `Position of icon`, true), new LibraryFunctionParameter("teamNum", `Team number`, true), new LibraryFunctionParameter("isActive", `Whether the icon is active or not`, true), new LibraryFunctionParameter("isMortar", `Whether the artillery is a mortar`, false), new LibraryFunctionParameter("clientNum", `The client number`, false)], true, false, `ArtilleryIconLocation( self.origin, 1, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ASMSetAnimationRate", `change the delta animation rate for the entity using ASM.`, "entity", [new LibraryFunctionParameter("rate", `(float)`, true)], true, false, `self ASMSetAnimationRate( 0.3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Attach", `Attach a model to an entity.`, "entity", [new LibraryFunctionParameter("modelname", `The model name to attach (string).`, true), new LibraryFunctionParameter("tagname", `The tag to attach the model to (string).`, false), new LibraryFunctionParameter("ignoreCollision", `flag to ignore collision. Defaults to false (integer).`, false)], true, false, `self Attach( "panzerflak_ammo", "tag_weapon_left" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AttachShieldModel", `Attach a shield model to a player.`, "player", [new LibraryFunctionParameter("modelname", `The model name to attach (string).`, true), new LibraryFunctionParameter("tagname", `The tag to attach the model to (string).`, false), new LibraryFunctionParameter("ignoreCollision", `flag to ignore collision. Defaults to false (integer).`, false)], true, false, `self AttachShieldModel( "weapon_riot_shield", "tag_weapon_left" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AttachWeapon", `Attaches a weapon to the entity.`, "entity", [new LibraryFunctionParameter("weapon", `The weapon to attach.`, true), new LibraryFunctionParameter("renderoptions", `The render options for the weapon`, false), new LibraryFunctionParameter("acvi", `The attachment cosmetic variations`, false)], false, true, `self AttachWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BadPlace_Box", `Creates a bad place box. AI will flee this position if they can, and will not go into it if they can avoid it.`, null, [new LibraryFunctionParameter("name", `The name of the bad place. If name is not "", the bad place can be moved or deleted by using the unique name.`, true), new LibraryFunctionParameter("duration", `If duration > 0, the bad place will automatically delete itself after this time. If duration <= 0, the bad place must have a name and will last until manually deleted.`, true), new LibraryFunctionParameter("origin", `The origin of the box.`, true), new LibraryFunctionParameter("halfSize", `The halfSize of the box.`, true), new LibraryFunctionParameter("team", `You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.`, true)], true, false, `BadPlace_Box( "moody", -1, level.moodyfall_mn, level.moodyfall_halfSize, "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BadPlace_Cylinder", `Creates a bad place cylinder. AI will flee this position if they can, and will not go into it if they can avoid it.`, null, [new LibraryFunctionParameter("name", `The name of the bad place. If name is not "", the bad place can be moved or deleted by using the unique name.`, true), new LibraryFunctionParameter("duration", `If duration > 0, the bad place will automatically delete itself after this time. If duration <= 0, the bad place must have a name and will last until manually deleted.`, true), new LibraryFunctionParameter("origin", `The origin of the cylinder.`, true), new LibraryFunctionParameter("radius", `The radius of the cylinder.`, true), new LibraryFunctionParameter("height", `The height of the cylinder.`, true), new LibraryFunctionParameter("team", `You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.`, true)], true, false, `BadPlace_Cylinder( "moody", -1, level.moodyfall_mn, level.moodyfall_radius, "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BadPlace_Delete", `Deletes a bad place. It is okay to delete a bad place name that doesn't exist. It is not okay to delete the special name "".`, null, [new LibraryFunctionParameter("bad place identifier", `The bad place to delete`, true)], true, false, `BadPlace_Delete( "bpFlak1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BallSetTarget", `Sets the target of the ball to the given entity, and resets if no entity is specified.`, "ball", [new LibraryFunctionParameter("target", `The target of the missile`, true), new LibraryFunctionParameter("targetOffset", `Offset to the target location (vector3)`, false)], true, false, `self BallSetTarget( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Ban", `Bans the specified player.`, null, [new LibraryFunctionParameter("clientnum", `The client number of the player to ban.`, true)], true, false, `Ban( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeamTrace", `Performs a bullet trace between two points and returns an array of information about the trace result.`, null, [new LibraryFunctionParameter("start_pos", `(point) The start position for the trace.`, true), new LibraryFunctionParameter("end_pos", `(point) The end position for the trace.`, true), new LibraryFunctionParameter("hit_characters", `(bool) Tell the trace to hit characters or not.`, true), new LibraryFunctionParameter("ignore_ent", `(entity) Entity to ingore for trace.`, true), new LibraryFunctionParameter("ignore_water", `(bool) Ignore water - defaults to false.`, false), new LibraryFunctionParameter("ignore_glass", `(bool) Ignore glass - defaults to false.`, false), new LibraryFunctionParameter("ignore_ent2", `(entity) Second entity to ingore for trace.`, false)], true, false, `a_trace = BeamTrace( org1, org2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BloodImpact", `Sets the blood impact type on the character`, "entity", [new LibraryFunctionParameter("value", `Has to be one of: "none", "hero" or "normal"`, true)], true, false, `guy BloodImpact ( "none" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BlurAndTint_FX", `Plays RadioActive/Fire FX`, "entity", [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("level", `0 - 1`, false)], false, true, `entity BlurAndTint_FX(0, true, 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Bobbing", `Causes a script entity to bob around its origin, along a given vector dir`, null, [new LibraryFunctionParameter("direction vector", `The direction of the bobbing`, true), new LibraryFunctionParameter("amplitude", `The amount of the bobbing in units`, true), new LibraryFunctionParameter("period", `The period of the bobbing in seconds`, true), new LibraryFunctionParameter("phase", `The phase offset of the bobbing`, false)], true, false, `self Bobbing( directionVir, 0.3, 0.4, 0.0f )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BonusCardActiveCount", `Returns how many bonus cards are active, cannot be called on a larry`, "player", [new LibraryFunctionParameter("classnum", `The current class num of the player`, true)], true, false, `cardCount = self BonusCardActiveCount( self.class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BoundsWouldTelefrag", `Returns true if the passed in bounding box would telefrag a player if another player was spawned there.`, null, [new LibraryFunctionParameter("mins", `Mins of bounding box`, true), new LibraryFunctionParameter("maxs", `Maxs of bounding box`, true)], true, false, `if ( BoundsWouldTelefrag( vehicle GetAbsMins(), vehicle GetAbsmaxs() ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BulletSpread", `uses spread to return a new end position`, null, [new LibraryFunctionParameter("start", `The bullet starting point`, true), new LibraryFunctionParameter("end", `The bullet ending point`, true), new LibraryFunctionParameter("spread", `Amount of spread`, true)], true, false, `endpos = BulletSpread( self.origin, target.origin, 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BulletTrace", `Performs a bullet trace between two points and returns an array of information about the trace result.`, null, [new LibraryFunctionParameter("start_pos", `(point) The start position for the trace.`, true), new LibraryFunctionParameter("end_pos", `(point) The end position for the trace.`, true), new LibraryFunctionParameter("hit_characters", `(bool) Tell the trace to hit characters or not.`, true), new LibraryFunctionParameter("ignore_ent", `(entity) Entity to ingore for trace.`, true), new LibraryFunctionParameter("ignore_water", `(bool) Ignore water - defaults to false.`, false), new LibraryFunctionParameter("ignore_glass", `(bool) Ignore glass - defaults to false.`, false), new LibraryFunctionParameter("ignore_ent2", `(entity) Second entity to ingore for trace.`, false)], true, false, `a_trace = BulletTrace( org1, org2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BulletTracePassed", `Allows script to do a bullet point trace with ( MASK_SHOT & ~CONTENTS_SKY ) returns true if the trace does not hit anything`, null, [new LibraryFunctionParameter("start", `The bullet start point`, true), new LibraryFunctionParameter("end", `The bullet end point`, true), new LibraryFunctionParameter("hit characters", `An entity to ignore`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore`, true), new LibraryFunctionParameter("ignore entity 2", `An entity to ignore`, false), new LibraryFunctionParameter("fx vis", `check against fx visibility also`, false), new LibraryFunctionParameter("ignore water", `mask contents_water`, false)], true, false, `passed = BulletTracePassed( grenade.origin, self.origin + (0,0,TROPHY_TRACE_Z), false, self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CamAnimScripted", `Plays the camera script on a player.`, null, [new LibraryFunctionParameter("player", `The player to play animation on`, true), new LibraryFunctionParameter("cam_anim", `The animation to play`, true), new LibraryFunctionParameter("start_time", `The start time of the animation`, true), new LibraryFunctionParameter("align_origin", `The origin to align to`, true), new LibraryFunctionParameter("align_angles", `The angles to align to`, true), new LibraryFunctionParameter("lerp_duration", `The lerp duration`, false), new LibraryFunctionParameter("camera_name", `The camera name`, false), new LibraryFunctionParameter("ignoreProcessingInitialNoteTracks", `Ignores processing the initial notetracks if the camera time starts earlier`, false)], true, false, `CamAnimScripted( player, "proto_melee_cam", gettime(), origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraForceDisableScriptCam", `Disable the script cam from client script.`, "player", [], false, true, `player CameraForceDisableScriptCam( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraSetLensId", `undefined`, "entity", [new LibraryFunctionParameter("id", `int`, true)], false, true, `entity CameraSetLensId(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraSetUpdateCallback", `Set the function that will get called during the camera update`, "player", [new LibraryFunctionParameter("function", `a function pointer to a function that will get called during the camera update, the function should set the scr cam`, false)], false, true, `player CameraSetUpdateCallback( &function )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanClaimNode", `Returns true if the node is unclaimed, false otherwise.`, null, [new LibraryFunctionParameter("node", `pathnode to check`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `if ( CanClaimNode( cover, team ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanPath", `Check if a path can be found between these positions.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `if ( self CanPath( self.origin, targetpos ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ChangeAdvertisedStatus", `Changes the advertised status`, null, [new LibraryFunctionParameter("onOff", `(boolean)`, true)], true, false, `changeAdvertisedStatus( onOff )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CheckIfSongUnlocked", `undefined`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play (string)`, true)], true, false, `self CheckIfSongUnlocked( "frag_out" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CheckNavMeshDirection", `Run a trace on NavMesh to get the furthest position a character can move in that direction`, null, [new LibraryFunctionParameter("start", `start of the trace`, true), new LibraryFunctionParameter("dir", `direction to trace`, true), new LibraryFunctionParameter("dist", `distance to trace`, true), new LibraryFunctionParameter("characterRadius", `the radius of the capsule used in trace. default to 0.`, false), new LibraryFunctionParameter("materialFlags", `the flags marking whether a face type can be used`, false)], true, false, `pos = CheckNavMeshDirection( (10,20,30), ( 1, 1, 0 ), 25 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CleanupSpawnedDynEnts", `Removed all dyn ents that were dynamically spawned (gib pieces, destructible parts, etc)`, null, [], false, true, `CleanupSpawnedDynEnts()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearAlternateAimParams", `Forces the local player to use default values for aim assist.  Only works in zombie/campaign mode. Can only be called on players`, "player", [], false, true, `self ClearAlternateAimParams()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearAnim", `Sets an animation's goal weight (and the goal weights of all of its descendents) to zero over the specified time.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to clear`, true), new LibraryFunctionParameter("time", `The blending time for the clear`, true)], true, false, `self ClearAnim( %root, 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearAnimLimited", `Sets an animation's goal weight to zero over the specified time.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to clear`, true), new LibraryFunctionParameter("time", `The blending time for the clear`, true)], true, false, `self ClearAnimLimited( %root, 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearLastUpdatedCollectibles", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearMaterialOverride", `Clears the material override`, "entity", [], false, true, `self ClearMaterialOverride()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearNearestEnemyScrambler", `clears closest enemy scrambler from the compass`, "player", [], false, true, `player ClearNearestEnemyScrambler( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPlayerCorpses", `Removes all player corpses from the level`, null, [], true, false, `ClearPlayerCorpses( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPlayerGravity", `Clears the gravity override for the player.`, "player", [], true, false, `player ClearPlayerGravity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearSpawnPoints", `Clears all spawnpoints out of the system`, null, [new LibraryFunctionParameter("list", `which list of spawnpoints to clear`, false)], true, false, `ClearSpawnPoints()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearSpawnPointsBaseWeight", `Clears the objective base weights set in the spawn points`, null, [new LibraryFunctionParameter("team mask", `teams that this command will affect`, true)], true, false, `ClearSpawnPointsBaseWeight( team_mask )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearStepTriggerSound", `Clears the sound triggered by steps`, "entity", [], false, true, `trigPlayer ClearStepTriggerSound()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearStowedWeapon", `Clears the stowed weapon for the player`, "entity", [], true, false, `self ClearStowedWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearStreamerRequest", `Clear a hint from a request slot (0-7)`, null, [new LibraryFunctionParameter("slot", `Request slot`, true)], false, true, `clearStreamerRequest(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearTargetEntity", `Clears the current target for this vehicle or turret.`, "turret", [], true, false, `roof_turret ClearTargetEntity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearTopScorers", `Clears the top scorer for the end game screen.`, null, [], true, false, `ClearTopScorers()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientAnnouncement", `Sends an announcement to a single client.`, null, [new LibraryFunctionParameter("clientnum", `The client number that the announcement is sent to.`, true), new LibraryFunctionParameter("string", `The announcement.`, true), new LibraryFunctionParameter("duration", `How long, in seconds, to display the announcement.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientClaimTrigger", `Claim a single user trigger.`, "client", [new LibraryFunctionParameter("trigger", `A trigger entity.`, true)], true, false, `other ClientClaimTrigger( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientPrint", `Print a localized version of this string for a given client`, null, [new LibraryFunctionParameter("client", `A client entity.`, true), new LibraryFunctionParameter("string", `A message to print.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientReleaseTrigger", `Release a single user trigger.`, "client", [new LibraryFunctionParameter("trigger", `A trigger entity.`, true)], true, false, `other ClientReleaseTrigger( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientSysRegister", `Declares a system who's state will be communicated over to the client script system when it changes.  Takes a unique name, and returns the id of the system.`, null, [new LibraryFunctionParameter("name", `The unique name of the system to be registered`, true)], true, false, `index = ClientSysRegister("FakeFire")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientSysSetState", `Sets the state of a pre registered client system for all clients.  The state will be communicated to the client script system.`, null, [new LibraryFunctionParameter("id", `The integer id of the client system.  Returned from call to ClientSysRegister.`, true), new LibraryFunctionParameter("state", `Arbitrary string state.  Will be sent to the client script system.`, true)], true, false, `ClientSysSetState(level._ClientSys["FakeFire"], "Event1Phase1")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CloneAndRemoveEntity", `Creates a new entity at the position/orientation/pose of the original, and kills the original`, null, [new LibraryFunctionParameter("entity", `entity field`, true)], true, false, `CloneAndRemoveEntity( ent )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("codcaster_keyline_enable", `Enable or disable the CODCaster Keyline effect`, "entity", [new LibraryFunctionParameter("type", `0-disable 1-enable`, true)], false, true, `entity CODCasterKeyline_Enable( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeGetClientField", `Gets the value for a given client field.`, null, [new LibraryFunctionParameter("entity", `The entity to search the name in`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `val = CodeGetClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeGetPlayerStateClientField", `Gets the value for a given player state client field.`, null, [new LibraryFunctionParameter("player", `A player`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `val = CodeGetPlayerStateClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeGetUIModelClientField", `Gets the value for a given player uimodel client field.`, null, [new LibraryFunctionParameter("player", `A player`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `val = CodeGetUIModelClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeGetWorldClientField", `Gets the value for a given client field.`, null, [new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `val = CodeGetWorldClientField("my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeIncrementClientField", `Increments the value for a given client field.`, null, [new LibraryFunctionParameter("entity", `An entity`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `CodeIncrementClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeIncrementPlayerStateClientField", `Increments the value for a given player state client field.`, null, [new LibraryFunctionParameter("player", `A player`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `CodeIncrementPlayerStateClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeIncrementUIModelClientField", `Increments the value for a given client field.`, null, [new LibraryFunctionParameter("entity", `An entity`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `CodeIncrementUIModelClientField(ent, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeIncrementWorldClientField", `Increments the value for a given world client field.`, null, [new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], true, false, `CodeIncrementWorldClientField("my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeSetClientField", `Sets the value for a given client field.`, null, [new LibraryFunctionParameter("entity", `An entity`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("value", `Value to transmit.`, true)], true, false, `CodeSetClientField(ent, "my_field", 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeSetPlayerStateClientField", `Sets the value for a given player state client field.`, null, [new LibraryFunctionParameter("player", `A player`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("value", `Value to transmit.`, true)], true, false, `CodeSetPlayerStateClientField(ent, "my_field", 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeSetUIModelClientField", `Sets the value for a given player uimodel client field.`, null, [new LibraryFunctionParameter("player", `A player`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("value", `Value to transmit.`, true)], true, false, `CodeSetUIModelClientField(ent, "my_field", 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CodeSetWorldClientField", `Sets the value for a given world client field.`, null, [new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("value", `Value to transmit.`, true)], true, false, `CodeSetWorldClientField("my_field", 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollisionTestPointsInBox", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollisionTestPointsInCone", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollisionTestPointsInCylinder", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollisionTestPointsInPill", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollisionTestPointsInSphere", `Returns an array of collision result structures`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ConnectPaths", `Connects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to connect paths.`, "entity", [], true, false, `vehicle ConnectPaths()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ConsumableDecrement", `Decrement a specified consumable for the player by the specified amount`, "player", [], true, false, `self ConsumableDecrement( "blackjack", "awarded", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ConsumableGet", `Returns the value of the specified consumable for the player`, "player", [], true, false, `self ConsumableGet( "blackjack", "awarded" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ConsumableIncrement", `Increment a specified consumable for the player by the specified amount`, "player", [], true, false, `self ConsumableIncrement( "blackjack", "awarded", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ConsumableSet", `Set a specified consumable for the player to the specified amount`, "player", [], true, false, `self ConsumableSet( "blackjack", "awarded", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CountPlayers", `Returns a count of the current players, even if they are still connecting to the game.`, null, [new LibraryFunctionParameter("team", `- if specifed, returns lists of players on different teams, in team based game modes.  Valid values "allies", "axis", "neutral" & "all"`, false)], true, false, `count = CountPlayers()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateDynEntAndLaunch", `Creates and launches a dynent.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("pos", `position to spawn at.`, true), new LibraryFunctionParameter("angles", `angles to spawn at.`, true), new LibraryFunctionParameter("hitpos", `the hit position`, true), new LibraryFunctionParameter("force", `The force of the launch`, true), new LibraryFunctionParameter("fx", `particle effects to play on this dynent`, false)], true, false, `CreateDynEntAndLaunch( spawn_models[i], origin, angles, origin, velocity, anim._effect["animscript_gibtrail_fx"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateSoundRandom", `Create sound random at the position`, null, [new LibraryFunctionParameter("position", `The position`, true), new LibraryFunctionParameter("name", `The sound name`, true), new LibraryFunctionParameter("min wait", `The minimum wait time`, true), new LibraryFunctionParameter("max wait", `The maximum wait time`, true)], false, true, `CreateSoundRandom(randSound.origin, randSound.script_sound, randSound.script_wait_min, randSound.script_wait_max)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateStreamerHint", `Allows scripter to create a streamer hint entity viewpoint to the player's viewpoint.`, null, [new LibraryFunctionParameter("origin", `Location at which to spawn the streamer hint.`, true), new LibraryFunctionParameter("factor", `The relative importance of this entity's viewpoint to the main viewpoint.`, true), new LibraryFunctionParameter("lightingState", `The lighting state to stream`, false)], true, false, `streamHintEnt = createStreamerHint( level.player.origin, 0.333 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CurrentSessionMode", `Returns the current session mode index`, null, [], true, false, `sessionMode = CurrentSessionMode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CylinderDamage", `cylinder_dir_vector should contains the direction and the length of the cylinder relative to the base origin`, null, [new LibraryFunctionParameter("cylinder_vec", `contains the direction and the length of the cylinder relative to the base origin`, true), new LibraryFunctionParameter("origin", `Origin of damage`, true), new LibraryFunctionParameter("near_radius", `Radius of the damage at the near end`, true), new LibraryFunctionParameter("far_radius", `Radius of the damage at the far end`, true), new LibraryFunctionParameter("max_damage", `Max damage, this is the damage at the origin`, true), new LibraryFunctionParameter("min_damage", `Max damage, this is the damage at the edge of the radius`, true), new LibraryFunctionParameter("attacker", `Attacker the dealt the damage`, false), new LibraryFunctionParameter("means_of_death", `Means of death of the damage`, false), new LibraryFunctionParameter("weapon", `Weapon used to damage`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DamageConeTrace", `Determines how much the entity can be seen from the given position. Performs multiple traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.`, "entity", [new LibraryFunctionParameter("damage position", `The point the sight starts at`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore when doing the traces`, false), new LibraryFunctionParameter("damage angles", `The forward direction of the cone, whose base is at the <damage position>.  Must be normalized.`, false), new LibraryFunctionParameter("cone angle", `Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.`, false)], true, false, `turretDamageFraction = entity damageConeTrace( turret.origin + (0,0,40), turret )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeactivateClientExploder", `Deactivates a client side exploder`, null, [new LibraryFunctionParameter("exploder id", `id of exploder to deactivate`, true)], true, false, `DeactivateClientExploder( 101 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeactivateClientRadiantExploder", `Deactivates a client side radiant exploder`, null, [new LibraryFunctionParameter("exploder id", `string id of exploder to deactivate`, true)], true, false, `DeactivateClientRadiantExploder( "light_switch" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Delete", `Removes an entity from the game in the same manner as a trigger_kill`, "entity", [], true, false, `self Delete()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeletePathNode", `Delete a dynamically created path node or cover node`, null, [new LibraryFunctionParameter("node", `The node to delete`, true)], true, false, `DeletePathNode( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DemoIsAnyFreeMoveCamera", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DemoIsDollyCamera", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DemoIsEditCamera", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DemoIsMovieCamera", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeployRiotShield", `Gets the index in a particular class`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `DeployRiotShield( owner, shield )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DepthInWater", `Returns the depth (in inches) that the entity is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.`, "entity", [], true, false, `depth = get_players()[0] DepthInWater()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DepthOfPlayerInWater", `Returns the depth (in inches) that the player is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.  More effecient than depthinwater but will only work for players`, "player", [], true, false, `depth = get_players()[0] DepthOfPlayerInWater()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Detach", `detaches an attached model from an entity`, "entity", [new LibraryFunctionParameter("modelname", `The model name to detach (string)`, true), new LibraryFunctionParameter("tagname", `The tag to detach the model from (string)`, false)], true, false, `self Detach( "explosivepack", "tag_weapon_right" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DetachAll", `detaches all attached models from an entity`, "entity", [], true, false, `self DetachAll()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DetachShieldModel", `Detaches an attached shield model from a player.`, "player", [new LibraryFunctionParameter("modelname", `The model name to detach (string)`, true), new LibraryFunctionParameter("tagname", `The tag to detach the model from (string)`, false)], true, false, `self DetachShieldModel( "weapon_riot_shield", "tag_weapon_left" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Detonate", `Detonate the entity and set the owner to the player which is specified.`, "entity", [new LibraryFunctionParameter("player", `The player who owns the entity`, false)], true, false, `self Detonate( attacker )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DirectionalHitIndicator", `Create a directional hit indicator`, null, [new LibraryFunctionParameter("victims0", `A bit array of entities 0-31 that got hit`, true), new LibraryFunctionParameter("victims1", `A bit array of entities 32-63 that got hit`, false)], true, false, `attacker DirectionalHitIndicator( victimArray0, victimArray1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableAimAssist", `Disables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.`, "entity", [], true, false, `player DisableAimAssist()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableDestructiblePieces", `Disables all destructible pieces that have this label set in the destructible gdt`, null, [new LibraryFunctionParameter("label", `the name of the field listed in the destructible gdt to disable`, true)], true, false, `DisableDestructiblePieces( "heavy_armor" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableGrenadeSuicide", `Stops cooked grenades from killing the player.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableGrenadeTouchDamage", `Resets the grenade touch damage flag of the entity`, "entity", [], true, false, `self DisableGrenadeTouchDamage()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableOffhandSpecial", `Disable the ability to activate a player's special offhand weapons`, "player", [], true, false, `player DisableOffhandSpecial()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableOnRadar", `Sets the icon to be shown on the minimap`, "entity", [], false, true, `actor DisableOnRadar()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableSpawnPointList", `disables spawn point list for a the team_mask`, null, [new LibraryFunctionParameter("list", `list to disable`, true), new LibraryFunctionParameter("team mask", `teams that this command will affect`, true)], true, false, `DisableSpawnPointList()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableSpeedBlur", `REmoves a speed blur on on the screen`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `DisableSpeedBlur( <localClientNum> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableVehicleSounds", `Disables all sounds from a vehicle`, "vehicle", [], false, true, `self DisableVehicleSounds()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisconnectPaths", `Disconnects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to disconnect paths.`, "entity", [new LibraryFunctionParameter("detailLevel", `how detailed the cut part matches the entity. 0 or omitted: box, 1: convex hull fitting rough shape, 2: [SUPER EXPENSIVE] use collision shape directly`, false), new LibraryFunctionParameter("moveAllowed", `sets whether the silhouette moves with the entity (defaults to true)`, false)], true, false, `level.ArmoredCar DisconnectPaths()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DoDamage", `Does damage to this entity`, "entity", [new LibraryFunctionParameter("health", `The amount of damage to do`, true), new LibraryFunctionParameter("source position", `The position that the damage comes from`, true), new LibraryFunctionParameter("attacker", `The entity that dealt the damage (such as an AI or player)`, false), new LibraryFunctionParameter("inflictor", `The entity that the damage came from (such as a grenade or turret)`, false), new LibraryFunctionParameter("hitloc", `The location of the damage, default is none; one of: { 'none', 'torso_upper', 'torso_lower', 'helmet', 'head', 'neck', 'left_arm_upper', 'left_arm_lower', 'left_hand', 'right_arm_upper', 'right_arm_lower', 'right_hand', 'left_leg_upper', 'left_leg_lower', 'left_foot', 'right_leg_upper', 'right_leg_lower', 'right_foot' }`, false), new LibraryFunctionParameter("mod", `. The means of death string. Otherwise, the means of death will be 'MOD_UNKNOWN'.`, false), new LibraryFunctionParameter("dflags", `. Damage flags.`, false), new LibraryFunctionParameter("weapon", `. Weapon used.`, false), new LibraryFunctionParameter("infdestructible_piece_indexlictor", `The destructible piece index from the destructible def gdt"`, false), new LibraryFunctionParameter("forcePain", `true/false; If true, actor->painDeath.iPainTime will be reset to zero"`, false)], true, false, `player DoDamage(25, gasEffectArea.origin, player.lastPoisonedBy, grenade_obj, 0, "MOD_EXPLOSIVE", 0, GetWeapon("tabun_gas_mp"), -1, false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DoesWeaponReplaceSpawnWeapon", `Returns true if the new weapon is an alt mode of the spawn weapon. Only certain alt variations are valid (not-gl)`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `if ( DoesWeaponReplaceSpawnWeapon( self.spawnWeapon, newWeapon ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DontInterpolate", `pop the entity's position instantaneously to where it moves this time step, rather than smoothly moving there from the previous position`, "entity", [], true, false, `entity DontInterpolate()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DoubleXPTimerFired", `Used to decrement consumable double xp promotions`, "player", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DragonStrike_Enable", `Enable or disable the DragonStrike effect`, "entity", [new LibraryFunctionParameter("type", `0-disable 1-enable`, true)], false, true, `entity DragonStrike_enable( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DragonStrike_SetColorRadiusSpinPulse", `Set Dragon Strike Cicle position`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity DragonStrike_SetColorRadiusSpinPulse( 1.0, 0.5, 0.25, 100.0, 0.5, 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DragonStrike_SetPosition", `Set Dragon Strike Cicle position`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity DragonStrike_SetPosition( vec3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DrawNode", `Draws a node`, null, [new LibraryFunctionParameter("node", `pathnode`, true)], true, false, `DrawNode( self.node)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DropNodEToFloor", `Drop the node to the floor.`, null, [new LibraryFunctionParameter("node", `node to drop`, true)], true, false, `DropNodeToFloor( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EACPathSet", `Sets the value of a eac path drone.`, null, [new LibraryFunctionParameter("vec3", `The value.`, true)], true, false, `SetEACPATH( origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Earthquake", `Create an earthquake`, null, [new LibraryFunctionParameter("scale", `scale of the earthquake. Must be greater than 0.`, true), new LibraryFunctionParameter("duration", `The duration of the earthquake. Must be greater than 0.`, true), new LibraryFunctionParameter("radius", `The radius of the earthquake. Must be greater than 0.`, true), new LibraryFunctionParameter("target", `Target is given if earthquake is to be shown to particular client`, false)], true, false, `Earthquake( 0.22, 7, player.origin, 150 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableAimAssist", `Enables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.`, "entity", [], true, false, `player EnableAimAssist()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableAllDestructiblePieces", `Enables all destructible pieces that were previously disabled`, null, [], true, false, `EnableAllDestructiblePieces()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableGrenadeSuicide", `Enables cooked grenades killing the player.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableGrenadeTouchDamage", `Sets the grenade touch damage flag of the entity`, "entity", [], true, false, `self EnableGrenadeTouchDamage()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableInfluencer", `Enables or disables the given influencer`, null, [new LibraryFunctionParameter("influencer id", `The influencer to enable/disable`, true), new LibraryFunctionParameter("enable", `True to enable. False to disable`, true)], true, false, `EnableInfluencer( influencer_id, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableLinkTo", `enables linkto for an entity`, "entity", [], true, false, `self.bombtrigger EnableLinkTo()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableNavMeshTrigger", `Enables/disables a given navmesh trigger`, null, [new LibraryFunctionParameter("targetname", `The targetname of the trigger entity.`, true), new LibraryFunctionParameter("enable", `Whether to enable disable the given volume for pathfinding.`, true)], true, false, `EnableNavMeshTrigger( "some_trigger", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableObstacle", `Enables or disables the hkai obstacle associated with a given entity.`, "entity", [new LibraryFunctionParameter("enable", `Whether to enable or disable the obstacle`, true)], true, false, `ent EnableObstacle( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableOffhandSpecial", `Enable the ability to activate a player's special offhand weapons`, "player", [], true, false, `player EnableOffhandSpecial()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableOnRadar", `Sets the icon to be shown on the minimap`, "entity", [], false, true, `actor EnableOnRadar()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableSpawnPointList", `enables spawn point list for a the team_mask`, null, [new LibraryFunctionParameter("list", `list to enable`, true), new LibraryFunctionParameter("team mask", `teams that this command will affect`, true)], true, false, `EnableSpawnPointList()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableSpeedBlur", `Sets a speed blur on on the screen with parameters`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true), new LibraryFunctionParameter("amount", `Blur Amount ( 0.0 - 1.0 )`, true), new LibraryFunctionParameter("inner radius", `The size of the inner radius ( 0.0 - 1.0 )`, true), new LibraryFunctionParameter("inner outerradius", `The size of the inner radius ( 0.0 - 1.0 )`, true), new LibraryFunctionParameter("velocityShouldScale", `false don't scale with velocity, true scale`, false), new LibraryFunctionParameter("velocityScale", `Specify the velocity when the scale is 1.0`, false), new LibraryFunctionParameter("blurInTime", `Specify the time it takes to complete a blur in`, false), new LibraryFunctionParameter("blurOutTime", `Specify the time it takes to complete a blur out`, false), new LibraryFunctionParameter("shouldOffset", `Specify whether the blur should change as you move left/right or up/down`, false)], false, true, `EnableSpeedBlur( localClientNum, .02, .5, .75, true, 300.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableVehicleSounds", `Enables all sounds from a vehicle`, "vehicle", [], false, true, `self EnableVehicleSounds()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EndCamAnimScripted", `Ends the camera script on a player.`, "player", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `EndCamAnimScripted( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EndExtraCamAnimScripted", `Ends the extracam camera script on a player.`, "player", [new LibraryFunctionParameter("player", `The player to play animation on`, true), new LibraryFunctionParameter("extra_cam_index", `The extra camera index`, true)], true, false, `EndExtraCamAnimScripted( player, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("evSetRanges", `Sets the visual range for EV mode`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true), new LibraryFunctionParameter("geometryRange", `geometry draw distance.`, true), new LibraryFunctionParameter("targetRange", `target object draw distance.`, true)], false, true, `evSetRanges( localclientnum, geometryRange, targetRange )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ExitLevel", `exits the current level`, null, [new LibraryFunctionParameter("save persistent", `if true then player info is retained`, false)], true, false, `ExitLevel( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ExperimentsGetVariant", `Gets the variant for a user for an experiment`, null, [], true, false, `variant = player ExperimentsGetVariant( experimentName )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ExtraCamAnimScripted", `Plays the camera script on an extracam player.`, null, [new LibraryFunctionParameter("player", `The player to play animation on`, true), new LibraryFunctionParameter("extra_cam_index", `The extra camera index`, true), new LibraryFunctionParameter("cam_anim", `The animation to play`, true), new LibraryFunctionParameter("start_time", `The start time of the animation`, true), new LibraryFunctionParameter("align_origin", `The origin to align to`, true), new LibraryFunctionParameter("align_angles", `The angles to align to`, true), new LibraryFunctionParameter("lerp_duration", `The lerp duration`, false), new LibraryFunctionParameter("camera_name", `The camera name`, false), new LibraryFunctionParameter("ignoreProcessingInitialNoteTracks", `Ignores processing the initial notetracks if the camera time starts earlier`, false)], true, false, `ExtraCamAnimScripted( player, 0, "proto_melee_cam", gettime(), origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FakeFire", `Simulates gun fire.  Sound and radar blip.`, null, [new LibraryFunctionParameter("owner", `The player who fakes fire`, true), new LibraryFunctionParameter("origin", `the origin of the fake fire`, true), new LibraryFunctionParameter("weapon", `The weapon used`, true), new LibraryFunctionParameter("shot count", `Number of shots fired`, true)], true, false, `decoy FakeFire( player, position, "turret_mp", 20 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindAnimByName", `Find specified animation( using animation name ) in a specified animtree( using atr name).`, null, [new LibraryFunctionParameter("tree", `Anim tree name`, true), new LibraryFunctionParameter("anim", `Name of anim`, true)], true, false, `animnamehash = FindAnimByName("generic_human", "chicken_dance")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindDRFilter", `optimized code replacement for find_dr_filter`, "entity", [new LibraryFunctionParameter("object", `entity to check for flags on`, true), new LibraryFunctionParameter("filterset", `filterset to use`, true)], false, true, `object FindDRFilter( filterset )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindPath", `Check if a path can be found between these positions.`, null, [new LibraryFunctionParameter("start", `.`, true), new LibraryFunctionParameter("end", `.`, true)], true, false, `if ( self FindPath( self.origin, potentialpos ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FlashbackFinish", `Finishes the flashback`, null, [], true, false, `self FlashbackFinish()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FlashbackStart", `Starts the flashback and returns the new origin`, null, [new LibraryFunctionParameter("weapon", `The weapon in the player loadout.`, true)], true, false, `newpos = self FlashbackStart( <weapon> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FlushSubtitles", `Flush and clear any current subtitles on the screen for this specific client`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum to flush the subtitles for`, true)], false, true, `FlushSubtitles(0) `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FootstepDoEverything", `Set the footsteps to play sound and play the footstep fx`, null, [], false, true, `FootstepDoEverything()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FootstepDoFootstepFX", `Set the footsteps to play the effect`, null, [], false, true, `FootstepDoFootstepFX()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FootstepDoNothing", `Set the footsteps to do nothing. Not to play sound or play any fx`, null, [], false, true, `FootstepDoNothing()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FootstepDoSound", `Set the footsteps to play sound`, null, [], false, true, `FootstepDoSound()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceAmbientRoom", `Force play an ambient sound`, null, [new LibraryFunctionParameter("name", `The sound name`, true)], false, true, `ForceAmbientRoom( "sndHealth_LowHealth" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceDelete", `Forces Removal of a  entity. Does not wait till next snapshot to remove it.  Will cause crash if called on animated entity`, "entity", [], false, true, `thing forcedelete()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceGameModeMappings", `Forces the users controller mappings for a specific game mode (or resets to user defaults)`, null, [new LibraryFunctionParameter("localClientNum", `Client number to play the animation on`, true), new LibraryFunctionParameter("modeName", `Name of the mode to switch to or "default" for user defaults`, true)], false, true, `ForceGameModeMappings( localClientNum, "default" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForcePainOn", `toggles pain.forcePain to true;  next damage reaction guarenteed`, "entity", [], true, false, `ai ForcePainOn()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceStreamBundle", `Force the assets in a script bundle to stream in`, null, [new LibraryFunctionParameter("name", `Name of the script bundle to stream`, true)], false, true, `ForceStreamBundle( "cin_ram_02_03_ai" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceStreamMaterial", `Forces the streamer to load texture LODs for a material even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingMaterial when you no longer need it, or Steve will be upset that you're wasting Streamer memory.`, null, [new LibraryFunctionParameter("material", `Material to force stream`, true), new LibraryFunctionParameter("textureLods", `Texture LODs to not force`, false)], false, true, `areAllForcedLodsLoaded = ForceStreamMaterial( material, mipsToNotForce )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceStreamWeaponRenderOptions", `Forces all materials for the combination of weapon and render options to stream in`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("weapon", `Weapon to look up the materials to stream with`, true), new LibraryFunctionParameter("weaponOptions", `Render Options to look up the materials to stream with`, true)], false, true, `ForceStreamWeaponRenderOptions( localClientNum, weapon, weaponOptions )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceStreamWeapons", `Forces all weapon materials to stream in`, null, [], false, true, `forceStreamWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceStreamXModel", `Forces the streamer to load model and texture LODs for a model even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingXModel when you no longer need it, or Steve will be upset that you're wasting Streamer memory.`, null, [new LibraryFunctionParameter("model", `The model to force stream`, true), new LibraryFunctionParameter("meshLodsToForce", `The mesh LODs to force ( Default is 0 )`, false), new LibraryFunctionParameter("textureLodsToForce", `The texture LODs to force ( Default is 0 )`, false)], false, true, `areAllForcedLodsLoaded = CScr_ForceStreamXModel( model, meshLodsToNotForce, textureLodsToNotForce, alsoStreamLowerLods=true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceTModeVisible", `Forces an entity to be visible as if a player was seeing it via tmode`, null, [new LibraryFunctionParameter("entity", `The entity the value is being set for`, true), new LibraryFunctionParameter("visible", `If the entity should be considered always visible or not (default true)`, false)], false, true, `ForceTModeVisible( aiGuy, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FXBlockSight", `Uses a general entity and a radius to set a line of sight blocker on the server for some AI. Destroyed when the entity is freed.`, null, [new LibraryFunctionParameter("entity", `the entity to use for the origin for tje line of sight blocker`, true), new LibraryFunctionParameter("radius", `the radius of the 'smoke screen' blocker`, true)], true, false, `FXBlockSight( fxent, 64 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetActivate", `turns gadget on in slot.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to activate. (integer)`, true), new LibraryFunctionParameter("weapon", `The gadget weapon`, true)], true, false, `self GadgetActivate( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetCharging", `Sets the gadget charging state.`, null, [new LibraryFunctionParameter("slot", `The gadget slot. (integer)`, true), new LibraryFunctionParameter("value", `undefined to get current state, true to set or false to unset. (boolean)`, false)], true, false, `self GadgetCharging( slot, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetDeactivate", `turns gadget off in slot.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to deactivate. (integer)`, true), new LibraryFunctionParameter("weapon", `The gadget weapon`, true), new LibraryFunctionParameter("penalty", `The power penalty type`, false)], true, false, `self GadgetDeactivate( slot, weapon, GADGET_OFF_PENALTY_SHUT_OFF )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetFlickering", `Tests a gadget is flickering and can optionally set flickering.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to test or apply flickering state. (integer)`, true), new LibraryFunctionParameter("flicker", `Set gadget to flickering state if true (boolean)`, false), new LibraryFunctionParameter("length", `Set gadget flickering length (integer)`, false)], true, false, `self GadgetFlickering( slot, true, 200 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetGetSlot", `Get gadget slot for weapon.`, null, [new LibraryFunctionParameter("weapon", `The weapon in the player loadout.`, true)], true, false, `self GadgetGetSlot( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetIsActive", `Returns true if the gadget is active.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to test. (integer)`, true)], true, false, `self GadgetIsActive( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetIsPrimed", `Returns true if the gadget is primed.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to test. (integer)`, true)], true, false, `self GadgetIsPrimed( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetIsReady", `Returns true if the gadget is ready.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to test. (integer)`, true)], true, false, `self GadgetIsReady( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPowerChange", `Applies a power change to the gadget power.`, null, [new LibraryFunctionParameter("slot", `The gadget slot apply the power change. (integer)`, true), new LibraryFunctionParameter("change", `The amount to change the power by. (float)`, true)], true, false, `self GadgetPowerChange( slot, -20 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPowerGet", `Gets the power remaining for gadget.`, null, [new LibraryFunctionParameter("slot", `The gadget slot (integer)`, true)], true, false, `power = self GadgetPowerGet( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPowerReset", `Applies a power reset.`, null, [new LibraryFunctionParameter("slot", `The gadget slot apply the power reset. (integer)`, true)], true, false, `self GadgetPowerReset( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPowerSet", `Sets the power override to value. Works always.`, null, [new LibraryFunctionParameter("slot", `The gadget slot apply the power change. (integer)`, true), new LibraryFunctionParameter("value", `The amount to set power to. (float)`, true)], true, false, `self GadgetPowerSet( slot, 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPulseGetOwner", `Returns the owner of the vision pulse you an entity is pulsed by if it exists`, "entity", [], false, true, `entity GadgetPulseGetOwner(<localclientnum>)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPulseResetReveal", `Resets the reveal on an entity for this player`, "entity", [], false, true, `entity GadgetPulseResetReveal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetPulseRevealed", `Tests whether an enemy is currently revealed for this player`, "entity", [], false, true, `reveal = entity GadgetPulseRevealed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetSetActivateTime", `Set the activation time of this gadget.`, null, [new LibraryFunctionParameter("slot", `The gadget slot. (integer)`, true), new LibraryFunctionParameter("time", `The activation time. (integer)`, true)], true, false, `self GadgetSetActivateTime( slot, time )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetSetEntity", `Set the entity used by this gadget.`, null, [new LibraryFunctionParameter("slot", `The gadget slot.`, true), new LibraryFunctionParameter("entity", `The entity used by the gadget.`, true)], true, false, `self GadgetSetEntity( slot, ent )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetSetInfrared", `Enables or disables infrared for the gadget`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true), new LibraryFunctionParameter("bool", `0 disables infrared, 1 enables it.`, true)], false, true, `GadgetSetInfrared( localclientnum, newVal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetStateChange", `changes the gadget state in a slot.`, null, [new LibraryFunctionParameter("slot", `The gadget slot to activate. (integer)`, true), new LibraryFunctionParameter("weapon", `The gadget weapon`, true), new LibraryFunctionParameter("state", `The state to change it to`, true)], true, false, `self GadgetStateChange( slot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GadgetTargetResult", `undefined`, null, [new LibraryFunctionParameter("hit_miss", `hit or miss`, true)], true, false, `GadgetTargetResult(true)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GameModeIsMode", `Returns true/false if the current game mode is the given mode`, null, [new LibraryFunctionParameter("gamemode", `(int)`, true)], true, false, `if ( GameModeIsMode( level.GAMEMODE_WAGER_MATCH ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GeneratePointsAroundCenter", `generate uniformly distributed points around a center in 2D (XY) plane`, null, [new LibraryFunctionParameter("origin", `Position to start the search around.`, true), new LibraryFunctionParameter("maxSearchRadius", `the maximum radius away from origin.`, true), new LibraryFunctionParameter("innerSpacing", `the distance between points at the minRadius.`, true), new LibraryFunctionParameter("minRadius", `the minimum radius away from origin. should be between 0 and maxRadius (both inclusive).`, false), new LibraryFunctionParameter("outerSpacing", `if defined, the distance between points will be Lerped from <innerSpacing> to [outerSpacing], to create a gradual distribution from minRadius to maxRadius.`, false), new LibraryFunctionParameter("distributionBias", `(vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.`, false)], true, false, `array = GeneratePointsAroundCenter( enemy.origin, 500, 80, 100, 40, (-0.3,0,0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GenerateScriptEvent", `Creates a script event at the actor's origin, with default radius`, "actor", [new LibraryFunctionParameter("origin", `Source position of the event.`, false), new LibraryFunctionParameter("radius", `Size of the event.`, false), new LibraryFunctionParameter("name", `Name of the event.`, false)], true, false, `self GenerateScriptEvent()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAbsMaxs", `Get absolute maximum bounds of the entity in world space.`, "entity", [], true, false, `absMaxs = wallModel GetAbsMaxs()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAbsMins", `Get absolute minimum bounds of the entity in world space.`, "entity", [], true, false, `absMins = wallModel GetAbsMins()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActiveLocalClients", `Get the number of active local clients`, null, [], false, true, `active_clients = GetActiveLocalClients()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorArray", `Returns an array of the human AI`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `aiarray = GetActorArray( "ralph", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorSpawnerArray", `Returns an array of all of the actor spawners in a level.`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `spawners = GetSpawnerArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorSpawnerTeamArray", `Returns an array of all of the spawners in a level`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', or 'neutral'`, true), new LibraryFunctionParameter("team", `any number of additional team names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `enemies = GetActorSpawnerTeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorTeamArray", `Returns an array of the human AI`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', or 'neutral'`, true), new LibraryFunctionParameter("team", `any number of additional team names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `aiarray = GetActorTeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorTeamCountRadius", `Returns number of human actor AI within a sphere on a given set of teams`, null, [new LibraryFunctionParameter("origin", `Center of sphere`, true), new LibraryFunctionParameter("radius", `Radius of sphere`, true), new LibraryFunctionParameter("team", `any number of team names may be added, either 'axis', 'allies', or 'neutral' (no team implies all teams)`, false)], true, false, `nearbyOthersCount = GetActorTeamCountRadius( self.origin, 500, "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetActorWeaponOptions", `Return's the actors current weapon options, ex: weapon camo option.`, "entity", [], true, false, `self GetActorWeaponOptions()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAIArchetypeArray", `Returns an array of the AI for the given archetype and optionally given team`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.`, false)], true, false, `aiarray = GetAIArchetypeArray( "human" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAIArray", `Returns an array of the human AI`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `aiarray = GetAIArray( "my_ai", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAICount", `Returns the current ai count.`, null, [], true, false, `aicount = GetAICount()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAIFxName", `Returns a FX name corresponding to the AI's aiFxBundle key/value pair.`, "entity", [new LibraryFunctionParameter("localClientNum", `Local client to check`, true), new LibraryFunctionParameter("aiFxBundleKey", `Script bundle key defined within the AI's aiFxTable.`, true)], false, true, `fxName = self GetAIFxName( localClientNum, surfaceTable )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAILimit", `Returns the max ai count set by script.`, null, [], true, false, `ailimit = GetAILimit()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAimAngles", `Returns an array with the angles of the aimTag and the relative aiming delta angles from this orientation.`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `aim_angles = ent GetAimAngles( shootPos, "tag_aim", (0, 30, 0), (15, 10, 0), (60, 60, 0), (5, 5, 0), 11 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAISpeciesArray", `Returns an array of the AI`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.`, false), new LibraryFunctionParameter("species", `species of AI to get, 'human', 'dog', 'robot' or 'all'. Defaults to 'human'.`, false)], true, false, `aiarray = GetAISpeciesArray( "axis", "all" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAITeamArray", `Returns an array of the human AI and vehicle AI`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', or 'neutral'`, true), new LibraryFunctionParameter("team", `any number of additional team names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `aiarray = GetAITeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAITriggerFlags", `Returns the spawn flags that will allow AI to activate triggers`, null, [], true, false, `spawn("trigger_radius", (0,0,0), GetAITriggerFlags())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAllCharacterBodies", `Returns all character indices, even disabled ones, for the current session mode (or specified session mode)`, null, [new LibraryFunctionParameter("sessionMode", `Session Mode Index`, true)], true, true, `heroIndices = GetAllCharacterBodies()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAllCharacterHeads", `Returns all character indices, even disabled ones, for the current session mode (or specified session mode)`, null, [new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroIndices = GetAllCharacterHeads()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAllNodes", `Gets all of the nodes in a level`, null, [], true, false, `nodes = GetAllNodes()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAmmoCount", `Returns the count of ammo left`, null, [new LibraryFunctionParameter("weapon", `The weapon for which we need ammo count`, true)], true, false, `n_ammo = self GetAmmoCount( w_weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAngleDelta", `Get the angle delta of the animation`, null, [new LibraryFunctionParameter("animation name", `Name of the animation`, true), new LibraryFunctionParameter("start time", `Start time of the animation`, false), new LibraryFunctionParameter("end time", `End time of the animation`, false)], true, false, `angleDelta = getAngleDelta( arrivalAnim, 0, normalizedLength )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAngleFromBits", `Gets the angle (0 - 360) from the (compressed) bits`, null, [], true, false, `yaw = GetAngleFromBits( bits, 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAngles", `Get the rotation of the entity`, "entity", [], true, false, `angles = self GetAngles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimCurrFrameCount", `Get current frame for the given animation when its running.`, "entity", [new LibraryFunctionParameter("animation", `a primitive animation: calling this function on a non-primitive animation will fail`, true)], false, true, `CurrFrameNum = GetAnimCurrFrameCount(climbAnim)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimForCharacter", `Returns the name of the animation to use for the character pose in the frontend`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `frontendVignetteAnim = GetAnimForCharacter( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimFrameCount", `Get total number of frames for the given animation.`, null, [new LibraryFunctionParameter("animation", `a primitive animation: calling this function on a non-primitive animation will fail`, true)], true, false, `FrameNum = GetAnimFrameCount(climbAnim)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimLength", `Gets the length of an animation`, null, [new LibraryFunctionParameter("animation", `a primitive animation: calling this function on a non-primitive animation will fail`, true)], true, false, `cycleTime = GetAnimLength( climbAnim )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimStateCategory", `Returns the current anim state category for an Actor.`, null, [], false, true, `category = GetAnimStateCategory( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimTagOrigin", `Returns the local tag position within the animation at the specified normalized time, has no consideration to bone hierarchy.`, null, [new LibraryFunctionParameter("animation name", `Name of the animation.`, true), new LibraryFunctionParameter("normalized time", `0.0 to 1.0 time within the animation.`, true), new LibraryFunctionParameter("tag name", `Name of the tag to look up within the animation.`, true)], true, false, `tagPosition = GetAnimTagOrigin( arrivalAnim, 0, "tag_sync" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnimTime", `Get the normalized animation time for the given animation.`, "entity", [new LibraryFunctionParameter("animation", `animation to manipulate`, true)], true, false, `if ( (self GetAnimTime( %walk_and_run_loops ) ) < 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAnyNodeArray", `Gets an array of nodes within given radius`, null, [new LibraryFunctionParameter("pos", `search origin`, true), new LibraryFunctionParameter("radius", `radius to search within`, true)], true, false, `node = GetCoverNodeArray( self.origin, 256 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetArchetypeFromClassname", `Given classname, returns archetype name if its an AITYPE or VEHICLE.`, null, [], true, false, `GetArchetypeFromClassname("spawner_enemy_54i_human_sniper_sniperrifle")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAssignedTeam", `returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.`, null, [new LibraryFunctionParameter("player", `The player`, true)], true, false, `team = GetAssignedTeam( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAssignedTeamName", `returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.`, null, [new LibraryFunctionParameter("player", `The player`, true)], true, false, `team = GetAssignedTeam( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAtrLoaded", `return an array of anim tree name loaded onto the server.`, null, [], true, false, `trees = GetAtrLoaded()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachIgnoreCollision", `Returns the ignore collision flag of the attached model at the given attachment slot`, "entity", [new LibraryFunctionParameter("modelindex", `The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)`, true)], true, false, `model_ignore_collision = self GetAttachIgnoreCollision( index )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachmentCosmeticVariantForWeapon", `Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon`, "entity", [new LibraryFunctionParameter("custom Class", `Class Num`, true), new LibraryFunctionParameter("loadoutSlot", `Loadout Slot (primary or secondary)`, true)], true, false, `acvi = self GetAttachmentCosmeticVariantForWeapon( class_num, "primary" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachmentCosmeticVariantIndexes", `Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon`, null, [new LibraryFunctionParameter("weaponname", `the name of the base weapon to return`, true), new LibraryFunctionParameter("attachmentname_1", `the name of the first attachment`, false), new LibraryFunctionParameter("variantindex_1", `the index of the cosmetic variant to use for the first attachment`, false), new LibraryFunctionParameter("attachmentname_2", `the name of the second attachment`, false), new LibraryFunctionParameter("variantindex_2", `the index of the cosmetic variant to use for the second attachment`, false), new LibraryFunctionParameter("attachmentname_3", `the name of the third attachment`, false), new LibraryFunctionParameter("variantindex_3", `the index of the cosmetic variant to use for the third attachment`, false), new LibraryFunctionParameter("attachmentname_4", `the name of the fourth attachment`, false), new LibraryFunctionParameter("variantindex_4", `the index of the cosmetic variant to use for the fourth attachment`, false), new LibraryFunctionParameter("attachmentname_5", `the name of the fifth attachment`, false), new LibraryFunctionParameter("variantindex_5", `the index of the cosmetic variant to use for the fifth attachment`, false), new LibraryFunctionParameter("attachmentname_6", `the name of the sixth attachment`, false), new LibraryFunctionParameter("variantindex_6", `the index of the cosmetic variant to use for the sixth attachment`, false), new LibraryFunctionParameter("attachmentname_7", `the name of the seventh attachment`, false), new LibraryFunctionParameter("variantindex_7", `the index of the cosmetic variant to use for the seventh attachment`, false), new LibraryFunctionParameter("attachmentname_8", `the name of the eighth attachment`, false), new LibraryFunctionParameter("variantindex_8", `the index of the cosmetic variant to use for the eighth attachment`, false)], true, false, `GetAttachmentCosmeticVariantIndexes( "mp7_mp", "acog", 2, "grip", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachmentNames", `Returns array containing the names for each type of attachment.`, null, [], true, false, `attachmentNames = GetAttachmentNames()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachModelName", `Returns the name of the attached model at the given attachment slot`, "entity", [new LibraryFunctionParameter("modelindex", `The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)`, true)], true, false, `model_name = self GetAttachModelName( index )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachSize", `Returns the number of attached models for this entity.`, "entity", [], true, false, `size = self GetAttachSize()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachTagName", `Returns the tagname of the attached model at the given attachment slot`, "entity", [new LibraryFunctionParameter("modelindex", `The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)`, true)], true, false, `tag_name = self GetAttachTagName( index )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBaseWeaponItemIndex", `Returns the base weapon item index from the statstable`, null, [new LibraryFunctionParameter("weaponName", `full weapon name e.g. m16_acog_mp.`, true)], true, false, `baseWeaponName = GetBaseWeaponItemIndex( "m16_acog_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBestInfluencepos", `returns the influence map position for ai, this is custom logic to return the closest posistion between the passed in thresholds`, "ai", [new LibraryFunctionParameter("index", `which influence map to use`, true), new LibraryFunctionParameter("low", `the low threshold value to check against`, true), new LibraryFunctionParameter("high", `the high threshold value to check against`, true)], true, false, `dir = self GetBestInfluencePos( index, low, high)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBestSpawnPoint", `Returns a sorted array of spawnpoints in order from best to worst for the given team`, null, [new LibraryFunctionParameter("point team", `Team that we need the points for`, true), new LibraryFunctionParameter("influencer team", `Influencer teams to compare the points against`, true), new LibraryFunctionParameter("vis team", `Team mask to use for enemy vis tests`, true), new LibraryFunctionParameter("player", `Player that we want the points for.  The first parameter will still be used for the team.`, false), new LibraryFunctionParameter("predictedSpawn", `true if this is a predicted spawn request (used by texture streaming).`, false), new LibraryFunctionParameter("array of lists", `if provided, the spawn point will be chosen from one of these lists. If a list is disabled already for a given team, it will not be considered.`, false)], true, false, `GetSortedSpawnPoints()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBitsForAngle", `Gets the compressed bits for an angle with <num bits> granularity`, null, [], true, false, `bits = GetBitsForAngle( angle, 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBodyAccentColorCountForHero", `Returns the number of accents for the specified body model of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true), new LibraryFunctionParameter("bodyIndex", `The index of the body for the specific hero`, true)], false, true, `modelName = GetBodyAccentColorCountForHero( localClientNum, 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBodyRenderOptionsPacked", `Gets the packed value of body render options (body type, style, colors)`, "entity", [], false, true, `gibEntity GetBodyRenderOptionsPacked()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBrushModelCenter", `Get the center of the Brush Model entity`, null, [new LibraryFunctionParameter("entity", `The brush model entity`, true)], true, false, `center = GetBrushModelCenter( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBuildKitAttachmentCosmeticVariantIndexes", `Get attachment cosmetic variant indexes for the weapon from the player's build kit`, "player", [new LibraryFunctionParameter("weapon", `weapon object`, true), new LibraryFunctionParameter("upgraded", `bool whether this should be the upgraded version. If so extclip and fmj will be added`, false)], true, false, `acvi = self GetBuildKitAttachmentCosmeticVariantIndexes( ar_standard )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBuildKitWeapon", `Get weapon object (including attachments) for the weapon from the player's build kit`, "player", [new LibraryFunctionParameter("weapon", `weapon object`, true), new LibraryFunctionParameter("upgraded", `bool whether this should be the upgraded version. If so extclip and fmj will be added`, false)], true, false, `weapon = self GetBuildKitWeapon( ar_standard )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBuildKitWeaponOptions", `Get weapon options for the weapon from the player's build kit`, "player", [new LibraryFunctionParameter("weapon", `weapon object`, true), new LibraryFunctionParameter("camo_index", `camo index to override the one from the build kit, typically a packapunch camo index`, false)], true, false, `weapon_options = self GetBuildKitWeaponOptions( ar_standard, packapunch_camo_index )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCamAngles", `Returns the camera view angles`, null, [], false, true, `player GetCamPos()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCamAnglesByLocalClientNum", `Get the camera angles of the local client given`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `cam_angles = GetCamAnglesByLocalClientNum( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCamAnimTime", `Gets the duration of an xcam in milliseconds.`, null, [new LibraryFunctionParameter("cam_anim", `The animation to play`, true)], true, false, `GetCamAnimTime( "proto_melee_cam" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCamPos", `Returns the camera position`, null, [], false, true, `player GetCamPos()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCamPosByLocalClientNum", `Get the camera position of the local client given`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `cam_origin = GetCamPosByLocalClientNum( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCentroid", `Gets the centroid of an entity`, "entity", [], true, false, `centroid = self GetCentroid()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterAssetName", `Returns the asset name for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroName = GetCharacterAssetName( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyModelColorCount", `Returns the body model count for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("bodyStyleIndex", `The index of the body style in the character`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyModelCount", `Returns the body model count for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionMode", `Session Mode Index`, true)], true, true, `heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyStyleIndex", `Returns the index of the body style designated by the given display name`, null, [new LibraryFunctionParameter("gender", `Whether or not to use the male bodytype`, true), new LibraryFunctionParameter("bodyStyleDisplayName", `The name of the body style`, true)], true, true, `bodyStyleIndex = GetCharacterBodyStyleIndex( true, "Technomancer" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterCustomizationForXUID", `undefined`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("xuid", `The xuid of the player to get customization for`, true)], false, true, `GetCharacterCustomizationForXUID( <xuid>)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterDisplayName", `Returns the display name for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroName = GetCharacterDisplayName( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterFields", `Returns info for the character pose playerbodytype`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroFields = GetCharacterFields( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHeadRenderOptions", `Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()`, null, [new LibraryFunctionParameter("headIndex", `The index of the character in the current game-mode's character table`, true)], true, true, `helmetRenderOptions = GetCharacterHeadRenderOptions( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHelmetHidesHead", `Returns whether or not the characters head should be hidden based on the helmet`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("helmetIndex", `The index of the helmet belonging to that character`, true), new LibraryFunctionParameter("sessionMode", `The session mode ( mp cp zm )`, true)], true, true, `hideHead = GetCharacterHelmetHidesHead( 0, 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHelmetModelColorCount", `Returns the helmet model count for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("helmetStyleIndex", `The index of the helmet style in the character`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHelmetModelCount", `Returns the helmet model count for a character for the current session mode`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHelmetRenderOptions", `Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("helmetIndex", `The index of the helmet belonging to that character`, true), new LibraryFunctionParameter("colorIndex1", `The index of accent color 1`, true), new LibraryFunctionParameter("colorIndex2", `The index of accent color 2`, true), new LibraryFunctionParameter("colorIndex3", `The index of accent color 3`, true)], true, true, `helmetRenderOptions = GetCharacterHelmetRenderOptions( 0, 1, 1, 2, 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterIndex", `Gets the character index`, "entity", [], false, true, `index = self GetCharacterIndex()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterModeRenderOptions", `Calculates the packed mode render option - to be passed to SetBodyRenderOptions()`, null, [new LibraryFunctionParameter("session_mode", `Session Mode enum index`, true)], true, true, `modeRenderOptions = GetCharacterModeRenderOptions( SESSIONMODE_MULTIPLAYER )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClassIndexFromName", `Gets the index in a particular class`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `GScr_GetClassIndexFromName( "CLASS_SMG" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClientFieldVersion", `Returns the version of the specifiec client field, in the specified client field set - or 0 if the field isn't registered.`, null, [], true, false, `if(GetClientFieldVersion( "world", "fog_volume_active" ))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClientTime", `Gets the current client time in milliseconds`, "entity", [], false, true, `currTime = ent GetClientTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClones", `Get an array of all the clones`, null, [new LibraryFunctionParameter("local client num", `local client`, true)], false, true, `clones = GetClones( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClosestPointOnNavMesh", `Get a point on NavMesh that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found. If distFromBoundary is defined, the point found on NavMesh will then be moved again to get it away from boundary`, null, [new LibraryFunctionParameter("position", `Position to start the search around.`, true), new LibraryFunctionParameter("searchRadius", `Radius to search within. If not provided, a default value proximately equal to player size will be used.`, false), new LibraryFunctionParameter("distFromBoundary", `Distance to keep away from NavMesh boundary. This distance can NOT be guaranteed. If not provided, it will be treated as 15 (AI default radius).`, false), new LibraryFunctionParameter("materialFlags", `the flags marking whether a face type can be used`, false)], true, false, `posOnNavMesh = GetClosestPointOnNavMesh( (10,20,30), 25, 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClosestPointOnNavVolume", `Get a point on nav volume that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found.`, "flying_ai", [new LibraryFunctionParameter("position", `Position to start the search around.`, true), new LibraryFunctionParameter("searchRadius", `Radius to search within. If not provided, a default value proximately equal to player size will be used.`, false)], true, false, `posOnNavVolume = self GetClosestPointOnNavVolume( (10,20,30), 25 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetContractName", `Gets the name of the specified contract`, null, [new LibraryFunctionParameter("contractIndex", `Contract ID`, true)], true, false, `contractName = GetContractName( contractIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetContractRequiredCount", `Gets the required count for the specified contract`, null, [new LibraryFunctionParameter("contractIndex", `Contract ID`, true)], true, false, `contractName = GetContractRequiredCount( contractIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetContractRequirements", `Returns an array of contract requirements. Each requirement takes up two indices, 'reqType' and 'reqData'.`, null, [new LibraryFunctionParameter("contractIndex", `The index of the contract`, true)], true, false, `mapNames = GetContractRequirements( contractIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetContractResetConditions", `Gets the reset conditions of the specified contract`, null, [new LibraryFunctionParameter("contractIndex", `Contract ID`, true)], true, false, `resetConditions = GetContractResetConditions( contractIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetControllerPosition", `get current deflection of control, returns values via an array with vector values for "look" and "move" which correspond to those controls.  Values are -1 to 1 and represent the given axis on the vector`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want the position of`, true)], false, true, `pos = self GetControllerPosition() ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetControllerType", `returns the controller type of the player`, null, [], true, false, `player GetControllerType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCorpseAnim", `Get the animation that the corpse will play`, "player", [], true, false, `deathAnim = self GetCorpseAnim()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCorpseArray", `Returns an array of all of the items in a level.`, null, [], true, false, `origins = GetCorpseArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCounterTotal", `Gets the counter count for the given counter`, null, [new LibraryFunctionParameter("counterType", `The counter type`, true)], true, false, `count = GetCounterTotal( "global_comebacks" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCoverNodeArray", `Gets an array of cover nodes within given radius`, null, [new LibraryFunctionParameter("pos", `search origin`, true), new LibraryFunctionParameter("radius", `radius to search within`, true)], true, false, `node = GetCoverNodeArray( self.origin, 256 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCrateHeadObjective", `Returns the equipment head objective as described in the grenadeweapon gdt.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `crateObjective = GetCrateHeadObjective( uav )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentAnimScriptedName", `Get current frame for the given animation when its running.`, "entity", [], false, true, `animName = GetCurrentAnimScriptedName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentEventId", `Gets the id from the current event.`, "ai_or_player", [], true, false, `eventId = self GetCurrentEventId()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentEventName", `Gets the name of the current event.`, "ai_or_player", [], true, false, `eventId = self GetCurrentEventName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentEventOriginator", `Gets the originator from the current event if any`, "ai_or_player", [], true, false, `target = self GetCurrentEventOriginator()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentEventType", `Gets the type from the current event.`, "ai_or_player", [], true, false, `type = self GetCurrentEventType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentEventTypeName", `Gets the type string name from the current event.`, "ai_or_player", [], true, false, `type = self GetCurrentEventTypeName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentGunRank", `Get the gun current rank`, "player", [new LibraryFunctionParameter("index", `the index of the gun to get`, true)], true, false, `rank - GetCurrentGunRank(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentWeaponIncludingMelee", `Returns the name of the weapon being used by the specified local client, and will return the melee weapon if the client is in a melee state`, null, [new LibraryFunctionParameter("localClientNum", `Local client number of the player`, true)], false, true, `currentWeapon = GetCurrentWeapon( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCustomTeamName", `Get the team name`, null, [new LibraryFunctionParameter("teamid", `TeamID`, true)], true, false, `name = GetCustomTeamName( teamid )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCyberComAbilityName", `Gets the cybercom ability name given the flag, type`, null, [new LibraryFunctionParameter("flag", `flag field`, true)], true, false, `GetCyberComAbilityName(  flag, type )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getCybercomType", `Gets the active cybercom type`, null, [], false, true, `cybercom_type = player getCybercomType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCyberComWeapon", `Gets the cybercom gadget weapon given the flag, type, and if upgraded`, null, [new LibraryFunctionParameter("flag", `flag field`, true), new LibraryFunctionParameter("type", `type of weapon`, true), new LibraryFunctionParameter("upgraded", `true if the weapon is upgraded`, true)], true, false, `GetCyberComWeapon(  flag, type, upgraded )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDamageableEntArray", `Returns the entities that can be damaged. Can optionally take an origin, radius, and a flag to check 3D.`, null, [new LibraryFunctionParameter("origin", `origin to check against`, false), new LibraryFunctionParameter("radius", `max distance to origin`, false), new LibraryFunctionParameter("checkZ", `if true then check distance in 3d`, false)], true, false, `entities = GetDamageableEntArray( maxDist, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDebugEye", `Gets the debug position of the eye for an AI or Player`, "player or actor", [], true, false, `eyePos = player GetDebugEye()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDecorations", `Gets an array of booleans that represents all the decorations the player has earned`, "player", [new LibraryFunctionParameter(" only_decorations_earned ", `Only get the decorations that the player has earned`, false)], true, false, `medals = e_player GetDecorationsEarned()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDefaultClassSlot", `Gets the item in a particular default class slot`, null, [new LibraryFunctionParameter("classname", `the classname of the item`, true), new LibraryFunctionParameter("slotname", `The slot to check`, true)], true, false, `GetDefaultClassSlot( "cqb", "primary" ); // Returns primary weapon reference`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDemoVersion", `Returns the demo version value`, null, [], false, true, `if ( GetDemoVersion() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDistanceFromScreenCenter", `Get the distance from the screen center to the entity`, "entity", [new LibraryFunctionParameter("localClientNum", `Local client to check`, true)], false, true, `ent GetDistanceFromScreenCenter( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDroppedWeapons", `Returns an array containing all the dropped weapons in the level`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getdynent", `Get the dynent with the specified targetname`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `twig = getdynent("twig")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getdynentarray", `Get a dynent array with the specified targetname`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `twigs = getdynentarray("twig")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEnemies", `Returns an array of enemies.`, "entity", [], true, false, `enemies = self GetEnemies()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEnemyScramblerAmount", `Returns the amount alpha of the enemy scrambler applied`, "player", [], false, true, `alpha = player GetEnemyScramblerAmount( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEnt", `Looks up entities by key and name`, null, [new LibraryFunctionParameter("name", `name to search for`, true), new LibraryFunctionParameter("key", `key that name goes with`, true), new LibraryFunctionParameter("ignore spawners", `if true then you won't get a spawner back`, false)], true, false, `spawner = GetEnt( "doorguy1", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntArray", `Looks up entities by key and name and a return an array of the matched entities`, null, [new LibraryFunctionParameter("name", `name to search for`, false), new LibraryFunctionParameter("key", `key that name goes with`, false), new LibraryFunctionParameter("ignore spawners", `if true then you won't get a spawner back`, false)], true, false, `spawners = GetEntArray( "doorguy1", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntArrayByType", `Gets an array of entities that have the given the type of the entity ( for example, ET_MISSILE )`, null, [new LibraryFunctionParameter("localclientnum", `Which local client's entity list to use.`, true), new LibraryFunctionParameter("type", `Type of the entity. Look into shared.gsh for the ET enum`, true)], false, true, `grenades = GetEntArray( 0, ET_MISSILE )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntArrayFromArray", `Searches given array entities by key and name and a return an array of the matched entities`, null, [new LibraryFunctionParameter("array", `array of entities`, true), new LibraryFunctionParameter("name", `name to search for`, true), new LibraryFunctionParameter("key", `key that name goes with`, true)], true, false, `spawners = GetEntArrayFromArray( array, "doorguy1", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntByNum", `Gets an entity from its entity number`, null, [new LibraryFunctionParameter("entity number", `(integer) The number of the entity to get`, true)], true, false, `entity = GetEntByNum( entnum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getEnterButton", `Gets the enter button.`, null, [], true, false, `getEnterButton()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntityAnimRate", `get the entity animation rate - ZOMBIES ONLY`, "entity", [], true, false, `rate = self GetEntityAnimRate()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntityNumber", `Get the entity number of the entity`, "entity", [], true, false, `hitEntNum = hitEnt getEntityNumber()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntityType", `Get the type of entity`, "entity", [], true, false, `inflictorEntType = grenade getEntityType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntNavMaterial", `get NavMesh material at where the entity stands`, null, [new LibraryFunctionParameter("ai_or_vehicle", `An AI character or an AI vehicle`, true)], true, false, `material = GetEntNavMaterial( ai_actor )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEntNum", `Get the entity number for this entity`, "entity", [], true, false, `self GetEntNum()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquipmentHeadObjective", `Returns the equipment head objective as described in the grenadeweapon gdt.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `headObjective = GetEquipmentHeadObjective( bouncingbettty )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedBodyAccentColorForHero", `Returns an array of the equipped body accent colors of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's session mode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table or in case of lobby client, his queue position`, true), new LibraryFunctionParameter("bodyIndex", `The index of the body`, true), new LibraryFunctionParameter("colorIndex", `The index of the accent color`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then we are supposed to retrieve for lobby client`, false)], false, true, `colorArray = GetEquippedBodyAccentColorForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedBodyForHero", `Returns the name of the equipped body model of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true)], false, true, `modelName = GetEquippedBodyForHero( localClientNum, SESSIONMODE_MULTIPLAYER, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedBodyIndexForHero", `Returns the index of the equipped body model of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `Character Session Mode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table or in case of lobby client, his queue position`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then we are supposed to retrieve for lobby client`, false)], false, true, `bodyIndex = GetEquippedBodyIndexForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedCharacterIndexForLobbyClientHero", `Returns the name of the equipped helmet accents colors of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("lobbyClientQueueIndex", `Queue index for lobby client, from which we get all his other information`, true)], false, true, `colorArray = GetEquippedHelmetAccentColorForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHeadIndexForHero", `Returns the index of the equipped head index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then check for the equipped head on the client in the lobbyQueueIndex position`, false)], false, true, `helmetIndex = GetEquippedHeadIndexForHero( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHelmetAccentColorForHero", `Returns the name of the equipped helmet accents colors of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character session mode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true), new LibraryFunctionParameter("helmetIndex", `The index of the helmet`, true), new LibraryFunctionParameter("colorIndex", `The index of the accent color`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then we are supposed to retrieve for lobby client`, false)], false, true, `colorArray = GetEquippedHelmetAccentColorForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHelmetForHero", `Returns the name of the equipped helmet model of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true)], false, true, `modelName = GetEquippedHelmetForHero( localClientNum, SESSIONMODE_MULTIPLAYER, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHelmetIndexForHero", `Returns the index of the equipped helmet index of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table or in case of lobby client, his queue position`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then we are supposed to retrieve for lobby client`, false)], false, true, `helmetIndex = GetEquippedHelmetIndexForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHeroIndex", `Returns the index of the equipped hero for the client`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true)], false, true, `heroIndex = GetEquippedHeroIndex( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedHeroMode", `Returns the mode of the equipped hero for the client`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true)], false, true, `heroIndex = GetEquippedHeroMode( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedLoadoutItemForHero", `Returns 1 if the hero's ability is equipped, 0 if the weapon is equipped.`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true)], false, true, `isAbilityEquipped = GetEquippedLoadoutItemForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEquippedShowcaseWeaponForHero", `Returns the showcase weapon of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("sessionMode", `The character's sessionMode`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table or in case of lobby client, his queue position`, true), new LibraryFunctionParameter("getForLobbyClient", `If this is set then we are supposed to retrieve for lobby client`, false)], false, true, `showcaseWeapon = GetEquippedShowcaseWeaponForHero( localClientNum, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEventPointOfInterest", `Gets the point of interest from the current event.`, "ai_or_player", [], true, false, `point = self GetEventPointOfInterest()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEye", `Get the eye position of the entity.`, "entity", [], true, false, `eye_pos = self GetEye()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEyeApprox", `Get the eye position of the entity with some added offset.`, "entity", [], true, false, `approx_eye_pos = self GetEyeGetEyeApprox()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFirstHeadOfGender", `Returns the first head of gender ("male" or "female")`, null, [new LibraryFunctionParameter("gender", `"male" or "female"`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `headIndex = GetFirstHeadOfGender( "male", "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFirstHeroOfGender", `Returns the first hero of gender ("male" or "female")`, null, [new LibraryFunctionParameter("gender", `"male" or "female"`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `characterIndex = GetFirstHeroOfGender( "male", "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFirstTouchFraction", `Returns the trace fraction of a capsule trace against the other entity`, "entity", [new LibraryFunctionParameter("other entity", `Entity to check against`, true), new LibraryFunctionParameter("start", `Starting point of the trace`, true), new LibraryFunctionParameter("end", `Ending point of the trace`, true)], true, false, `fraction = GetFirstTouchFraction( player, trigger, old_origin, current_origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFlowGraphDef", `returns a struct representing the flow graph definition asset`, null, [new LibraryFunctionParameter("name", `The name of the flow graph asset`, true)], true, true, `flowGraphDef = GetFlowGraphDef( "my_flow_graph" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFogSettings", `Get the current fog settings as an array.`, null, [], true, false, `fogsettings = getfogsettings()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFootstepStrings", `Returns an array containing all the footstep names`, null, [], false, true, `footstepNameArray = GetFootstepStrings()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFreeActorCount", `Get number of free actors.`, null, [], true, false, `GetFreeActorCount()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFreerunTrackIndex", `Returns the unique id for this mission`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.index = GetFreerunTrackIndex( "mp_Freerun_01" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFriendlyScramblerAmount", `Returns the amount alpha of the friendly scrambler applied`, "player", [], false, true, `alpha = player GetFriendlyScramblerAmount( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGadgetPower", `Returns the current power level of the player gadget`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true), new LibraryFunctionParameter("slot", `Slot of the gadget. Default is 0.`, false)], false, true, `power = GetGadgetPower( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGameTypeEnumFromName", `Returns the enum value corresponding to the current game type from global leaderboard gametype entries.`, null, [new LibraryFunctionParameter("gameTypeName", `game type name e.g. "tdm".`, true), new LibraryFunctionParameter("isHardcore", `True if the hardcore mode is on`, true)], true, false, `gameTypeEnum = GetGameTypeEnumFromName( "tdm", false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGametypeSetting", `Gets the value of a gametype setting.`, null, [new LibraryFunctionParameter("setting", `The setting name as a string.`, true)], true, false, `GetGametypeSetting( "scoreLimit" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGrappleTargetArray", `Returns an array of all of the grapple targets`, null, [], true, false, `enemies = GetGrappleTargetArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGroundEnt", `Gets the entity beneath the calling entity`, "entity", [], true, false, `ground_ent = self GetGroundEnt()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeadGender", `Returns the given head's gender ("male" or "female")`, null, [new LibraryFunctionParameter("headIndex", `The index of the head`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `gender = GetHeadGender( headIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHealthOverlayTime", `Returns the time the health overlay has been on`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetHealthOverlayTime( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeliDamageState", `Returns the damage state of the heli.`, null, [], false, true, `vehicle GetHeliDamageState( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHelmetAccentColorCountForHero", `Returns the number of accents for the specified helmet model of a specific hero`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("heroIndex", `The index of the hero in the current game-mode's character table`, true), new LibraryFunctionParameter("helmetIndex", `The index of the helmet for the specific hero`, true)], false, true, `accentColorCount = GetHelmetAccentColorCountForHero( localClientNum, 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroBodyModelIndices", `Returns the given hero's body models for the current session mode`, null, [new LibraryFunctionParameter("heroIndex", `The index of the hero`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `heroBodyModelNames = GetHeroBodyModels( heroIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroes", `Returns all hero indices for the current session mode (or specified session mode)`, null, [new LibraryFunctionParameter("sessionmode", `Session Mode (cp,mp,zm)`, false)], false, true, `heroIndices = GetHeroes()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroGender", `Returns the given hero's gender ("male" or "female")`, null, [new LibraryFunctionParameter("heroIndex", `The index of the hero`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `gender = GetHeroGender( heroIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroHeadModelIndices", `Returns all hero indices for the current session mode`, null, [], false, true, `heroHelmetModelNames = GetHeroHelmetModels( heroIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroHelmetModelIndices", `Returns the given hero's helmet models for the current session mode`, null, [new LibraryFunctionParameter("heroIndex", `The index of the hero`, true), new LibraryFunctionParameter("sessionmode", `The session mode (cp,mp,zm)`, false)], false, true, `heroHelmetModelNames = GetHeroHelmetModelIndices( heroIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHorizontalOffsetFromScreenCenter", `Get the distance from the screen center to the entity`, "entity", [new LibraryFunctionParameter("localClientNum", `Local client to check`, true), new LibraryFunctionParameter("width", `width to check against`, false)], false, true, `ent GetDistanceFromScreenCenter( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInfluenceAt", `Returns the influence value at the origin position on the influence map, undefined if no value can be found.`, null, [new LibraryFunctionParameter("influenceMapIndex", `Index of the influence map`, true), new LibraryFunctionParameter("origin", `The location to check for influence value`, true)], true, false, `GetInfluenceAt(influenceMapIndex, origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInfluenceFacePos", `Returns the faces pos on the influence map`, null, [], true, false, `pos = GetInfluenceFacePos( faceIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInfluenceNumFaces", `Returns the number faces on the influence`, null, [], true, false, `numFaces = GetInfluenceNumFaces()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInfluencerPreset", `Adds a new influencer of <name> at <origin> and <angles>`, null, [new LibraryFunctionParameter("name", `valid spawn influencer preset name.`, true)], true, false, `preset_array = GetInfluencerPreset( name )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInfluencerTimeoutRemaining", `Gets the remaining influencer timeout in milliseconds.  Returns a negative number if no timeout.`, null, [new LibraryFunctionParameter("influencer id", `The influencer id`, true)], true, false, `GetInfluencerTimeout( influencer_id )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInKillcam", `returns if the client is in killcam or not.`, null, [new LibraryFunctionParameter("local_client_num", `The local client to check`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInterestPoolAwareness", `Gets the current interest pool awareness level regardless of actual awareness level.`, "ai", [], true, false, `interestAwareness = self GetInterestPoolAwareness()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInterestPoolValue", `Gets the sentient's interest pool value.`, "ai_or_player", [], true, false, `value = self GetInterestPoolValue()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemArray", `Returns an array of all of the items in a level.`, null, [], true, false, `origins = GetItemArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemAttachment", `Gets the attachment for a particular item`, null, [new LibraryFunctionParameter("itemIndex", `The item index`, true), new LibraryFunctionParameter("attachmentNum", `The attachment number for the index`, true)], true, false, `GetItemAttachment( 10, 1 ); // returns attachment 1 for item 10`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemAttachmentAllocationCost", `Gets the allocation cost of an attachment for a particular item`, null, [new LibraryFunctionParameter("itemIndex", `The item index`, true), new LibraryFunctionParameter("attachmentNum", `The attachment number for the index`, true)], true, false, `GetItemAttachmentAllocationCost( 10, 1 ); // returns allocation cost of attachment 1 for item 10`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemGroupForWeaponName", `Returns the ref for a specific weapon name`, null, [new LibraryFunctionParameter("weaponName", `Name of weapon to get item group`, true)], false, true, `ref = GetItemGroupForWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemGroupFromItemIndex", `Returns the ref for a specified item index`, null, [new LibraryFunctionParameter("itemIndex", `Item index`, true)], true, false, `ref = GetItemGroupFromItemIndex( itemIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetKillCamEntity", `returns the killcamentity.`, null, [new LibraryFunctionParameter("local_client_num", `The local client to check`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetKnownLength", `Get the known length of the sound`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true)], false, true, `length = GetKnownLength( level.mySnd )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLastOutWaterTime", `Returns the last time the player was not completely submerged`, "player", [], true, false, `time = player GetLastOutWaterTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightColor", `Gets the current color of the light, as an RGB vector.`, "light", [], true, false, `color = self GetLightColor()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightExponent", `Gets the current exponent of the light.`, "light", [], true, false, `exponent = self GetLightExponent()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightFovOuter", `Gets the current outer fov of a spot light.`, "light", [], true, false, `fov = self GetLightFovOuter()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightIntensity", `Gets the current intensity of the light.`, "light", [], true, false, `intensity = self GetLightIntensity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightRadius", `Gets the current radius of the light.`, "light", [], true, false, `radius = self GetLightRadius()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLinkedEnt", `Get the entity that the calling entity is linked to`, "entity", [], true, false, `linked_ent = self GetLinkedEnt()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutAllocation", `Get how many allocation points are spent in the custom class`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true)], true, false, `allocationSpent = self GetLoadoutAllocation( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutGunSmithVariantIndex", `Get the GunSmith Variant index of the primary weapon, pass 1 as an option to get the secondary`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true), new LibraryFunctionParameter("getSecondary", `defaults to false, if set will get you the variant index of the secondary`, false)], true, false, `gunSmithPrimaryIndex = self GetLoadoutGunSmithVariantIndex( 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutItem", `Get the index of the item in the custom class`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true), new LibraryFunctionParameter("loadoutSlot", `Loadout Slot`, true)], true, false, `primary = self GetLoadoutItem( 0, primary )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutItemRef", `Get the reference of the item in the custom class`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true), new LibraryFunctionParameter("loadoutSlot", `Loadout Slot`, true)], true, false, `primary = self GetLoadoutItemRef( 0, primary )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutPerks", `Get the list of specialties in the custom class`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true)], true, false, `primary = self GetLoadoutPerks( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLoadoutWeapon", `Get the full weapon name (including attachments) of the item in the custom class`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true), new LibraryFunctionParameter("loadoutSlot", `Loadout Slot (primary or secondary)`, true)], true, false, `primary = self GetLoadoutWeapon( 0, primary )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLobbyClientCount", `Returns the number of connected or connecting clients`, null, [], true, false, `clientCount = GetClientCount()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientAngles", `Get the local client angles`, null, [new LibraryFunctionParameter("client", `the client to get angles for`, true)], false, true, `client_angles = GetLocalClientAngles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientDriver", `Returns the local client index of the driver of the vehicle if the driver is a local client or undefined.`, "vehicle", [], false, true, `driver = self GetLocalClientDriver( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientEyePos", `Gets the local client eye pos`, null, [new LibraryFunctionParameter("client", `the client to get eye pos for`, true)], false, true, `eye_pos = GetLocalClientEyePos( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientFOV", `Get the local client field of view in degrees`, null, [new LibraryFunctionParameter("client", `the client index to get fov for`, true)], false, true, `client_fov = GetLocalClientFOV()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientNumber", `Returns the local client number.`, "player", [], false, true, `clientNum = self GetLocalClientNumber()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalClientPos", `Returns pos of localclient`, null, [new LibraryFunctionParameter("client", `the client to get position`, true)], false, true, `origin = GetLocalClientPos( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalGunnerAngles", `Returns the angles of the specified gunner, local to the vehicle itself.`, "vehicle", [new LibraryFunctionParameter("gunnerIndex", `The index of the gunner seat`, true)], false, true, `localAngles = self GetLocalGunnerAngles( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalPlayer", `Get the local player predicted centity.`, null, [new LibraryFunctionParameter("local client num", `local client`, true)], false, true, `GetLocalPlayer( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalPlayers", `Get an array of all the local players`, null, [], false, true, `players = GetLocalPlayers()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLocalPlayerTeam", `Gets the team of the local player`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client to check`, true)], false, true, `team = GetLocalPlayerTeam( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapAtIndex", `Get the name of the map at the given index in a mode's maptable.  Returns undefined if the given index doesn't index the given maptable`, null, [new LibraryFunctionParameter("index", `the index of the map you're looking for.`, true), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, true, `GetMapAtIndex( "cp_mi_sing_blackstation" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapFields", `Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, true, `fields = GetMapFields( GetNextMap("cp_mi_sing_blackstation") )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapIntroMovie", `Get the intro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, false, `world.nextIntroMovie = GetMapIntroMovie( GetNextMap("cp_mi_sing_blackstation") )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapOrder", `Get the index of the current map in the maptable.  Returns -1 if currentmap wasn't found`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, false, `if( GetMapOrder( "cp_mi_sing_blackstation" ) > GetMapOrder( world.highestMapCompletion ) { world.highestMapCompletion = "cp_mi_sing_blackstation"; }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapOutroMovie", `Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, false, `world.nextOutroMovie = GetMapIntroMovie( GetNextMap("cp_mi_sing_blackstation") )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMaxLocalClients", `Get the max number of local clients`, null, [], false, true, `max_clients = GetMaxLocalClients()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMaxReverseSpeed", `Get maximum reverse speed of a vehicle.`, "vehicle", [], false, true, `speed = vehicle GetMaxReverseSpeed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMaxs", `Get maximum bounds of the entity`, "entity", [], true, false, `maxs = wallModel GetMaxs()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMaxVehicles", `Return the maximum number of vehicles that can be instantiated simultaneously.  This is platform-specific.`, null, [], true, false, `vehicleSlotsFree = GetMaxVehicles() - level.vehicles_list.size`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMeleeChainCount", `Gets the number of melee kills achieved by the player within their current streak.`, "entity", [], true, false, `entity GetMeleeChainCount( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getmicrosecondsraw", `Gets raw system microseconds; used for profiling, only gives lower 32 bits as script doesn't support uint64_t properly right now`, null, [], true, false, `start_time = GetMicrosecondsRaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMigrationStatus", `undefined`, null, [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMillisecondsRaw", `Gets raw system milliseconds; use for profiling long routines as it is only an integer`, null, [], true, false, `start_time = GetMillisecondsRaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMins", `Get minimum bounds of the entity`, "entity", [], true, false, `mins = wallModel GetMins()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMissileOwner", `Returns the entity that owns this missile`, "missile", [], true, false, `javelinOwner = GetMissileOwner( thisMissile )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMissionName", `Returns the name of the mission this map is part of`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.mission = GetMissionName( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMissionUniqueID", `Returns the unique id for this mission`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.unique_id = GetMissionUniqueID( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMissionVersion", `Returns the unique id for this mission`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.unique_id = GetMissionVersion( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMoveDelta", `Gets the move delta for the animation`, null, [new LibraryFunctionParameter("animation name", `Name of the animation`, true), new LibraryFunctionParameter("start time", `Normalized start time of the animation`, false), new LibraryFunctionParameter("end time", `Normalized end time of the animation`, false), new LibraryFunctionParameter("entity", `The entity should be passed if the animation name is a string to look up the animation from the entity's anim tree`, false)], true, false, `localDeltaVector = GetMoveDelta( animation, 0, 1, entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMovementType", `Returns the movement type for the entity`, "entity", [], false, true, `movement_type = self GetMovementType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMoverEnt", `Gets the moving entity the player is sitting on .`, "player", [], true, false, `if(player GetMoverEnt())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMoveSpeedScale", `Gets the speed scale multiplier for the entity`, "entity", [], true, false, `speed_modifier = self GetMoveSpeedScale()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNavMeshFaceNormal", `Returns the face normal vector of the closest navmesh point to the passed in position, within the search radius.`, null, [new LibraryFunctionParameter("position", `Position to start the search around.`, true), new LibraryFunctionParameter("searchRadius", `Radius to search within.`, true)], true, false, `navmeshNormal = GetNavMeshFaceNormal( (10,20,30), 25 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNavMeshTriggersForPoint", `Returns a list of the names of navmesh triggers that a given point resides in`, null, [new LibraryFunctionParameter("pos", `The test position.`, true)], true, false, `targetNames = GetNavMeshTriggersForPoint( pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNearestNode", `Returns the node nearest to this origin or undefined if no close node exists.`, null, [new LibraryFunctionParameter("origin", `location to search for the nearest node`, true)], true, false, `node = GetNearestNode( guy.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNearestPathPoint", `Returns the nearest point on the navmesh for the given origin and radius or undefined if no point can be found.`, null, [new LibraryFunctionParameter("origin", `The point from which to search from`, true), new LibraryFunctionParameter("radius", `The maximum radius in which to search`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNextMap", `Get the name of the next map in the maptable.  Returns "" if this is the last map, undefined if currentmap wasn't found`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false), new LibraryFunctionParameter("dlcindex", `dlc1..N if DLC.  If ommitted, use "base".`, false), new LibraryFunctionParameter("sessionmodeabbrev", `cp,mp,zm.  If ommitted, use current game mode abbreviation`, false)], true, false, `GetNextMap( "cp_mi_sing_blackstation" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNextTraversalNodeOnPath", `undefined`, null, [new LibraryFunctionParameter("start", `the  index for the starting node`, true)], true, false, `GetNextTraversalNodeOnPath(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNode", `Gets a node with the given name, key pair`, null, [new LibraryFunctionParameter("name", `name to search for`, true), new LibraryFunctionParameter("key", `key that name goes with`, true)], true, false, `node = GetNode( self.target, "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeArray", `Gets an array of nodes that have the given name, key pair`, null, [new LibraryFunctionParameter("name", `name to search for`, true), new LibraryFunctionParameter("key", `key that name goes with`, true)], true, false, `node = GetNodeArray( self.target, "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeArraySorted", `Gets an array of nodes that have the given name, key pair, within given radius, sorts them`, null, [new LibraryFunctionParameter("name", `name to search for`, true), new LibraryFunctionParameter("key", `key that name goes with`, true), new LibraryFunctionParameter("pos", `search origin`, true), new LibraryFunctionParameter("r", `the radius to sort in`, true)], true, false, `nodes = GetNodeArraySorted(self.target, "targetname", self.origin, 256 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeEdge", `Returns an array of points which corresponds to the node volume's traversal edge. The traversal edge is represented as a piecewise linear function.`, null, [new LibraryFunctionParameter("node", `node volume`, true)], true, false, `points = GetNodeEdge( myNode )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeIndexOnPath", `undefined`, null, [new LibraryFunctionParameter("node", `The node to get the other node for`, true)], true, false, `GetNodeIndexOnPath(node)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeOwner", `Get the owner of the node.`, null, [new LibraryFunctionParameter("node", `which node to get the owner of.`, true)], true, false, `node_owner = GetNodeOwner( node ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeRegion", `Returns the region of the give node, if there is one. Returns undefined otherwise.`, null, [new LibraryFunctionParameter("node1", `pathnode to check`, true)], true, false, `if ( GetNodeRegion( myNode ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodesInRadius", `Gets all of the nodes (max of 256) within a cylinder, in unsorted order`, null, [new LibraryFunctionParameter("origin", `location to search for nodes at`, true), new LibraryFunctionParameter("max radius", `maximum distance of nodes to return`, true), new LibraryFunctionParameter("min radius", `maximum distance of nodes to return`, true), new LibraryFunctionParameter("max height", `maximum height difference to origin. Defaults to 512`, false), new LibraryFunctionParameter("node type", `node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes`, false), new LibraryFunctionParameter("max nodes", `the maximum number of nodes to return up to 256`, false), new LibraryFunctionParameter("region index", `the region index the nodes should belong to`, false)], true, false, `nodes = GetNodesInRadius( guy.origin, 512, 0, 128, "Path" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodesInRadiusSorted", `Gets all of the nodes (max of 256) within a cylinder, sorted by closest to <origin>`, null, [new LibraryFunctionParameter("origin", `location to search for nodes at`, true), new LibraryFunctionParameter("max radius", `maximum distance of nodes to return`, true), new LibraryFunctionParameter("min radius", `maximum distance of nodes to return`, true), new LibraryFunctionParameter("max height", `maximum height difference to origin. Defaults to 512`, false), new LibraryFunctionParameter("node type", `node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes`, false), new LibraryFunctionParameter("max nodes", `the maximum number of nodes to return up to 256`, false)], true, false, `nodes = GetNodesInRadiusSorted( guy.origin, 512, 0, 128, "Path" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNonPredictedLocalPlayer", `Get the local player non predicted centity.`, null, [new LibraryFunctionParameter("local client num", `local client`, true)], false, true, `GetNonPredictedLocalPlayer( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNormalHealth", `Get health in a normalized range of 0 to 1`, "entity", [], true, false, `normal_health = self GetNormalHealth()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNorthYaw", `Get North Yaw`, null, [], true, false, `northvector = (cos(getnorthyaw()), sin(getnorthyaw()), 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNotetracksInDelta", `Get a list of notetracks and times within a specific time delta of a specific time in an animation`, null, [new LibraryFunctionParameter("animation", `the animation for which notetrack information is needed`, true), new LibraryFunctionParameter("time", `The time in the animation around which notetrack information is needed in the range 0-1`, true), new LibraryFunctionParameter("time_delta", `The amount of time around the time provided to check for notetracks in seconds defaults to 0.15`, false)], true, false, `notetrackArray = GetNotetracksInDelta( anim, 0.4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNotetrackTimes", `Gets an array of the times during an animation that the given notetrack occurs. The times returned are fractional (0 to 1).`, null, [new LibraryFunctionParameter("animation", `an animation`, true), new LibraryFunctionParameter("note track", `a constant string with the name of the note track`, true)], true, false, `exitAlignTimes = GetNotetrackTimes( exitAnim, "exit_align" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumberOfCollectiblesForLevel", `Returns the number of collectibles for the given level`, null, [], true, false, `collectibleCount = GetNumberOfCollectiblesForLevel( GetRootMapName() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumChallengesComplete", `Returns the number of challenges completed in a given mission`, "player", [new LibraryFunctionParameter("mission_name", `(string) The name of the mission to check completed challenges in`, true)], true, false, `is_default = self GetNumChallengesComplete( "angola" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumConnectedPlayers", `Returns the number of players that are connected to our game.  Ignores bots by default.`, null, [new LibraryFunctionParameter("include bots", `The optional check to include test clients (bots). (bool)`, false)], true, false, `num_players_and_bots = GetNumConnectedPlayers( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumExpectedPlayers", `Returns the number of players that we're expecting to join our game.`, null, [], true, false, `num_players = GetNumExpectedPlayers()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumFreeEntities", `Get the number of free fake entities`, null, [new LibraryFunctionParameter("local client number", `Which local client to spawn the entity for.`, true)], false, true, `numfree = GetNumFreeEntities( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumParts", `Return number of bones in the model`, null, [new LibraryFunctionParameter("model", `The model to get parts for`, true)], true, false, `numParts = GetNumParts( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumZBarrierPieces", `Returns number of pieces in specified zbarrier ent.`, "entity", [], true, false, `numPieces = ent GetNumZBarrierPieces())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOrigin", `Get the origin of the entity`, "entity", [], true, false, `origin = self GetOrigin()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOtherNodeInNegotiationPair", `Returns the other node of the passed in negotiation node. Returns the begin node if end is passed and vice versa.`, null, [new LibraryFunctionParameter("node", `The node to get the other node for`, true)], true, false, `end_node = GetOtherNodeInNegotiationPair( begin_node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOwner", `Get an entity's owner`, "entity", [new LibraryFunctionParameter("localClientNum", `Local client to check`, true)], false, true, `ent GetOwner( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetParentEntity", `Gets the parent entity.  Requires client-side linking to be set up on the entity.`, "entity", [], false, true, `parent = self GetParentEntity( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPartName", `Get the bone name for the model and index`, null, [new LibraryFunctionParameter("model", `The model to get parts for`, true), new LibraryFunctionParameter("index", `The bone index`, true)], true, false, `boneName = GetPartName( model, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathfindingRadius", `Returns the radius used for pathfinding operations.`, "entity", [], true, false, `radius = ent GetPathfindingRadius()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathMetric", `Get path metric for the path from the ai to origin`, "entity", [new LibraryFunctionParameter("origin", `the goal for the path`, true)], true, false, `path_metric = level.ai_for_pathing GetPathMetric( dropPos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlaybackTime", `Get the playback time for the sound given by playbackId`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true)], false, true, `time = GetPlaybackTime( level.mySnd )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerCorpse", `Gets the most recent corpse fort he player`, null, [], false, true, `cybercom_type = player GetPlayerCorpse()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerGibDef", `Returns string of gibdef for current player`, "player", [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerGravity", `Gets the gravity or gravity override value for the player.`, "player", [], true, false, `player GetPlayerGravity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerLastOutWaterTime", `Gets the last time the player was not underwater`, "entity", [], false, true, `waterTime = player GetPlayerLastOutWaterTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerName", `Gets the character index`, "player", [], false, true, `player_name = self GetPlayerName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSelectedGestureName", `Get the equipped gesture animation name`, "player", [new LibraryFunctionParameter("gestureType", `The type of gesture to get`, true)], true, false, `gesture = player GetPlayerSelectedGestureName( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSelectedTauntName", `Get the equipped taunt animation name`, "player", [new LibraryFunctionParameter("tauntType", `The type of taunt to get`, true)], true, false, `taunt = player GetPlayerSelectedTauntName( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSpawnId", `Returns the current spawn id for the player (used for debugging purposes only)`, null, [new LibraryFunctionParameter("player", `The player that we are spawning in`, true)], true, false, `spawnId = GetPlayerSpawnId( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSpeed", `Gets the speed value for the player.`, "player", [], true, false, `player GetPlayerSpeed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerVehicle", `Returns undefined if the player is not in a vehicle`, null, [new LibraryFunctionParameter("player", `The player to check vehicle for`, true)], false, true, `vehicle = GetPlayerVehicle( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPointInBounds", `Returns a point within an entity's bounds.`, "entity", [new LibraryFunctionParameter("ratio_ForwardBack", `1.0 is full forward, -1.0 is full backwards.`, true), new LibraryFunctionParameter("ratio_LeftRight", `1.0 is full left, -1.0 is full right.`, true), new LibraryFunctionParameter("ratio_UpDown", `1.0 is full up, -1.0 is full down.`, true)], true, false, `targetForwardPnt = helo GetPointInBounds( 1.0, 0.0, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPrimaryDeltaAnim", `Returns the primary delta anim playing on this entity, or the name of the animation if the entity is in an animscripted state.`, "entity", [], false, true, `anim = self GetPrimaryDeltaAnim()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRandomCompatibleAttachmentsForWeapon", `Returns an array of compatible attachments. If num desired attachments are specified then that many attachments will be returned if possible`, null, [new LibraryFunctionParameter("weapon", `The weapon name.`, true), new LibraryFunctionParameter("num desired attachments", `Max number of compatible attachments desired. If the number is more than available attachments for the weapon, it will just not return that many.`, false)], true, false, `GetRandomCompatibleAttachmentsForWeapon( weaponObject, 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRandomPointOnNavVolume", `Get a random point on nav volume. Returns the position if found one, or undefined if not found.`, "flying_ai", [], true, false, `random = self GetRandomPointOnNavVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRealTime", `Get the real system time in milliseconds`, null, [], false, true, `time = GetRealTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRefFromItemIndex", `Returns the ref for a specified item index`, null, [new LibraryFunctionParameter("itemIndex", `Item index`, true)], true, false, `ref = GetRefFromItemIndex( itemIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetReflectionLocs", `Gets array of the locations of all of the reflection_probes in the level`, null, [], true, false, `reflection_locs = GetReflectionLocs()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetReflectionOrigin", `Given a position, returns the position of the reflection probe in use there`, null, [], true, false, `probe_pos = GetReflectionOrigin( camera_pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRetrievableWeapons", `Returns an array of weapons that need watchers so they can be retrieved by the player.`, null, [], true, false, `retrievableWeapons = GetRetrievableWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRevealPulseMaxRadius", `Returns the max radius for the reveal vision pulse`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetRevealPulseMaxRadius( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRevealPulseOrigin", `Returns the pulse origin for the local client reveal pulse`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetRevealPulseOrigin( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRevealPulseRadius", `Returns the radius for the local client reveal pulse`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetRevealPulseRadius( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRootMapName", `Returns the root map of a mission`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.rootMap = GetRootMapName( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRope", `Returns the rope index based on targetname. Use it for ropes setuped in radiant. Returns -1, if not found.`, null, [new LibraryFunctionParameter("targetname", `The targetname of the rope you interested in`, true)], false, true, `GetRope( "testrope" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetRoundsPlayed", `Get rounds played in match state`, null, [new LibraryFunctionParameter("value", `The number of rounds played`, true)], true, false, `GetRoundsPlayed( game["roundsplayed"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptBundle", `Returns the script bundle struct.`, null, [], true, true, `settings = GetScriptBundle( "doorsettings" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptBundleList", `Returns the script bundle list array.`, null, [], true, true, `settings = GetScriptBundleList( "doorsettings" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptBundleNames", `Returns all the names of the script bundles of the specified type in an array.`, null, [], true, true, `settings = GetScriptBundleNames( "scene" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptBundles", `Returns a list of script bundles based on the type.`, null, [], true, true, `settings = GetScriptBundles( "scenes" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptMoverArray", `Returns an array of all of the script_origins in a level.`, null, [], true, false, `origins = GetScriptMoverArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetServerHighestClientFieldVersion", `Returns the server's highest clientfield version.`, null, [], false, true, `if ( my_version < GetServerHighestClientFieldVersion() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetShootAtPos", `Gets the position an attacker would shoot at to hit this entity.For AI or player this is the eye position.For other entities it's the tag_eye if there is one else the center of the entity bounding box.`, "entity", [new LibraryFunctionParameter("attacker", `The entity that will be shooting`, false)], true, false, `targetPos = self.enemy GetShootAtPos(self)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetShoutcasterSetting", `Gets the value of a shoutcaster setting.`, null, [new LibraryFunctionParameter("setting", `The setting name as a string.`, true)], false, true, `GetGametypeSetting( "who is going to win" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSkiptoName", `Get the skip to name with the given index`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSkipTos", `Get all skip tos for the level`, null, [], true, false, `skiptos = GetSkipTos()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSnapshotIndexArray", `Returns an array of the indices of current snapshots for all connected clients.`, null, [], true, false, `snapindices = GetSnapshotIndexArray( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSoundFromSurfaceTable", `Returns the fx for a given surface type from the surfacefxtable.`, null, [new LibraryFunctionParameter("surfacefxtable", `Surface fx table.`, true), new LibraryFunctionParameter("surface type", `Surface type`, true)], false, true, `fx = GetSoundFromSurfaceTable( fx_surface_table, surface_type )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpawnerArray", `Returns an array of all of the spawners in a level.`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `spawners = GetSpawnerArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpawnerTeamArray", `Returns an array of all of the spawners in a level`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', or 'neutral'`, true), new LibraryFunctionParameter("team", `any number of additional team names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `enemies = GetSpawnerTeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpawnStructForCharacter", `Returns the targetname of the script_struct to use for the character pose in the frontend`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `frontendVignetteAnim = GetSpawnStructForCharacter( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpecialistIndex", `Returns the specialist index for the player`, "player", [], true, false, `specialistIndex = player GetSpecialistIndex()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStance", `Gets the stance of the player. It only works for the player.`, "player", [], true, false, `stance = player GetStance()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStartAngles", `Get the starting angles for an animation, in world coordinates, given its current position, and angles`, null, [new LibraryFunctionParameter("origin", `The current origin of the animation in world coordinates`, true), new LibraryFunctionParameter("angle", `The current angle set of the animation in world coordinates`, true), new LibraryFunctionParameter("animation", `The currently running animation`, true), new LibraryFunctionParameter("animation time", `The animation time in 0-1 range`, false)], true, false, `org1 = GetStartAngles( climborg, climbang, buddyanim1, [0.5] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStartOrigin", `Get the starting origin for an animation, in world coordinates, given its current position, and angles`, null, [new LibraryFunctionParameter("origin", `The current origin of the animation in world coordinates`, true), new LibraryFunctionParameter("angle", `The current angle set of the animation in world coordinates`, true), new LibraryFunctionParameter("animation", `The currently running animation`, true), new LibraryFunctionParameter("animation time", `The starting animation time in 0-1 range`, false)], true, false, `org1 = GetStartOrigin( climborg, climbang, buddyanim1, [0.5] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStartTime", `Returns the start time for the current round.`, null, [], true, false, `GetStartTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStowedWeapon", `Gets the stowed weapon for the player`, "entity", [], true, false, `stowed = self GetStowedWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStreamerRequestProgress", `Get the progress (between 0-100) of the streamer request slot`, null, [new LibraryFunctionParameter("slot", `Request slot`, true)], false, true, `getStreamerRequestProgress(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStreamingProgress", `Gets a progress value between 0 (no progress) and 1 (complete) for all the models and meshes that the script is currently forcing`, null, [], false, true, `progress = GetStreamingProgress()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTagAngles", `Gets the angles of the tag`, "entity", [], true, false, `angles = self GetTagAngles( "tag" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTagOrigin", `Gets the origin of the tag`, "entity", [], true, false, `origin = self GetTagOrigin( "tag" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTargetEntity", `Gets the target entity of this turret or vehicle weapon`, "turret_or_vehicle", [new LibraryFunctionParameter("gunnerIndex", `the gunner index if called on a vehicle`, false)], true, false, `target = roof_turret GetTargetEntity( ); target = tank GetTargetEntity( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTargetLockEntity", `Get locked target`, null, [new LibraryFunctionParameter("localclientnum", `localclientnum`, true)], false, true, `target = self GetTargetLockEntity(<localclientnum>)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTargetLockEntityArray", `Get locked target`, null, [], false, true, `target = self GetTargetLockEntityArray(<localclientnum>)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTargetOrigin", `Gets the target origin of this turret or vehicle weapon`, "turret_or_vehicle", [new LibraryFunctionParameter("gunnerIndex", `the gunner index if called on a vehicle (integer)`, false)], true, false, `origin = roof_turret GetTargetOrigin( ); origin = tank GetTargetOrigin( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTeam", `Return true if the team of an entity if it can be found, undefined otherwise.`, "entity", [], true, false, `orig_team = self GetTeam()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTeamPlayersAlive", `Returns the number of players still alive on a given team`, null, [new LibraryFunctionParameter("team", `A string value, either 'axis' or 'allies' or 'team3'`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTeamSatellite", `Gets whether a team has Satellite or not`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.`, true)], true, false, `GetTeamSatellite( "allies" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTeamScore", `Get a team's score`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either 'axis' or 'allies' or 'team3'.`, true)], true, false, `if ( GetTeamScore( "allies" ) > getTeamScore("axis") ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTeamSpyplane", `Gets whether a team has Spyplane or not`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.`, true)], true, false, `GetTeamSpyplane( "allies" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTime", `Gets the level time in Milliseconds from the start of the level.`, null, [], true, false, `nextNodeTime = GetTime() + 500`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersBodyModel", `Returns the name of the equipped body model of the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `modelName = GetTopPlayersBodyModel( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersBodyRenderOptions", `Returns the render options for the body for the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `renderOptions = GetTopPlayersBodyRenderOptions( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersGesture", `Returns the selected gesture of type CharacterGestureTypes for the given player`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true), new LibraryFunctionParameter("CharacterGestureTypes", `The CharacterGestureTypes enum value of the gesture to use`, true)], false, true, `gesture_anim = GetTopPlayersGesture( localClientNum, 2, 2 );	// GESTURE_TYPE_BOAST = 2`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersHelmetModel", `Returns the name of the equipped helmet model of the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `modelName = GetTopPlayersHelmetModel( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersHelmetRenderOptions", `Returns the render options for the body for the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `renderOptions = GetTopPlayersHelmetRenderOptions( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersIndex", `Returns the index of the client array or undefined if the client player is not a top scorer`, null, [new LibraryFunctionParameter("localClientNum", `Local client`, true)], false, true, `topPlayerIndex = self GetTopPlayersIndex( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersTaunt", `Returns the selected taunt of type CharacterTauntTypes for the given player`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true), new LibraryFunctionParameter("CharacterGestureTypes", `The CharacterTauntTypes enum value of the taunt to use`, true)], false, true, `taunt_anim = GetTopPlayersTaunt( localClientNum, 2, 0 );	// TAUNT_TYPE_FIRST_PLACE = 0`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersTeam", `Returns the team of the player top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `team = GetTopPlayersTeam( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersWeaponInfo", `Returns the equipped weapon of the top player in the game`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `weapon = GetTopPlayersWeaponInfo( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersWeaponModel", `Returns the name of the equipped weapon model of the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `modelName = GetTopPlayersWeaponModel( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopPlayersWeaponRenderOptions", `Returns the render options for the weapon for the top player in the game by index`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true), new LibraryFunctionParameter("topPlayerIndex", `The index of the top player`, true)], false, true, `renderOptions = GetTopPlayersWeaponRenderOptions( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTopScorerCount", `Returns the number of clients in the top scorers array`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum of the player in question`, true)], false, true, `numClients = GetTopScorerCount( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTotalAmmo", `Returns the total amount of ammo the client has for the currently equipped weapon`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true), new LibraryFunctionParameter("weaponName", `Name of the desired weapon to check`, true)], false, true, `ammoCount = GetTotalAmmo( localClientNum, "ak47_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTotalServerPauseTime", `Gets the total time the server has been paused since the map started.`, null, [], true, false, `val = GetTotalServerPauseTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("gettotalunlockedweaponattachments", `Get total number of attachments that are unlocked for the weapon specified`, null, [new LibraryFunctionParameter("weapon", `weapon`, true)], true, false, `player GetTotalUnlockedWeaponAttachements( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTouchingVolume", `Get the entities that are inside the bounds given`, null, [new LibraryFunctionParameter("origin", `Position of bounding box`, true), new LibraryFunctionParameter("mins", `The minimum extents of the bounding box`, true), new LibraryFunctionParameter("maxs", `The maximum extents of the bounding box`, true)], true, false, `entities = GetTouchingVolume( self.origin, mins, maxs )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTriggerAccumulate", `Returns the accumulate value from the trigger`, "trigger", [], true, false, `self GetTriggerAccumulate()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretArcLimits", `Return turret info for arc mins and maxs`, "turret", [], true, false, `limits turret GetTurretArcLimits()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretOwner", `Gets the "owner" of this turret`, "turret", [], true, false, `turret_user = roof_turret GetTurretOwner()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretTarget", `Gets the current target of this turret`, "turret", [], true, false, `target = roof_turret GetTurretTarget()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetUpgradedPieceNumLives", `Returns the number of lives, or pull reps it should take a zombie to dislodge this piece, if it's upgraded.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `piece.numLives = ent GetUpgradedPieceNumLives(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetUTC", `Gets the UTC time.`, null, [], true, false, `val = GetUTC()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetValidCoverPeekOuts", `Returns an array of directions an AI can peek out from a cover node. Possible values are 'over', 'left', and 'right'.`, "pathnode", [], true, false, `GetValidCoverPeekOuts( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleArray", `Returns an array of all of the vehicles in a level`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `enemies = GetVehicleArray( "drones", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleSpawnerArray", `Returns an array of all of the vehicle spawners in a level`, null, [new LibraryFunctionParameter("name", `Name to search for.`, false), new LibraryFunctionParameter("key", `The key to search for.`, false)], true, false, `enemies = GetVehicleSpawnerArray( "bob", "targetname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleSpawnerTeamArray", `Returns an array of all of the vehicle spawners in a level with the specified team`, null, [new LibraryFunctionParameter("team", `a team name, either 'axis', 'allies', or 'neutral'`, true), new LibraryFunctionParameter("team", `any number of teams names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `enemies = GetVehicleSpawnerTeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleTeamArray", `Returns an array of all of the vehicles in a level that are not sentients`, null, [new LibraryFunctionParameter("team", `any number of teams names may be added, either 'axis', 'allies', or 'neutral'`, false)], true, false, `enemies = GetVehicleTeamArray( "axis", "neutral" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleTriggerFlags", `Returns the spawn flags that will allow vehicles to activate triggers`, null, [], true, false, `spawn("trigger_radius", (0,0,0), GetVehicleTriggerFlags())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVelocity", `Returns the entity's velocity.`, "entity", [new LibraryFunctionParameter("entity", `An entity.`, true)], true, false, `vel = thing GetVelocity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVisibleNode", `Returns the farthest visible node on the path from <start> to <end> or undefined if no path exists.`, null, [new LibraryFunctionParameter("start", `starting origin of the path`, true), new LibraryFunctionParameter("end", `ending origin of the path`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore during pathnode trace checks`, false)], true, false, `node = GetVisibleNode( guy.origin, enemy.origin, guy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVisibleNodes", `Returns an array of nodes visible to this node`, null, [new LibraryFunctionParameter("node", `pathnode to check`, true)], true, false, `nodes = GetVisibleNodes( cover.node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVisionPulseMaxRadius", `Returns the max radius for the localClients vision pulse`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetVisionPulseMaxRadius( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVisionPulseRadius", `Returns the current radius for the localClients vision pulse`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `power = GetVisionPulseRadius( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getvrcamangles", `Get the VR camera angles of the player`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRCamAnglesByLocalClientNum", `Get the camera angles of the local client given`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `cam_angles = GetVRCamAnglesByLocalClientNum( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getvrcampos", `Get the VR camera position of the player`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRCamPosByLocalClientNum", `Get the camera position of the local client given`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `cam_origin = GetVRCamPosByLocalClientNum( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRControllerAngles", `gets the world-space angles of the tracked VR controller`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want the orientation of`, true), new LibraryFunctionParameter("handIdx", `0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist`, true)], false, true, `pos = self GetVRControllerAngles( 0, (60, 0, 0) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRControllerGripButton", `returns true if the grip button is pressed`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want`, true), new LibraryFunctionParameter("handIdx", `0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist`, true)], false, true, `holding = self GetVRControllerGripButton( 0 ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRControllerPosition", `gets the world-space position of the tracked VR controller`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want the position of`, true), new LibraryFunctionParameter("handIdx", `0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist`, true)], false, true, `pos = self GetVRControllerPosition( 0 ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVRControllerXButton", `returns true if the grip button is pressed`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want`, true), new LibraryFunctionParameter("handIdx", `0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist`, true)], false, true, `holding = self GetVRControllerXButton( 0 ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWallRunWallNormal", `Returns the normal of the wall the player is running on (or was running on)`, "player", [], true, false, `wall_normal = player GetWallRunWallNormal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWatcherWeapons", `Returns array of weapons that need watchers so they will die when the player respawns`, null, [], true, false, `watcherWeapons = GetWatcherWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWaterHeight", `Returns the height of the water at this position`, null, [new LibraryFunctionParameter("pos", `Query position`, true)], true, false, `height = getwaterheight( self.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeapon", `Get the requested weapon object based on game mode agnostic weapon name string`, null, [new LibraryFunctionParameter("weaponname", `the name of the base weapon to return`, true), new LibraryFunctionParameter("attachmentname_1 or array of attachments", `the name of the first attachment to return`, false), new LibraryFunctionParameter("attachmentname_2", `the name of the second attachment to return`, false), new LibraryFunctionParameter("attachmentname_3", `the name of the third attachment to return`, false), new LibraryFunctionParameter("attachmentname_4", `the name of the fourth attachment to return`, false), new LibraryFunctionParameter("attachmentname_5", `the name of the fifth attachment to return`, false), new LibraryFunctionParameter("attachmentname_6", `the name of the sixth attachment to return`, false), new LibraryFunctionParameter("attachmentname_7", `the name of the seventh attachment to return`, false), new LibraryFunctionParameter("attachmentname_8", `the name of the eighth attachment to return`, false)], true, false, `GetWeapon( "ar_standard", "acog" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAccuracy", `Returns accuracy at the distance from the current enemy.`, null, [new LibraryFunctionParameter("entity", `An entity. Must be AI.`, true), new LibraryFunctionParameter("weapon name", `The weapon name.`, true)], true, false, `getweaponaccuracy( self, "ak47" ), getweaponaccuracy( ai, ai.primaryweapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAttachments", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponChargeLevel", `Get the current charge level for charged shot weapons`, null, [], false, true, `charge = player GetWeaponChargeLevel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponForCharacter", `Returns the weapon at the given index`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `modelName = GetWeaponForCharacter( 0, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponForwardDir", `Returns the weapon's forward direction`, "weapon", [], true, false, `weapon GetWeaponForwardDir()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponHackRatio", `Get the players hack completion ratio`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `GetWeaponHackRatio(localClientNum, 1, "hotgun_zm")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponModelForCharacter", `Returns the name of the weapon model of at the given index`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `modelName = GetWeaponModelForCharacter( 0, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponMuzzlePoint", `Returns the weapon's muzzle point`, "weapon", [], true, false, `weapon GetWeaponMuzzlePoint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponOptic", `Gets the weapon optic attachment name`, "player", [new LibraryFunctionParameter("weapon", `Weapon name`, true)], true, false, `attachmentName = player GetWeaponOptic( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponPosFrac", `Gets the weapon pos frac of the player. It only works for the player.`, "player", [new LibraryFunctionParameter("local client num", `Player to get weapon pos frac for.`, true)], false, true, `if ( player GetWeaponPosFrac(0) > 0.5 ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponWithAttachments", `Get the requested weapon object`, null, [new LibraryFunctionParameter("weaponname", `the name of the base weapon with attachments to return`, true)], false, true, `GetWeapon( "mp7_mp+acog" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponWorldModel", `Returns weaopn world model`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `model = GetWeaponWorldModel("lmg")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponXCam", `Get the weapon XCam`, null, [new LibraryFunctionParameter("weapon object", `The weapon entity`, true), new LibraryFunctionParameter("camera", `The camera to get`, true)], true, false, `weapon GetWeaponXCam( GetWeapon( weaponName ), "cam_cac_weapon" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetXCamForCharacter", `Returns the name of the xcam to use for the character pose in the frontend`, null, [new LibraryFunctionParameter("characterIndex", `The index of the character in the current game-mode's character table`, true), new LibraryFunctionParameter("sessionmode", `Session Mode Index`, true)], true, true, `frontendVignetteAnim = GetXCamForCharacter( characterIndex, "mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetXCamMouseControl", `Get the current "yaw" and "pitch" of the mouse xcam.  Returns an array with two keys, "yaw" and "pitch".`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the controller you want the mouse yaw/pitch of`, true)], false, true, `xcammouse = GetXCamMouseControl( localclientnum ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetXModelCenterOffset", `Calculates the offset to the center of the model from the origin`, null, [new LibraryFunctionParameter("modelname", `The name of the xmodel`, true)], true, true, `offset = GetXModelCenterOffset( "modelname" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierArray", `Returns an array of all of the zbarrier objects in a level.`, null, [], true, false, `zbarriers = GetZBarrierArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierAttackSlotHorzOffset", `Returns the horizontal offset used to offset the position of each attack slot relative to the zbarrier object.  Odd numbers will start in the center of the barrier and offset to each side.  Even numbers will start each side of the center - with no central spot specified.`, "entity", [], true, false, `horzOffset = ent GetZBarrierAttackSlotHorzOffset()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierNumAttackSlots", `Returns the number of attack slots used by this zbarrier.`, "entity", [], true, false, `numSlots = ent GetZBarrierNumAttackSlots()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierPieceAnimLengthForState", `Returns the length in seconds for the animation associated with the supplied state for a piece, in seconds.`, "entity", [new LibraryFunctionParameter("index", `The index of the piece we care about.`, true), new LibraryFunctionParameter("state", `Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.`, true), new LibraryFunctionParameter("scalar", `Scalar applied to animation length.`, false)], true, false, `wait(ent GetZBarrierPieceAnimLengthForState(0, "opening", 0.9))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierPieceAnimState", `Returns the anim state name to be used for zombies tearing this board down.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `anim_state = ent GetZBarrierPieceAnimState(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierPieceAnimSubState", `Returns the anim sub-state name to be used for zombies tearing this board down.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `anim_state = ent GetZBarrierPieceAnimSubState(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierPieceIndicesInState", `Returns an array of integer indices of the zbarriers pieces that are in the specified state.`, "entity", [new LibraryFunctionParameter("state", `Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.`, true)], true, false, `open_pieces = ent GetZBarrierPieceIndicesInState("open")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierPieceState", `Returns the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `pieceState = ent GetZBarrierPieceState(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierReachThroughAttackAnimState", `Returns the anim state name for reach through attacks used by this zbarrier.`, "entity", [], true, false, `attackStateName = ent GetZBarrierReachThroughAttackAnimState()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetZBarrierTauntAnimState", `Returns the anim state name for taunts used by this zbarrier.`, "entity", [], true, false, `tauntStateName = ent GetZBarrierTauntAnimState()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Ghost", `Used when the entity should be sent over the network to clients but not be drawn`, "entity", [], true, false, `model Ghost()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Gib", `Gib an entity`, "entity", [new LibraryFunctionParameter("gibtype", `Type of gib`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `self gib( "normal", temp_array )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GlassRadiusDamage", `Damages glass in the radius`, null, [new LibraryFunctionParameter("origin", `Origin of damage`, true), new LibraryFunctionParameter("radius", `Radius of damage`, true), new LibraryFunctionParameter("max_damage", `Max damage, this is the damage at the origin`, true), new LibraryFunctionParameter("min_damage", `Max damage, this is the damage at the edge of the radius`, true), new LibraryFunctionParameter("means_of_death", `Means of death passed to the glass system from script, defaults to MOD_EXPLOSIVE`, false)], true, false, `GlassRadiusDamage( origin, range, max_damage, min_damage, means_of_damage )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GrenadeExplosionEffect", `Create a grenade explosion effect at the position`, null, [new LibraryFunctionParameter("position", `Position of the fx`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GroundTrace", `Allows script to do a point trace with MASK_SHOT + MASK_ITEM. Returns hit position, hit entity, hit surface normal.`, null, [new LibraryFunctionParameter("start", `The bullet start point`, true), new LibraryFunctionParameter("end", `The bullet end point`, true), new LibraryFunctionParameter("hit characters", `When set to true, this will trace for character hits`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore`, true), new LibraryFunctionParameter("ignore water", `Optionally ignore water. (bool)`, false), new LibraryFunctionParameter("ignore glass", `Optionally ignore glass. (bool)`, false)], true, false, `trace = GroundTrace(magicBulletOrigin.origin, eyePos, true, undefined)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasAnimTree", `Returns true if the entity has an anim tree`, "entity", [], false, true, `self HasAnimTree()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasASM", `Check if this entity has an ASM.`, "entity", [], true, false, `if ( HasASM( self ) ) {`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasDObj", `Returns 1 if the entity currently has a dobj.`, "entity", [new LibraryFunctionParameter("local client number", `number of the local client on the machine.`, true)], false, true, `if(ent HasDObj(0))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasPart", `Returns whether the entity has the given tagname as part of its skeleton.`, "entity", [new LibraryFunctionParameter("tagname", `The tag to search for. (string)`, true), new LibraryFunctionParameter("modelname", `The optional model name to help specify the part location. (string)`, false)], true, false, `has_part = self HasPart( "tag_weapon", "weapon_saw" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HeliTurretDogTrace", `Determines if you helicopter turret can see the dog.`, null, [new LibraryFunctionParameter("position", `place that check if you can see if being performed`, true), new LibraryFunctionParameter("dog", `the dog that the helicopter wants to see`, true), new LibraryFunctionParameter("hitNum", `if you run this more than once make sure to populate this with the return of the last as it will increase efficiency`, true)], true, false, `if (0 == (copter HeliTurretSightTrace(heli_turret_point, dog, lastHit))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HeliTurretSightTrace", `Determines if you helicopter turret can see an the players eyes.`, null, [new LibraryFunctionParameter("position", `place that check if you can see if being performed`, true), new LibraryFunctionParameter("player", `the player that the helicopter wants to see`, true), new LibraryFunctionParameter("hitNum", `if you run this more than once make sure to populate this with the return of the last as it will increase efficiency`, true)], true, false, `if (0 == (copter HeliTurretSightTrace(heli_turret_point, player, lastHit))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Hide", `Hide the entity`, "entity", [], true, false, `self Hide()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideFromTeam", `Hides the entity from a particular team`, "entity", [new LibraryFunctionParameter("team", `The team to show the entity to.`, true)], true, false, `self HideFromTeam( friend_team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("hideinfovolume", `Stops an info volume from being drawn`, null, [new LibraryFunctionParameter("entnum", `the entity number of the info volume`, true)], true, false, `InfoVolumeDebug_HideVolume( info_volume GetEntityNumber() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideMiscModels", `Hide all misc models with this targetname`, null, [new LibraryFunctionParameter("targetname", `targetname of misc model(s).`, true)], true, false, `HideMiscModels( "crash_destruct" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HidePart", `Hide part of an entity.`, "entity", [new LibraryFunctionParameter("tagname", `The tag to hide. All surfaces with a vertex weighted to the tag will be hidden and have no bullet collision. (string)`, true), new LibraryFunctionParameter("modelname", `The optional model name to help specify the part location. (string)`, false), new LibraryFunctionParameter("bApplyToChildren", `Optional flag to specify if we should apply the operation to children bones as well. (boolean)`, false)], true, false, `self HidePart( "tag_weapon", "weapon_saw" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideZBarrierPiece", `Stops the indexed piece from being drawn.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent HideZBarrierPiece(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IncrementCounter", `Increments the counter`, null, [new LibraryFunctionParameter("counterType", `The counter type`, true), new LibraryFunctionParameter("increment", `The increment type`, true)], true, false, `IncrementCounter( "global_comebacks", level.globalComebacks )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("incrementSpecificWeaponPickedUpCount", `increment the count of the times we've picked up this weapon (uniquely identified by weapon+attachemnts; see function: areWeaponsEqual )`, "player", [new LibraryFunctionParameter("weapon", `the weapon`, true)], true, false, `self incrementSpecificWeaponPickedUpCount( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("InfoVolumeDebugInit", `Initializes the info volume debug array`, null, [], true, false, `DebugInfoVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("InitClientObjectives", `Delete a spawned effect.`, null, [new LibraryFunctionParameter("localClientNum", `client on which to clear the objectives.`, true)], false, true, `InitObjectives( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("InLastStand", `Check the last stand state for the client`, "client", [], true, false, `if ( self InLastStand() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsActor", `Checks whether this entity is an ai character`, null, [new LibraryFunctionParameter("entity", `An entity object that may be an ai character`, true)], true, false, `if ( IsActor( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsActorCorpse", `Checks whether this entity is an actor corpse`, null, [new LibraryFunctionParameter("entity", `An entity object that might be a corpse`, true)], true, false, `if ( IsActorCorpse( corpse ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsActorSpawner", `Checks whether this entity is an actor spawner`, null, [new LibraryFunctionParameter("entity", `An entity object that may be an actor spawner`, true)], true, false, `if ( IsActorSpawner( ent ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsADS", `Returns true if this local client is in ADS, false otherwise`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `IsADS( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAI", `Checks whether this entity is an ai character`, null, [new LibraryFunctionParameter("entity", `An entity object that may be an ai character`, true)], true, false, `if ( IsAI( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAirborne", `Checks whether this entity is an airborne unit`, null, [new LibraryFunctionParameter("entity", `An entity object`, true)], true, false, `if ( IsAirborne( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAlive", `Checks whether this entity is alive`, null, [new LibraryFunctionParameter("entity", `An entity object that might be alive or dead`, true)], true, false, `if ( IsAlive( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAnimLooping", `Gets whether an animation is looped or not`, null, [new LibraryFunctionParameter("animation", `an animation that needs to be identified as a looping or not`, true)], true, false, `boolLoop = IsAnimLooping( climbAnim )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsArchetypeLoaded", `Returns true if a given archetype is loaded in the level.`, null, [], true, false, `if ( IsArchetypeLoaded( ARCHETYPE_WARLORD ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsArenaMode", `Returns true if we are in arena mode`, null, [], true, false, `if ( IsArenaMode() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAssetLoaded", `Check whether or not an asset is loaded.`, null, [new LibraryFunctionParameter("assetType", `"weapon" or "material"`, true), new LibraryFunctionParameter("assetName", `The name of the asset - should match zone_source`, true)], true, false, `IsAssetLoaded( "weapon", "rpg" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAttached", `Returns true if the model is attached to the entity`, "entity", [new LibraryFunctionParameter("modelname", `The name of the model to test if attached.`, true), new LibraryFunctionParameter("tagname", `The tag to test`, false)], false, true, `self IsAttached( "somemodel", "tag_origin" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsBonusCardActive", `Returns if the bonus card is enabled and active in the class, cannot be called on a larry`, "player", [new LibraryFunctionParameter("bonuscard", `BonusCard index from bonuscard.gsh`, true), new LibraryFunctionParameter("classnum", `The current class num of the player`, true)], true, false, `primary = self IsBonusCardActive( BONUSCARD_PRIMARY_GUNFIGHTER_INDEX, self.class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsBot", `Returns true if the entity is a bot controlled player`, "entity", [], true, false, `if( self IsBot() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCamAnimLooping", `Returns whether or not a specific camera anim loop.`, null, [new LibraryFunctionParameter("cam_anim", `The animation to play`, true)], true, false, `IsCamAnimLooping( "proto_melee_cam" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCameraSpikeToggled", `Returns 1 if the camera spike is toggled to be active, 0 otherwise`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the camera spike owner`, true)], false, true, `if ( IsCameraSpikeToggled( 0 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsClientCacheStable", `Is the players client cache stable, have we loaded all other clients' resources.`, "player", [], true, false, `player IsClientCacheStable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsContentScreenFilterPlaying", `Returns whether or not this player is playing a Graphics Content blocking filter at this moment or not.`, "player", [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCorpse", `Checks whether this entity is a corpse`, null, [new LibraryFunctionParameter("entity", `An entity object that might be a corpse`, true)], true, false, `if ( IsCorpse( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCoverNode", `returns true if the node is of type NODE_TYPEFLAGS_COVER_ONLY`, null, [new LibraryFunctionParameter("node", `The node to delete`, true)], true, false, `IsCoverNode( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDangerous", `Returns true if the pathnode is dangerous for the given team`, "pathnode", [new LibraryFunctionParameter("team", `Name of the team.`, true)], true, false, `if ( node IsDangerous( team ) ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDedicated", `Returns true/false if we are running on the dedicated server`, null, [], true, false, `if ( IsDedicated() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDemoPlaying", `Returns true if a demo is currently playing back`, null, [], false, true, `if ( IsDemoPlaying() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDoubleJumping", `Returns true if the player is double jumping.`, "player", [], true, false, `if(player DoubleJumping())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDriving", `Returns true if the player is driving a vehicle.`, "player", [new LibraryFunctionParameter("localClientNum", `The localClientNum of the caller`, true)], false, true, `if ( self IsDriving( <localClientNum> ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDynEntValid", `Returns if the dynEnt still valid or not`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `if( IsDynEntValid( dyn_id) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsEMPJammed", `Returns true if this player is jammed by the emp, false otherwise`, null, [], true, false, `if ( player IsEMPJammed() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsEntity", `Checks whether given variable is of type entity.`, null, [new LibraryFunctionParameter("variable", `variable to test`, true)], true, false, `if ( IsEntity( variable ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsEntityLinkedToTag", `Returns is the entity is linked to the parententity, ( on a specific tag optional )`, "parententity", [new LibraryFunctionParameter("entity", `The entity that we are checking`, true), new LibraryFunctionParameter("tag", `The tag we are checking`, false)], false, true, `if ( player IsEntityLinkedToTag( grenade, "j_head" ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsEventServiced", `Set the specified event to serviced.`, "ai", [new LibraryFunctionParameter("eventId", `The identifier of the event (integer)`, true)], true, false, `serviced = self IsEventServiced( 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFiringTurret", `Checks whether this turret is firing. The entity must be a turret`, "turret", [], true, false, `turret IsFiringTurret()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFlared", `Check is a player is under the influence of a flare`, null, [], true, false, `if ( player IsFlared() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFriendly", `Returns true if entity is friendly`, null, [new LibraryFunctionParameter("localclientnum", `Local client number of the local client you want to test against`, true), new LibraryFunctionParameter("predicted", `Test against predicted version, false by default`, false)], false, true, `if ( entity IsFriendly( <localClientNum>, [predicted] ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGadgetMeleeCharging", `Is the player in the process of melee charging `, null, [], true, false, `self IsGadgetMeleeCharging()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGlobalStatsServer", `Returns true if the game is a global stats ranked server`, null, [], true, false, `level.ranked |= IsGlobalStatsServer()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGodMode", `Checks whether this entity is in god mode`, null, [new LibraryFunctionParameter("entity", `An entity object to check for god mode`, true)], true, false, `if ( IsGodMode( player ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("isGrenadeDud", `Returns if a grenade is a dud`, "grenade", [], false, true, `if ( grenade isGrenadeDud() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsHidden", `return true if entity is hidden`, "entity", [], true, false, `self IsHidden()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInHelicopter", `Returns true if the client is in a helicopter.`, null, [new LibraryFunctionParameter("localClientNum", `Client number to check`, true)], false, true, `if( IsInHelicopter( 0 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInScrCam", `Check if the camera of local client is in scripted camera`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `inScrCam = IsInScrCam( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInScritpedAnim", `Returns 1 if the entity currently has scripted animation playing.`, "entity", [], false, true, `if(ent IsInScritpedAnim())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInSecondChance", `To check if player is needs revive`, null, [], true, false, `if ( self IsInSecondChance() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInsideHeightLock", `Returns whether the entity is inside the height lock or not`, "entity", [], true, false, `if( self IsInsideHeightLock() ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLaserOn", `check if the entity has laser turned on.`, "entity", [], true, false, `if ( IsLaserOn( entity ) ) { ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLinkedTo", `Returns true if the entity is linked to the other entity`, "entity", [new LibraryFunctionParameter("other", `Entity`, true)], true, false, `if (ent IsLinkedTo( other )) { // dostuff }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLoadingCinematicPlaying", `Is the player playing the loading cinematic`, "player", [], true, false, `player IsLoadingCinematicPlaying()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalClientDead", `Checks if the pm_type > PM_DEAD`, null, [], false, true, `IsLocalClientDead()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalClientDriver", `Returns the driver of the vehicle.`, "vehicle", [new LibraryFunctionParameter("localClientNum", `The localClientNum of the caller`, true)], false, true, `driver = self IsLocalClientDriver(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalGame", `Returns true if the game local only`, null, [], true, false, `level.local = IsLocalGame()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalPlayer", `Returns true if the ent it's called on is a local player.`, "entity", [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalPlayerViewLinked", `Returns whether or not this entity is linked to the given local client`, "player", [new LibraryFunctionParameter("localClientNum", `The localClientNum of the caller`, true)], false, true, `if ( script_mover IsLocalPlayerWeaponViewOnlyLinked( localClientIndex ) ) { ... }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalPlayerWeaponViewOnlyLinked", `Returns whether or not this player is linked to an enity with weapon view only linking.`, "player", [], false, true, `weaponviewonlylinked = self IsLocalPlayerWeaponViewOnlyLinked()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMantling", `Return true if the player is mantling, false otherwise.`, "player", [], true, false, `self IsMantling()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMapSubLevel", `Returns whether or not the map is a sublevel of a mission`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.isSubLevel = IsMapSubLevel( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMature", `Checks if a player has his Graphic Content Flag is on`, null, [new LibraryFunctionParameter("player", `The player to check if his Graphic Content Flag is on`, true)], true, false, `IsMature( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ismissileinsideheightlock", `Returns whether the entity is inside the height lock or not`, "entity", [], true, false, `if( self IsInsideHeightLock() ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMovingPlatform", `Returns whether platform is a moving platform or not`, null, [], true, false, `platform IsMovingPlatform()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsNavVolumeLoaded", `Checks whether nav volume is loaded`, null, [], true, false, `if ( IsNavVolumeLoaded() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsNodeEnabled", `returns true if the node is enabled, false otherwise`, null, [new LibraryFunctionParameter("node", `The node to check`, true)], true, false, `IsNodeEnabled( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsNodeOccupied", `See if anyone has claimed a particular node.`, null, [new LibraryFunctionParameter("node", `which node to check.`, true)], true, false, `if ( IsNodeOccupied( node ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsOnGround", `Returns true if entity is on ground`, "entity", [], true, false, `if( self IsOnGround() ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsOnLadder", `Return true if the player is on a ladder, false otherwise.`, "player", [], true, false, `self IsOnLadder()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsOnSlide", `Return true if the player is in the player movement slide.`, "player", [], true, false, `self IsOnSlide()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsOnTurret", `Returns true if the player is currently on a turret`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `if( IsOnTurret( 0 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPathfinder", `Checks whether this entity is registered with navigation system so it can do pathfinding and position query`, null, [new LibraryFunctionParameter("entity", `An entity to check`, true)], true, false, `if ( IsPathfinder( tank ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPaused", `Returns whether a given entity is paused as part of a world pause.`, "entity", [], true, false, `if ( ent IsPaused() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPeelingOut", `Returns true if the vehicle is currently peeling out.`, "vehicle", [], false, true, `if ( self IsPeelingOut() ) { }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayer", `Checks whether this entity is the player`, null, [new LibraryFunctionParameter("entity", `An entity object that may be the player`, true)], true, false, `if ( IsPlayer( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerCorpse", `Returns true if the ent it's called on is a player corpse.`, "entity", [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerDead", `Returns 1 if the entity currently has health of 0 or less`, "entity", [], false, true, `if(ent IsPlayerDead())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerDoubleJumping", `Returns 1 if the player is currently double jumping (boosting)`, "entity", [], false, true, `if(ent IsPlayerDoubleJumping())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerFiring", `Returns 1 if the player is currently firing`, "entity", [], false, true, `if(ent IsDead())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerJumping", `Returns 1 if the player is currently jumping`, "entity", [], false, true, `if(ent IsPlayerJumping())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerNumber", `Returns true if the passed in int is a valid client number`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerSliding", `Returns 1 if the player is currently sliding`, "entity", [], false, true, `if(ent IsPlayerSliding())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerSprinting", `Returns 1 if the player is currently sprinting`, "entity", [], false, true, `if(ent IsPlayerSprinting())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerSwimming", `Return if a player is swimming`, "player", [], true, false, `depth = get_players()[0] IsPlayerSwimming()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerSwimmingOnSurface", `Return if a player is swimming`, "entity", [], false, true, `swimming = player IsPlayerSwimmingOnSurface()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerSwimmingUnderwater", `Return if a player is swimming`, "entity", [], false, true, `swimming = player IsPlayerSwimmingUnderwater()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerTalking", `Returns 1 if the player is talking`, "entity", [], false, true, `if(ent IsPlayerTalking())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerUnderwater", `Return if a player is underwater`, "player", [], true, false, `depth = get_players()[0] IsPlayerUnderwater()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerWallRunning", `Returns 1 if the player is currently wall running`, "entity", [], false, true, `if(ent IsPlayerWallRunning())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerWallRunningRight", `Returns 1 if the player is currently wall running right`, "entity", [], false, true, `if(ent IsPlayerWallRunning())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayingAnimScripted", `Returns true if the entity is playing in scripted animation.`, "entity", [], true, false, `if(player IsPlayingAnimScripted())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayingLoopSound", `Returns true if the entity is playing a loop sound`, null, [new LibraryFunctionParameter("alias", `specific alias to check for`, false)], false, true, `car IsPlayingLoopSound()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPointInNavVolume", `Checks if a given point is within the specified navigation volume.`, null, [new LibraryFunctionParameter("position", `Position to evaluate.`, true), new LibraryFunctionParameter("navVolumeName", `Either "navvolume_small" or "navvolume_big".`, true)], true, false, `result = IsPointInNavVolume( (10,20,30), "small volume" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPointOnNavMesh", `Checks if a given point is valid on the NavMesh. This check performs all the necessary validation such as away from boundary, correct material, navmesh trigger, etc.`, null, [new LibraryFunctionParameter("position", `Position to evaluate.`, true), new LibraryFunctionParameter("entity / radius", `the point is for this entity to path to, or an estimate radius of the expected character radius. default to radius 0. Note: not passing in the entity can cause false positive when point is on NavMesh but too close to boundary / on wrong material / in disabled navmesh trigger; or false negative when big character's origin is far below NavMesh but still within tolerant height.`, false)], true, false, `isValid = IsPointOnNavMesh( (10,20,30), self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPoisoned", `Check is a player is under the influence of gas`, null, [], true, false, `if ( player IsPoisoned() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsRagdoll", `Return true if the entity is a ragdoll body, false otherwise.`, "player_or_playercorpse", [], true, false, `if( player IsRagdoll() ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsRobot", `Returns true if the ent it's called on is a sentient vehicle i.e. a Robot.`, "entity", [], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsScrambled", `Returns the if player is getting scrambled by an enemy`, "player", [], false, true, `if ( player IsScrambled( ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSentient", `Checks whether this entity is a sentient, that is normally either an ai actor, ai vehicle or the player`, null, [new LibraryFunctionParameter("entity", `An entity object that may be a sentient character`, true)], true, false, `if ( IsSentient( vehicle.riders[j] ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsShoutcaster", `Returns 1 if the local client is shoutcasting`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client to check`, true), new LibraryFunctionParameter("checkFistPerson", `Check if we want first person spectating to be not considered as spectate`, false)], false, true, `if ( IsSpectating( localClientNum, false ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSlamming", `Returns true if the player is slamming.`, "player", [], true, false, `if(player IsSlamming())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSliding", `Returns true if the player is sliding.`, "player", [], true, false, `if(player IsSliding())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSpawner", `Checks whether this entity is a spawner`, "entity", [new LibraryFunctionParameter("entity", `An entity object that may be a spawner`, true)], true, false, `if ( IsSpawner( ent ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSpawnPointVisible", `Returns true or false if a point is visible to the given team`, null, [new LibraryFunctionParameter("point", `Spawnpoint origin that needs to be checked`, true), new LibraryFunctionParameter("angles", `Spawnpoint angles that needs to be checked`, true), new LibraryFunctionParameter("team", `Team that we need to check against the point`, true), new LibraryFunctionParameter("ignore player", `The player that we are spawning in`, true)], true, false, `if ( IsSpawnPointVisible( point_position, point_angles, "axis", player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSpectating", `Returns 1 if the local client is spectating`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client to check`, true), new LibraryFunctionParameter("checkFistPerson", `Check if we want first person spectating to be not considered as spectate`, false)], false, true, `if ( IsSpectating( localClientNum, false ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSplitScreen", `Returns true if the game is a splitscreen game`, null, [], true, false, `level.splitscreen = IsSplitScreen()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSplitScreenHost", `Returns true if local player is the host`, "player", [], false, true, `if ( player IsSplitScreenHost() ) { }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSprinting", `Returns true if the player is sprinting.`, "player", [], true, false, `if(player IsSprinting())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStarterPack", `Returns true if the player has starter pack`, "player", [], true, false, `if ( self IsStarterPack() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStartingClassDefault", `Returns true if the starting class is the default class for the level`, "player", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStreamed", `Returns true if this entity is fully streamed in`, "entity", [], false, true, `thing isStream()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStreamerReady", `Is the players streamer ready.`, "player", [], true, false, `player IsStreamerReady()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSwimming", `Returns 1 if the player is swimming.`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `isSwimming = IsSwimming( localclientnum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTestClient", `Returns true if the player is a test client (Does not have a remote user).`, "player", [], true, false, `if( self IsTestClient() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsThirdPerson", `Checks if the camera mode to third person if true`, null, [], false, true, `IsThirdPerson()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTouching", `Returns true if <other entity> is touching <entity>`, "entity", [new LibraryFunctionParameter("other entity", `Entity.`, true)], true, false, `if( player IsTouching( e_goal_volume ) ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTouchingSwept", `Returns true if <other entity> is touching <entity>`, "entity", [new LibraryFunctionParameter("other entity", `Entity.`, true)], true, false, `if( player IsTouchingSwept( e_goal_volume ) ) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTouchingVolume", `Returns true if entity is touching the volume.`, "entity", [new LibraryFunctionParameter("origin", `Origin of the volume`, true), new LibraryFunctionParameter("volume mins", `The min extents of the volume`, true), new LibraryFunctionParameter("volume maxs", `The max extents of the volume`, true)], true, false, `if ( crate_ent IsTouchingVolume( origin + (0,0,40), mins, maxs ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTraversing", `Returns true if the player is traversing.`, "player", [], true, false, `if(player IsTraversing())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTriggerEnabled", `Returns true if trigger is enabled. False otherwise`, "trigger", [], true, false, `if( trig isTriggerEnabled() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTurretFiring", `Checks if this turret is firing`, "turret", [], true, false, `if( IsTurretFiring( roof_turret ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTurretLockedOn", `Checks whether this turret is locked onto a target. The entity must be a turret`, "turret", [], true, false, `turret IsTurretLockedOn()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsUnderwater", `Returns 1 if the player is underwater.`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true)], false, true, `clipCount = IsUnderwater( localclientnum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsUsingNavVolume", `Checks whether this entity is using Nav Volume. Note this is a relatively low level check. For general gameplay check whether an entity is flying, consider using IsAirborne.`, null, [new LibraryFunctionParameter("entity", `An entity object`, true)], true, false, `if ( IsUsingNavVolume( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("isUsingT7Melee", `Returns true T7 Melee system is being used`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsValidGametype", `Returns true if the string is a valid game type`, null, [new LibraryFunctionParameter("game type", `a string to check`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicle", `Checks whether this entity is an ai character`, null, [new LibraryFunctionParameter("entity", `An entity object that may be an ai character`, true)], true, false, `if ( IsVehicle( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleSpawner", `Checks whether this entity is a vehicle spawner`, "entity", [new LibraryFunctionParameter("entity", `An entity object that may be a vehicle spawner`, true)], true, false, `if ( IsVehicleSpawner( ent ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVisibleByPlayer", `Returns 1 if the actor can be seen by a player`, null, [], false, true, `if( IsVisibleByPlayer(ent) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("isvr", `check if this player has VR enabled`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWallRunning", `Returns true if the player is wall running.`, "player", [], true, false, `if(player IsWallRunning())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWallrunNode", `returns true if the node has the PNF_WALLRUN flag set`, null, [new LibraryFunctionParameter("node", `The node to check`, true)], true, false, `IsWallrunNode( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWheelColliding", `Returns if the given wheel is on the ground.`, "vehicle", [new LibraryFunctionParameter("wheel", `The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'`, true)], false, true, `colliding = self IsWheelColliding( front_left )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWheelPeelingOut", `Returns if the given wheel is sliding.`, "vehicle", [new LibraryFunctionParameter("wheel", `The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'`, true)], false, true, `peeling = self IsWheelPeelingOut( front_left )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWheelSliding", `Returns if the given wheel is sliding.`, "vehicle", [new LibraryFunctionParameter("wheel", `The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'`, true)], false, true, `sliding = self IsWheelSliding( front_left )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWorldPaused", `returns whether or not the world is currently paused`, null, [], true, false, `if ( IsWorldPaused() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsZBarrier", `Returns true if the entity called on is a zbarrier.`, "entity", [], true, false, `if(ent IsZBarrier())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsZBarrierClosed", `Returns true if the state of all of the zbarrier's pieces is 'closed'.`, "entity", [], true, false, `closed = ent IsZBarrierClosed())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsZBarrierOpen", `Returns true if the state of all of the zbarrier's pieces is 'open'.`, "entity", [], true, false, `open = ent IsZBarrierOpen())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ItemWeaponSetAmmo", `Set the weapon ammo to the given clip ammo and reserve ammo. Can give an alternate weapon index`, "item", [new LibraryFunctionParameter("clipAmmo", `Ammo for the clip`, true), new LibraryFunctionParameter("reserveAmmo", `Reserve ammo`, true), new LibraryFunctionParameter("altIndex", `Alternate weapon index`, false)], true, false, `weap ItemWeaponSetAmmo( clip, extra, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Kick", `Kicks the specified player.`, null, [new LibraryFunctionParameter("clientnum", `The client number of the player to kick.`, true)], true, false, `Kick( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Kill", `Kills this entity. If the entity could not be killed, errors. Automatically sets setCanDamage( true ).`, "entity", [new LibraryFunctionParameter("source position", `The position that the damage comes from. Defaults to entity's origin`, false), new LibraryFunctionParameter("attacker", `The entity that dealt the damage (such as an AI or player)`, false), new LibraryFunctionParameter("inflictor", `The entity that the damage came from (such as a grenade or turret)`, false), new LibraryFunctionParameter("weapon", `weapon to do damage with`, false)], true, false, `level.player kill()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("KillClientRadiantExploder", `Deactivates a client side radiant exploder`, null, [new LibraryFunctionParameter("exploder id", `string id of exploder to deactivate`, true)], true, false, `DeactivateClientRadiantExploder( "light_switch" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("KillServer", `kills the server`, null, [], true, false, `KillServer()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LaserOff", `Turns off entity's laser sight.`, "entity", [], true, false, `self LaserOff()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LaserOn", `Turns on entity's laser sight.`, "entity", [], true, false, `self LaserOn()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Launch", `Launch an object that interacts with the world, using an initial velocity. From this point on this object will no longer block either missiles or bullets.`, "entity", [new LibraryFunctionParameter("initial velocity", `The initial velocity of the launch.`, true), new LibraryFunctionParameter("initial angular velocity", `The initial angular velocity of the launch.`, false)], true, false, `self Launch( (x, y, z) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("launchdynent", `Launch a dynent`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("force", `the direction and magnitude of the force applied`, true), new LibraryFunctionParameter("hitp", `the location of the hitpoint in world space`, false)], false, true, `launchdynent( brick, (0,0,200) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LaunchRagdoll", `Launch this ragdoll.`, "entity", [new LibraryFunctionParameter("force", `launch force`, true), new LibraryFunctionParameter("bonename", `bone name to apply the force to`, false)], true, false, `self LaunchRagdoll( (0,0,100) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LaunchVehicle", `Launch this physics vehicle.`, "entity", [new LibraryFunctionParameter("force", `launch force`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `panzer LaunchVehicle( (0,0,100) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LerpViewAngleClamp", `Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.`, "player", [new LibraryFunctionParameter("time", `Lerp duration in seconds. A value of 0 means instantaneous.`, true), new LibraryFunctionParameter("accel time", `Acceleration time.`, true), new LibraryFunctionParameter("decel time", `Decelaration time.`, true), new LibraryFunctionParameter("right arc", `Angle to clamp view to the right.`, true), new LibraryFunctionParameter("left arc", `Angle to clamp view to the left.`, true), new LibraryFunctionParameter("top arc", `Angle to clamp view to the top.`, true), new LibraryFunctionParameter("bottom arc", `Angle to clamp view to the bottom.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkNodes", `Connects node1 to node2. Call it again with arguments flipped if you want a two-way connection.`, null, [new LibraryFunctionParameter("node1", `first node to link`, true), new LibraryFunctionParameter("node2", `second node to link`, true)], true, false, `LinkNodes( node_moving_elev_left, node_moving_elev_right )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkTo", `Attaches one entity to another`, "non_player_entity", [new LibraryFunctionParameter("linkto entity", `The entity to attach this thing to`, true), new LibraryFunctionParameter("tag", `The tag to attach the entity to`, false), new LibraryFunctionParameter("originOffset", `The positional offset from the base position`, false), new LibraryFunctionParameter("anglesOffset", `The angular offset from the base angles`, false)], true, false, `self.rightturret LinkTo( self, "tag_gunRight", (0,0,0), (0,0,0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkToBlendToTag", `Attaches one entity to another, gradually lerping entity to the parents orientation`, "non_player_entity", [new LibraryFunctionParameter("linkto entity", `The entity to attach this thing to`, true), new LibraryFunctionParameter("tag", `The tag to attach the entity to`, false), new LibraryFunctionParameter("only yaw", `Tells if blending only the yaw. Default to true.`, false), new LibraryFunctionParameter("collision physics", `Sets whether we should use collision physics. Defaults to false.`, false)], true, false, `self.rightturret LinkToBlendToTag( self, "tag_gunRight" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkToCamera", `Links an entity directly to the camera.  Good for scripted player arms.`, null, [new LibraryFunctionParameter("linkType", `, 0 - pitch only, 1 - yaw only, 2 - roll only, 3 - swimming, 4 - full, 5 - 3d compass.  Full is the default if not specified."`, true), new LibraryFunctionParameter("offset", `Vector of the offset`, false)], false, true, `swimming_arms LinkToCamera()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkToUpdateOffset", `Attaches one entity to another, gradually lerping entity to the parents orientation`, "non_player_entity", [new LibraryFunctionParameter("origin_offset", `The origin offset`, true), new LibraryFunctionParameter("angles_offset", `The angles offset`, false)], true, false, `self.rightturret LinkToUpdateOffset( originsOffset, anglesOffset )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkTraversal", `Creates a user edge connecting two path nodes`, null, [new LibraryFunctionParameter("node", `Negotiation begin node`, true)], true, false, `LinkTraversal( beginNode )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LoadSentientEventParameters", `Loads the global sentient event parameters for a given scriptbundle sentient events asset. (all AI will use these)`, null, [new LibraryFunctionParameter("scriptBundle", `String name of the script bundle to load`, true)], true, false, `LoadSentientEventParameters( "sentientevents" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LoadSiegeAnim", `Load a siege anim into memory`, null, [new LibraryFunctionParameter("anim_name", `Name of the siege anim to load`, true)], false, true, `LoadSiegeAnim( "flappy_bird" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LocalClientActive", `Return whether local client is active`, null, [new LibraryFunctionParameter("client", `the client to check if it is active`, true)], false, true, `active = LocalClientActive( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LocalToWorldCoords", `Transform the given local coordinate point to a world coordinate point`, "entity", [new LibraryFunctionParameter("local coordinate", `The point in local coordinates (vector3)`, true)], true, false, `ramboPoint = self LocalToWorldCoords( delta )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LookAtEntity", `Set this actor to look at the specified entity. Call this function without any entity specified to turn it off.`, "actor", [new LibraryFunctionParameter("otherguy", `the other guy to look at`, false)], true, false, `guy LookAtEntity( otherguy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LookAtPos", `Set this actor to look at the specified position. Call this function without any position specified to turn it off.`, "actor", [new LibraryFunctionParameter("pos", `the position to look at`, false)], true, false, `guy LookAtPos( pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LUINotifyEvent", `Sends a notify from script to LUI.`, "player", [new LibraryFunctionParameter("player", `the player to notify. If not specified, all players are notified.`, false), new LibraryFunctionParameter("lui event name", `as an IString`, true), new LibraryFunctionParameter("num of args", `number of parameters`, true), new LibraryFunctionParameter("args", `argument to pass to LUI`, true)], true, false, `LUINotifyEvent( &"update_objectives", 1, &"LEVEL_GOTO_NEXT_PLACE" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LUINotifyEventToSpectators", `Sends a notify from script to LUI.`, null, [new LibraryFunctionParameter("lui event name", `as an IString`, true), new LibraryFunctionParameter("num of args", `number of parameters`, true), new LibraryFunctionParameter("args", `argument to pass to LUI`, true)], true, false, `LUINotifyEventToSpectators( &"update_objectives", 1, &"LEVEL_GOTO_NEXT_PLACE" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicBullet", `Creates a magic bullet at the source`, null, [new LibraryFunctionParameter("weapon", `Weapon type of the bullet`, true), new LibraryFunctionParameter("source", `Where the bullet will be spawned`, true), new LibraryFunctionParameter("destination", `Where the bullet will be fired at`, true), new LibraryFunctionParameter("attacker", `Set the owner of the bullet to this`, false), new LibraryFunctionParameter("targetent", `The target of the bullet`, false), new LibraryFunctionParameter("targetOffset", `Offset the target by this vector`, false)], true, false, `MagicBullet( GetWeapon("sniper_hyperion"), level.sniper_loc.origin, target GetTagOrigin( "tag_eye" ), level.sniper_boss)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicGrenade", `Creates a "Magic" grenade from an actor.`, "actor", [new LibraryFunctionParameter("origin", `The starting point of the grenade toss`, true), new LibraryFunctionParameter("target position", `The target point of the grenade toss`, true), new LibraryFunctionParameter("time to blow", `The grenade fuse time in seconds`, false), new LibraryFunctionParameter("weapon", `The grenade weapon to use (defaults to equipped grenade weapon)`, false)], true, false, `self MagicGrenade( self.origin, target.origin, 2.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicGrenadeManual", `creates a "Magic" grenade from an actor`, "actor", [new LibraryFunctionParameter("origin", `The starting point of the grenade toss`, true), new LibraryFunctionParameter("velocity", `The initial velocity vector for the grenade movement`, true), new LibraryFunctionParameter("time to blow", `The grenade fuse time in seconds`, false)], true, false, `self MagicGrenadeManual( self.origin, target.origin, 2.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicGrenadeManualPlayer", `creates a "Magic" grenade from a player`, "player", [new LibraryFunctionParameter("origin", `The starting point of the grenade toss`, true), new LibraryFunctionParameter("velocity", `The initial velocity vector for the grenade movement`, true), new LibraryFunctionParameter("weapon", `The grenade weapon to base on`, true), new LibraryFunctionParameter("time to blow", `The grenade fuse time in seconds`, false)], true, false, `self MagicGrenadeManualPlayer( self.origin, target.origin, 2.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicGrenadePlayer", `Creates a "Magic" grenade from a player.`, "player", [new LibraryFunctionParameter("weapon", `The grenade weapon to use`, true), new LibraryFunctionParameter("origin", `The starting point of the grenade toss`, true), new LibraryFunctionParameter("velocity", `The initial velocity vector for the grenade movement`, true)], true, false, `MagicGrenadePlayer( "sticky_grenade_mp", self.origin, toss_velocity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicGrenadeType", `Fire a 'magic grenade', from the source location towards the destination point.`, null, [new LibraryFunctionParameter("weaponName", `The name of the weapon`, true), new LibraryFunctionParameter("sourceLoc", `The grenade starting point`, true), new LibraryFunctionParameter("velocity", `The velocity of the grenade`, true), new LibraryFunctionParameter("time to blow", `The grenade fuse time in seconds`, false)], true, false, `ent MagicGrenadeType( "fraggrenade", self.origin, myVelocity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MagicMissile", `Launches a weapon from the given position with the given velocity.  Velocity determines direction.`, "attacker", [new LibraryFunctionParameter("weapon", `- Weapon name.`, true), new LibraryFunctionParameter("position", `- Position to launch from.`, true), new LibraryFunctionParameter("velocity", `- Direction and force of launch.`, true), new LibraryFunctionParameter("targetent", `The target of the bullet`, false)], true, false, `bomb = player MagicMissile( "artillery_mp", (100,100,0), ( 0.1, 0.1, 0.1 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeFakeAI", `Create a drone from script model, that can be moved around with simple commands`, "script_model", [], true, false, `guy MakeFakeAI()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeGrenadeDud", `Turns a grenade into a dud`, "grenade", [], true, false, `grenade MakeGrenadeDud()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakePathfinder", `Register a vehicle with Havok so it can do pathfinding and position query`, "vehicle", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeSentient", `Turn a vehicle or script mover into a sentient.`, "entity", [], true, false, `heli MakeSentient()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeTurretUnusable", `Sets a turret to be unable to be used`, "turret", [], true, false, `roof_turret MakeTurretUnusable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeTurretUsable", `Sets a turret able to be used`, "turret", [], true, false, `roof_turret MakeTurretUsable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeUnusable", `Sets this entity to be not usable by the player`, "entity", [], true, false, `mover MakeUsable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeUsable", `Sets this entity to be usable by the player`, "entity", [new LibraryFunctionParameter("team", `The team that is allowed to use the object. Only for script movers.`, false)], true, false, `mover MakeUsable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Map", `Loads a new map`, null, [new LibraryFunctionParameter("map name", `The map to load`, true), new LibraryFunctionParameter("save persistent", `if true then player info is retained`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Map_Restart", `Restarts the map`, null, [new LibraryFunctionParameter("save persistent", `if true then player info is retained`, false)], true, false, `Map_Restart( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MapExists", `Returns true if the map with the given name exists on the server`, null, [new LibraryFunctionParameter("map name", `The map to check.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MapShaderConstant", `Maps a shader constant to an index. Returns 1 if success, 0 on failure`, null, [new LibraryFunctionParameter("localClientNum", `Local client for which to map the shader constant`, true), new LibraryFunctionParameter("index", `the index you want this shader constant to map to`, true), new LibraryFunctionParameter("constant name", `a string that's the name of the shader constant`, true), new LibraryFunctionParameter("x", `initial value of x component`, false), new LibraryFunctionParameter("y", `initial value of y component`, false), new LibraryFunctionParameter("z", `initial value of z component`, false), new LibraryFunctionParameter("w", `initial value of w component`, false)], false, true, `ent mapshaderconstant( 0, "shaderColor" ); ent mapshaderconstant( 0, "shaderColor", 1, 0, 1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MarkAsDirty", `Marks the entity as dirty`, null, [], false, true, `MarkAsDirty( entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MarkDestructibleDestroyed", `set destructible destroyed`, "destructible", [], true, false, `barrel MarkDestructibleDestroyed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MarkNoVehicleNavMeshFaces", `Update the novehicle flag on navmesh faces. This should only be used in MP map for now.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("matchRecordOvertimeRound", `call after matchRecordRoundStart to mark the round as an overtime round (only first overtimee round is actually recorded)`, null, [], true, false, `matchRecordOvertimeRound()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("matchRecordRoundStart", `need a hook for round starts, to get time stamps`, null, [], true, false, `matchRecordRoundStart()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Matrix4x4TransformPoints", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MaySpawnEntity", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MaySpawnFakeEntity", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MisdirectionEnable", `Enables or disables misdirection display`, null, [new LibraryFunctionParameter("localClientNum", `The local client number.`, true), new LibraryFunctionParameter("bool", `0 disables display, 1 enables it.`, true)], false, true, `MisdirectionEnable( localclientnum, newVal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_DroneSetVisible", `Set the missile or drone to be visible`, "entity", [new LibraryFunctionParameter("flag", `True to set visible, false otherwise`, true)], true, false, `self Missile_DroneSetVisible( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_GetTarget", `Sets the target of the missile to the given entity, and resets if no entity is specified.`, "missile", [], true, false, `target = missile Missile_GetTarget()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("missile_settarget", `Sets the target of the missile to the given entity, and resets if no entity is specified.`, "missile", [new LibraryFunctionParameter("target", `The target of the missile`, false), new LibraryFunctionParameter("targetOffset", `Offset to the target location (vector3)`, false)], true, false, `self missile_settarget( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MissionFailed", `Restarts the map`, null, [], true, false, `MissionFailed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MissionHasAccolades", `Returns whether or not this mission has any accolades associated with it`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.has_accolades = MissionHasAccolades( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MissionHasCollectibles", `Returns whether or not this mission has any collectibles in it`, null, [new LibraryFunctionParameter("currentmap", `the name of the current map.  If ommitted, use Dvar sv_mapname`, false)], true, false, `level.has_collectibles = MissionHasCollectibles( "cp_mi_cairo_ramses2" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MissionRestart", `Restarts the mission, which might take you to a different BSP if this is a sublevel`, null, [], true, false, `MissionRestart()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveGravity", `Fling this entity.`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("initial velocity", `The initial velocity to fling this entity at`, true), new LibraryFunctionParameter("time", `The time to move the entity in seconds`, true)], true, false, `self MoveGravity( break_vector, time )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveSlide", `Launches the entity in the given velocity. When on the ground it will slide smoothly. Call StopMoveSlide to make it stop moving.`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("center", `The center of the entity's collision with the ground`, true), new LibraryFunctionParameter("radius", `The radius of the entity's collision with the ground`, true), new LibraryFunctionParameter("initial velocity", `The initial velocity to move the entity at`, true)], true, false, `self MoveSlide( 16, anglesToForward( self.angles ) * 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveTo", `Move this entity to the given point.`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("point", `The point to move the entity to`, true), new LibraryFunctionParameter("time", `The time to move the entity in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating`, false)], true, false, `dummy MoveTo( dest_org, .5, .05, .05 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveX", `Move this entity to the given world x value`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("point", `The x value to move the entity to, as a floating point number`, true), new LibraryFunctionParameter("time", `The time to move the entity in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `train MoveX( -4400, 60, 15, 20 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveY", `move this entity to the given world y value`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("point", `The y value to move the entity to, as a floating point number`, true), new LibraryFunctionParameter("time", `The time to move the entity in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `hangardoor MoveY( 320, 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveZ", `Move this entity to the given world z value`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("point", `The z value to move the entity to, as a floating point number`, true), new LibraryFunctionParameter("time", `The time to move the entity in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NavPointSightFilter", `Given an array of navmesh points, filters the array based on navmesh visibility to an origin.`, null, [new LibraryFunctionParameter("points", `Array of navmesh points`, true), new LibraryFunctionParameter("origin", `Origin to check visibility from`, true), new LibraryFunctionParameter("checksight", `True to check sight, false otherwise`, false)], true, false, `points = NavPointSightFilter( points, nearest )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NeedsRevive", `Used for mini maps to display compass icon`, null, [new LibraryFunctionParameter("bool", `does player need to be reived`, true)], true, false, `self NeedsRevive( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NodesAreLinked", `Returns true if node1 is connected to node2.`, null, [new LibraryFunctionParameter("node1", `first node`, true), new LibraryFunctionParameter("node2", `second node`, true)], true, false, `NodesAreLinked( node_moving_elev_left, node_moving_elev_right )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NodesVisible", `Returns true if these nodes are visible to one another, false otherwise.`, null, [new LibraryFunctionParameter("node1", `pathnode to check`, true), new LibraryFunctionParameter("node2", `pathnode to check against node1`, true)], true, false, `if ( NodesVisible( cover, guy.node ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NotSolid", `Unsets the solid flag, so that this object is no longer collidable.`, "ent", [], true, false, `self NotSolid()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NumRemoteClients", `Returns the number of remote clients connected to the game.  Very useful for scaling content for coop play, and network balancing.`, null, [], true, false, `num_remote_clients = NumRemoteClients()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Obituary", `Create an obituary for a character`, null, [new LibraryFunctionParameter("victim", `The victim entity`, true), new LibraryFunctionParameter("attacker", `The attacker entity`, true), new LibraryFunctionParameter("weapon", `The weapon name`, true), new LibraryFunctionParameter("weapon", `The means of death as a string`, true)], true, false, `Obituary( self, attacker, sWeapon, sMeansOfDeath )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Add", `Add a new objective, with ability to specify all the info for the objective`, null, [new LibraryFunctionParameter("objective_number", `The number of the objective to add`, true), new LibraryFunctionParameter("state", `A string value representing the state of the objective. Valid states are "empty", "active", "invisible", "done", "current" and "failed"`, true), new LibraryFunctionParameter("position/onEntity", `The position of the objective - or - <entity> entity to be tracked.`, false), new LibraryFunctionParameter("displayName", `The text to use for the objective. This should be a valid localized text reference`, false), new LibraryFunctionParameter("entity", `The owner entity`, false)], true, false, `Objective_Add( objective_number, "active", closest.bomb.origin, objective_text, self.objective )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_ClearAllUsing", `Clears the objective of all players using status.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_ClearEntity", `Clears the entity previous set on the objective`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_ClearPlayerUsing", `Sets the objective to be not being used by the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("player", `The player who is no longer using the objective`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Delete", `Deletes the objective`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true)], true, false, `Objective_Delete( objective_number )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_FlipIcon", `Flips the icon of the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true), new LibraryFunctionParameter("shouldFlipMaterial", `1 if the material should be flipped, 0 otherwise`, false)], false, true, `Objective_FlipIcon( self.friendlyObjID )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_GetGamemodeFlags", `Gets the gamemode flags for the objective.`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective.`, true)], true, false, `flags = Objective_GetGamemodeFlags( myObjNumber )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Icon", `Set the objective icon`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("icon", `The icon name`, true)], true, false, `objective_icon( crateObjID, "compass_supply_drop_black" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_OnEntity", `Sets the objective to get its position from an entity.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("entity", `The entity to set the objective to`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Position", `Set the objective position`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("position", `The position to set`, true)], true, false, `objective_position( self.objectiveID, self.curOrigin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Set3D", `Sets flag determining if 3D state for an objective is drawn.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("use3D", `true if should render in hud`, true), new LibraryFunctionParameter("unused", `not used`, false), new LibraryFunctionParameter("unused", `not used`, false), new LibraryFunctionParameter("unused", `not used`, false), new LibraryFunctionParameter("unused", `not used`, false)], true, false, `Objective_Set3D( myObjNum, true, undefined, undefined, undefined, (0,0,70) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetColor", `Sets a color for the objective that the icon will then be drawn with.`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective.`, true), new LibraryFunctionParameter("r/colorName", `Red float value for objective, or color name set from the UIEditor as an IString.`, true), new LibraryFunctionParameter("g", `Green float value for objective.`, false), new LibraryFunctionParameter("b", `Blue float value for objective.`, false), new LibraryFunctionParameter("a", `Alpha float value for objective. Default of 1.0 if not specified.`, false)], true, false, `Objective_SetColor( myObjNumber, 1.0, 0.0, 0.0, 1.0 )Objective_SetColor( myObjNumber, "FriendlyBlue" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetFlag", `Sets the gamemode flags for the objective.`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective to alter`, true), new LibraryFunctionParameter("flag", `- active, fadeoutonscreen, perk, drawdistance, drawname, in3d, clipToMap, primary`, true), new LibraryFunctionParameter("true/false", `turn the flag on or off`, true)], true, false, `Objective_SetFlag( myObjNumber, "active", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetGamemodeFlags", `Sets the gamemode flags for the objective.  This function only works for modes not using 3d objectives (mp).`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective.`, true), new LibraryFunctionParameter("flags", `script managed flags.`, true)], true, false, `Objective_SetGamemodeFlags( myObjNumber, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetIcon", `Sets the icon for the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client that is using the objective`, true), new LibraryFunctionParameter("objectiveNumber", `The ID of the objective to alter`, true), new LibraryFunctionParameter("materialName", `The material to set`, true)], false, true, `Objective_SetIcon( localClientNum, clientObjID, "remotemissile_target" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetIconSize", `Sets the objective's scale for the icon.`, null, [new LibraryFunctionParameter("localClientNum", `The local client that is using the objective`, true), new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("scale", `The value to scale the objective icon`, true)], false, true, `objective_SetIconSize( localClientNum, clientObjID, 50 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetInvisibleToAll", `Sets the objective to be invisible to all players.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetInvisibleToPlayer", `Sets the objective to be invisible to the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("player", `The player to whom the objective is now invisible`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetInvisibleToPlayerByIndex", `Sets the objective to be invisible to the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("entnum", `The entity number of the player to whom the objective is now invisible`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetPlayerUsing", `Sets the objective to being used by the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("player", `The player who is using the objective`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetProgress", `Sets the progress for the objective.`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective.`, true), new LibraryFunctionParameter("percent", `percent float value for objective [0-1].`, true)], true, false, `Objective_SetProgress( myObjNumber, 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetSize", `Sets a size for the objective that the icon will then be drawn at. Min is MIN_OBJECTIVE_ICON_SIZE = 5`, null, [new LibraryFunctionParameter("objective_index", `The ID of the objective.`, true), new LibraryFunctionParameter("entity/float", `The entity to get the size from or a sizeX.`, true), new LibraryFunctionParameter("float", `If sizeX was used in prvious arg, this is sizeY.`, false)], true, false, `Objective_SetSize( myObjNumber, myTrigger )Objective_SetSize( myObjNumber, 20, 30 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetStencil", `Sets the objective's stencil for the icon.`, null, [new LibraryFunctionParameter("localClientNum", `The local client that is using the objective`, true), new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("stencil", `Set to true if you want the objective to stencil`, true)], false, true, `Objective_SetStencil( localClientNum, clientObjID, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetUIModelValue", `Set a UI Model Value for an objective`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("lui menu data name", `precached name string for the data which we're trying to set.`, true), new LibraryFunctionParameter("lui menu data value", `value for the data which we're trying to set on the objective.`, true)], true, false, `Objective_SetUIModelValue( 0, "killedCount", 4 ); or Objective_SetUIModelValue( 0, "killedCount", "Four" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetVisibleToAll", `Sets the objective to be visible to all players.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetVisibleToPlayer", `Sets the objective to be visible to the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("player", `The player to whom the objective is now visible`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_SetVisibleToPlayerByIndex", `Sets the objective to be visible to the specified player.`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("entnum", `The entity number of the player to whom the objective is now visible`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_State", `Set a state for the objective`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("state", `The state to set`, true)], true, false, `Objective_State( obj_id, "active" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_Team", `Sets the team that the objective is for. Allows having different objectives for each team`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("team", `The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'`, true)], true, false, `Objective_Team( 0, "allies" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Objective_VisibleTeams", `Sets the team that the objective is visible too for. Allows having different objectives for each team`, null, [new LibraryFunctionParameter("objective_number", `The ID of the objective to alter`, true), new LibraryFunctionParameter("team", `The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'`, true)], true, false, `Objective_VisibleTeams( 0, 01101101 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OffhandWeaponsEnabled", `Determine if offhand weapons are enabled for the player`, "player", [], true, false, `enabled = player OffhandWeaponsEnabled()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OverrideLightingOrigin", `Uses the entity origin as the lighting origin instead of the center of the entity's bounding area`, "entity", [], false, true, `door OverrideLightingOrigin()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OverrideSpawnflags", `Sets the spawnflags on this entity.  Used for patching.`, "entity", [], true, false, `entity OverrideSpawnflags( 64 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathDistance", `Returns the approximate/semi-accurate path distance between two points or undefined if no path can be found.`, null, [new LibraryFunctionParameter("start", `.`, true), new LibraryFunctionParameter("end", `.`, true), new LibraryFunctionParameter("generatePathForAccurateDist", `If set to true, a real path will be generated and the total length of the path segments will be returned.`, false), new LibraryFunctionParameter("pathEnt", `Only used when generatePathForAccurateDist is set. pathEnt will be used for generating a path, so it will respect the movement type. Only supported for actors.`, false), new LibraryFunctionParameter("pathDistanceType", `The method of pathdistance calculation. Two options are PATHDIST_APPROXIMATE(using getApproximateFuturePositions), PATHDIST_CORNERPREDICTED (using getCornerPredictor).`, false), new LibraryFunctionParameter("maxCornerPredictions", `Maximum number of cornerPrediction steps when PATHDIST_CORNERPREDICTED is used. Handles the edge case when cornerPrediction may not ever finish stepping the path all the way.`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsExplosionCylinder", `Created a physics explosion cylinder`, null, [new LibraryFunctionParameter("position", `The origin of the cylinder`, true), new LibraryFunctionParameter("outer radius", `The outer radius of the cylinder`, true), new LibraryFunctionParameter("inner radius", `The inner radius of the cylinder`, true), new LibraryFunctionParameter("magnitude", `The magnitude of the explosion`, true)], true, false, `PhysicsExplosionCylinder( self.origin, 600, 240, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsExplosionSphere", `Create a physics explosion sphere`, null, [new LibraryFunctionParameter("position", `The origin of the sphere`, true), new LibraryFunctionParameter("outer radius", `The outer radius of the sphere`, true), new LibraryFunctionParameter("inner radius", `The inner radius of the sphere`, true), new LibraryFunctionParameter("magnitude", `The magnitude of the explosion`, true), new LibraryFunctionParameter("outer damage", `The optional outer damage`, false), new LibraryFunctionParameter("inner damage", `The optional inner damage`, false)], true, false, `PhysicsExplosionSphere( origin, radius, radius, 5, max_damage, min_damage )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsJetThrust", `Creates a physics jet thrust`, null, [new LibraryFunctionParameter("origin", `origin of the thrust`, true), new LibraryFunctionParameter("weapon facing dir", `The weapon facing direction`, true), new LibraryFunctionParameter("radius", `The radius of the thrust`, true), new LibraryFunctionParameter("magnitude", `The magnitude of the thrust`, true), new LibraryFunctionParameter("angle limit", `The angle limit for the thrust`, true)], true, false, `PhysicsJetThrust( self.origin, (0,0,1), 400, 1, 60)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsJolt", `Create a physics radius jolt`, null, [new LibraryFunctionParameter("position", `The origin of the jolt`, true), new LibraryFunctionParameter("outer radius", `The outer radius of the jolt`, true), new LibraryFunctionParameter("inner radius", `The inner radius of the jolt`, true), new LibraryFunctionParameter("impulse", `The impulse created by the explosion`, true)], true, false, `PhysicsJolt( self.origin, 600, 240, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsLaunch", `Permanently turn this entity into a physics object with an intial force vector at the specified point.`, "script_model", [new LibraryFunctionParameter("contact_point", `The point to apply the initial force`, false), new LibraryFunctionParameter("initial_force", `The force vector to apply`, false)], true, false, `dummy PhysicsLaunch( contact_point, initial_force )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsTrace", `Does a physics trace from start to end. Returns hit position`, null, [new LibraryFunctionParameter("start", `starting position`, true), new LibraryFunctionParameter("end", `ending position`, true), new LibraryFunctionParameter("mins", `minimum bounds`, false), new LibraryFunctionParameter("maxs", `maximum bounds`, false), new LibraryFunctionParameter("ignore entity", `the entity to not consider`, false), new LibraryFunctionParameter("mask type", `the trace modifier`, false)], true, false, `trace = PhysicsTrace( start, end, ( 0, 0, 0 ), ( 0, 0, 0 ), self, PHYSICS_TRACE_MASK_VEHICLE_CLIP )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PhysicsTraceEx", `Physics trace, ignoring characters. Returns the full trace structure.`, null, [new LibraryFunctionParameter("start", `The start point`, true), new LibraryFunctionParameter("end", `The end point`, true), new LibraryFunctionParameter("mins", `trace capsule min`, false), new LibraryFunctionParameter("maxs", `trace capsule max`, false), new LibraryFunctionParameter("entity", `entity to ignore`, false), new LibraryFunctionParameter("player clip", `collide with the player solid mask instead of ai solid mask`, false)], true, false, `trace = PhysicsTraceEx( start, end, (-10,-10,0), (10,10,0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaceSpawnPoint", `Raises the spawn point up to make sure it's not in the ground, then drops it back down into the ground.`, "spawn point", [], true, false, `spawnpoints[i] PlaceSpawnPoint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayBattleChatterToTeam", `Play the sound alias as if coming from the entity, so that only one team can hear it`, "entity", [new LibraryFunctionParameter("aliasname1", `The first sound alias to play`, true), new LibraryFunctionParameter("aliasname2", `The second sound alias to play`, true), new LibraryFunctionParameter("teamname", `The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.`, true), new LibraryFunctionParameter("ignoreplayer", `If present, this player will not hear the sound.`, false)], true, false, `self PlaySoundToTeam( "frag_out", "axis", self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerBeingSpectated", `Returns the player the local client is spectating or the player himself if no spectating is going on`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client to check`, true)], false, true, `spectated = PlayerBeingSpectated( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerBulletTrace", `Allows script to do a bullet point trace with CONTENTS_PLAYER, collides with player hitboxes. Returns hit position, hit entity, hit surface normal.`, null, [new LibraryFunctionParameter("start", `The bullet start point`, true), new LibraryFunctionParameter("end", `The bullet end point`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore`, true)], true, false, `trace = PlayerBulletTrace( magicBulletOrigin.origin, eyePos, undefined )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerCamLinkTo", `Sets the player's vision to look through another entity.`, "player", [new LibraryFunctionParameter("entity", `Entity to look through.`, true), new LibraryFunctionParameter("tagname", `Name of tag on host model to attach to.`, true)], true, false, `level.player2 CameraLinkTo( cameraUpstairs, "tag_player" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerCamUnlink", `Unlinks the player's vision from an entity.`, "player", [], true, false, `level.player2 CameraUnlink( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerGrappleTrace", `Trace to see if grapple is valid`, null, [new LibraryFunctionParameter("start", `starting position`, true), new LibraryFunctionParameter("end", `ending position`, true), new LibraryFunctionParameter("ignore entity", `this entity should be ignored`, false)], true, false, `hitp = PlayerGrappleTrace(player.origin, player.origin + (0,0,-500))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkedOffsetDisable", `If disabled, the linked player's orientation will not use their link offset.`, "linked_player", [], true, false, `ac130guy PlayerLinkedOffsetDisable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkedOffsetEnable", `If enabled, the linked player's orientation will use their link offset. This is traditional (CoD4) LinkTo behavior for a player.`, "linked_player", [], true, false, `ac130guy PlayerLinkedOffsetEnable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkedSetUseBaseAngleForViewClamp", `Sets the whether the player's view clamp is based on the entity (true) or the tag selected (false). Must be called after linking using WeaponViewToDelta`, "linked_player", [new LibraryFunctionParameter("enable", `whether or not to enable using the base entity for the view angle clamp base.`, true)], true, false, `player PlayerLinkedSetUseBaseAngleForViewClamp( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkTo", `Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. Rotating the parent entity/tag will not move the player's eye position, but only the player's view angles. Thus, the player's eye position is locked in place, always directly above the parent tag.`, "player", [new LibraryFunctionParameter("linkto entity", `The entity to attach the player to.`, true), new LibraryFunctionParameter("tag", `The tag to attach the player to.`, false), new LibraryFunctionParameter("view fraction", `How much the change in the tag's rotation effects the players view. Defaults to 0.`, false), new LibraryFunctionParameter("right arc", `Angle to clamp view to the right. Defaults to 180.`, false), new LibraryFunctionParameter("left arc", `Angle to clamp view to the left. Defaults to 180.`, false), new LibraryFunctionParameter("top arc", `Angle to clamp view to the top. Defaults to 180.`, false), new LibraryFunctionParameter("bottom arc", `Angle to clamp view to the bottom. Defaults to 180.`, false), new LibraryFunctionParameter("use tag angles", `Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.`, false), new LibraryFunctionParameter("auto recenter", `Players view will auto recenter to the tag he is linked to. use tag angles must be true.`, false)], true, false, `level.player PlayerLinkTo( vehicle, "tag_player", 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkToAbsolute", `Attaches the player to an entity. No view movement is allowed.  The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)`, "player", [new LibraryFunctionParameter("lockto entity", `The entity to attach the player to`, true), new LibraryFunctionParameter("tag", `The tag to attach the player to`, false)], true, false, `player PlayerLinkToAbsolute( vehicle, "tag_player" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkToBlend", `Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.`, "player", [new LibraryFunctionParameter("parent", `The entity to attach the player to.`, true), new LibraryFunctionParameter("tag", `The tag to attach the player to.`, false), new LibraryFunctionParameter("pos time", `Lerp duration in seconds. Default is 1.`, false), new LibraryFunctionParameter("pos accel time", `Acceleration time. Default is 0.`, false), new LibraryFunctionParameter("pos decel time", `Decelaration time. Default is 0.`, false), new LibraryFunctionParameter("angle time", `angle Lerp duration in seconds. Default is <time>.`, false), new LibraryFunctionParameter("angle accel time", `angle Acceleration time. Default is 0.`, false), new LibraryFunctionParameter("angle decel time", `angle Decelaration time. Default is 0.`, false)], true, false, `player PlayerLinkToBlend( ice_pick, "tag_origin`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkToDelta", `Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)`, "player", [new LibraryFunctionParameter("linkto entity", `The entity to attach the player to.`, true), new LibraryFunctionParameter("tag", `The tag to attach the player to.`, false), new LibraryFunctionParameter("view fraction", `How much the change in the tag's rotation effects the players view. Defaults to 0.`, false), new LibraryFunctionParameter("right arc", `Angle to clamp view to the right. Defaults to 180.`, false), new LibraryFunctionParameter("left arc", `Angle to clamp view to the left. Defaults to 180.`, false), new LibraryFunctionParameter("top arc", `Angle to clamp view to the top. Defaults to 180.`, false), new LibraryFunctionParameter("bottom arc", `Angle to clamp view to the bottom. Defaults to 180.`, false), new LibraryFunctionParameter("use tag angles", `Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.`, false), new LibraryFunctionParameter("auto recenter", `Players view will auto recenter to the tag he is linked to. use tag angles must be true.`, false)], true, false, `level.player PlayerLinkToDelta( vehicle, "tag_player", 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerLinkWeaponViewToDelta", `Similar to PlayerLinkToDelta(), but the player's body stays behind. The player's view attaches to the tag, and any weapon fire will also come from there.`, "player", [new LibraryFunctionParameter("linkto entity", `The entity to attach the player to.`, true), new LibraryFunctionParameter("tag", `The tag to attach the player to.`, false), new LibraryFunctionParameter("view fraction", `How much the change in the tag's rotation effects the players view. Defaults to 0.`, false), new LibraryFunctionParameter("right arc", `Angle to clamp view to the right. Defaults to 180.`, false), new LibraryFunctionParameter("left arc", `Angle to clamp view to the left. Defaults to 180.`, false), new LibraryFunctionParameter("top arc", `Angle to clamp view to the top. Defaults to 180.`, false), new LibraryFunctionParameter("bottom arc", `Angle to clamp view to the bottom. Defaults to 180.`, false), new LibraryFunctionParameter("use tag angles", `Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.`, false)], true, false, `level.player PlayerLinkToDelta( vehicle, "tag_player", 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerPhysicsTrace", `Does a physics trace and returns the hit point.`, null, [new LibraryFunctionParameter("start", `starting position`, true), new LibraryFunctionParameter("end", `ending position`, true)], true, false, `hitp = PlayerPhysicsTrace(player.origin + (0,0,72), player.origin + (0,0,-500))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerPhysicsTraceIgnoreEnt", `Does a physics trace and returns the hit point.`, null, [new LibraryFunctionParameter("start", `starting position`, true), new LibraryFunctionParameter("end", `ending position`, true)], true, false, `hitp = PlayerPhysicsTraceIgnoreEnt(player.origin + (0,0,72), player.origin + (0,0,-500))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerPositionValid", `Returns true if the passed in origin is valid for a spawn (ie not inside something).`, null, [new LibraryFunctionParameter("position", `The position of the potential spawn point`, true)], true, false, `if(playerpositionvalid(spawnpoints[i].origin))...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerPositionValidIgnoreEnt", `Returns true if the passed in origin is valid for a spawn (ie not inside something).`, null, [new LibraryFunctionParameter("position", `The position of the potential spawn point`, true)], true, false, `if(PlayerPositionValidIgnoreEnt(spawnpoints[i].origin))...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerSetGroundReferenceEnt", `The ground entity's rotation will be added onto the player's view.  In particular, this will cause the player's yaw to rotate around the entity's z-axis instead of the world z-axis.  You only need to call this function once.  After that, any rotation that the reference entity undergoes will affect the player.  Call this command again with undefined to turn it off.`, "player", [new LibraryFunctionParameter("ground reference entity", `The entity used to rotate the player's view.`, true)], true, false, `player PlayerSetGroundReferenceEnt( seaEnt )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerSightTrace", `Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.`, null, [new LibraryFunctionParameter("position", `place that check if you can see if being performed`, true), new LibraryFunctionParameter("maxDistance", `if the position is further than this -1 will be returned`, true), new LibraryFunctionParameter("hitNum", `if you run this more than once make sure to populate this with the return of the last as it will increase efficiency`, true)], true, false, `if (0 == (self Playersighttrace(positionOfFlare, 200, lastHit))`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayFX", `Plays the fx at the given location.`, null, [new LibraryFunctionParameter("fx name", `Name of the fx. Fx has to be cached`, true), new LibraryFunctionParameter("position", `Position to play the fx at`, true), new LibraryFunctionParameter("forward", `The forward vector of the fx`, false), new LibraryFunctionParameter("up", `The up vector of the fx`, false), new LibraryFunctionParameter("ignore pause", `True if the fx should play even when the game is paused.`, false)], true, false, `PlayFX( level._effect["nuke_fx"], nuke_pos.origin, forward, up )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayFXOnCamera", `Plays the fx at the given offset from the camera.`, null, [new LibraryFunctionParameter("fx name", `Name of the fx. Fx has to be cached`, true), new LibraryFunctionParameter("offset", `Offset from camera to play fx`, false), new LibraryFunctionParameter("forward", `The forward vector of the fx`, false), new LibraryFunctionParameter("up", `The up vector of the fx`, false), new LibraryFunctionParameter("ignore pause", `True if the fx should play even when the game is paused.`, false)], true, false, `PlayFX( level._effect["bubbles"], offset, forward, up )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayFXOnTag", `Play fx on a particular tag of an entity`, null, [new LibraryFunctionParameter("fx name", `Name of the fx. Fx has to be cached`, true), new LibraryFunctionParameter("entity", `The entity to play the fx on. Should have a model`, true), new LibraryFunctionParameter("tag", `The tag to play the fx on`, true), new LibraryFunctionParameter("ignore pause", `True if the fx should play even when the game is paused.`, false)], true, false, `PlayFxOnTag( level._effect["character_fire_death_torso"], self, "J_Spine1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayLoopedFX", `Play an fx which is looped`, null, [new LibraryFunctionParameter("fx name", `Name of the fx. Fx has to be cached`, true), new LibraryFunctionParameter("repeat", `Time to repeat after`, true), new LibraryFunctionParameter("position", `Position to play the fx at`, true), new LibraryFunctionParameter("cull distance", `The cull distance for the fx`, false), new LibraryFunctionParameter("forward", `The forward vector of the fx`, false), new LibraryFunctionParameter("up", `The up vector of the fx`, false)], true, false, `PlayLoopedFX( level._effect[self.v["trailfx"]], self.v["trailfxdelay"], self.v["origin"], 0, self.v["forward"], self.v["up"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayLoopSound", `Play a looping sound with an optional fadetime in seconds.`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true), new LibraryFunctionParameter("fadetime", `Time to fade the sound in. Range is between 1 and 31 inclusive.`, false)], true, false, `fire_sound_ent playloopsound ("mpl_player_burn_loop")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRumbleLoopOnEntity", `Plays a looping rumble on the given entity.`, "entity", [new LibraryFunctionParameter("rumble name", `The name of the rumble to play`, true)], true, false, `self PlayRumbleLoopOnEntity( "damage_heavy" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRumbleLoopOnPosition", `Play a looping rumble on the given position`, null, [new LibraryFunctionParameter("rumblename", `The rumble name`, true), new LibraryFunctionParameter("position", `The rumble position`, true)], true, false, `PlayRumbleLoopOnPosition( "grenade_rumble", origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRumbleOnEntity", `Plays a rumble on the given entity.`, "entity", [new LibraryFunctionParameter("rumble name", `The name of the rumble to play`, true)], true, false, `self PlayRumbleOnEntity( "damage_heavy" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRumbleOnPosition", `Play a rumble on the given position`, null, [new LibraryFunctionParameter("rumblename", `The rumble name`, true), new LibraryFunctionParameter("position", `The rumble position`, true)], true, false, `PlayRumbleOnPosition( "grenade_rumble", origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySound", `Play the sound at the entity`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true)], true, false, `bomb PlaySound( "zmb_bomb_explode" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundAtPosition", `Play the sound alias from a position`, null, [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true), new LibraryFunctionParameter("position", `The point where the sound is played`, true)], true, false, `PlaySoundAtPosition("Dirt_skid", ( 100, 100, 0 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundOnTag", `Play the sound alias as if coming from the tag`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play, this can be the string name, or the integer hash`, true), new LibraryFunctionParameter("tag", `If present, the sound will play at the position of the given tag`, false), new LibraryFunctionParameter("team", `If present or not undefined the sound will only be heard by the specified team`, false), new LibraryFunctionParameter("ent", `If present the sound will also be heard on the specified entity`, false)], true, false, `self PlaySoundOnTag( soundAlias, "J_Head")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundToAllButPlayer", `Play the sound alias as if coming from the entity, so that everyone but one player can hear it`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play (string)`, true), new LibraryFunctionParameter("player", `The player that will not be able to hear the sound. (entity)`, true)], true, false, `self PlaySoundToAllButPlayer( "frag_out", self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundToPlayer", `Play the sound alias as if coming from the entity, so that only one player can hear it`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play (string) or the sound alias (int)`, true), new LibraryFunctionParameter("player", `The player that will be able to hear the sound. (entity)`, true)], true, false, `self PlaySoundToPlayer( "frag_out", self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundToTeam", `Play the sound alias as if coming from the entity, so that only one team can hear it`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true), new LibraryFunctionParameter("teamname", `The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.`, true), new LibraryFunctionParameter("ignoreplayer", `If present, this player will not hear the sound.`, false)], true, false, `self PlaySoundToTeam( "frag_out", "axis", self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlaySoundWithNotify", `Play the sound alias as if coming from the entity`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true), new LibraryFunctionParameter("notification string", `If present, the sound will notify this string on this entity when done.stopsounds`, false), new LibraryFunctionParameter("tag", `If present, the sound will play at the position of the given tag`, false)], true, false, `self PlaySoundWithNotify("Dirt_skid","skidsound")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionQuery_Filter_Directness", `Directness filter compute the direction information for each of the positions, relative to <origin> and <target>.`, null, [new LibraryFunctionParameter("queryStruct", `result from PositionQuery_Source function. each point contained here will have direction info computed.`, true), new LibraryFunctionParameter("origin", `usually the position of AI before move.`, true), new LibraryFunctionParameter("target", `the position AI is trying to approach.`, true), new LibraryFunctionParameter("resultVarName", `by default the result directness value will be stored in pointStruct.directness, but can be override by this string.`, false)], true, false, `PositionQuery_Filter_Directness( queryResult, self.origin, self.enemy.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionQuery_Filter_DistanceToGoal", `Calculate the distance to <entity>.goalpos. If the point is in <entity>.goalradius, the distance will be 0. the result is in pointStruct.distToGoal`, null, [new LibraryFunctionParameter("queryStruct", `result from PositionQuery_Source function."`, true), new LibraryFunctionParameter("entity", `the entity used to check goal."`, true)], true, false, `PositionQuery_Filter_DistanceToGoal( queryResult, self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionQuery_Filter_InClaimedLocation", `Check if the locations are inside other sentients claimed locations <entity>.inClaimedLocation.`, null, [new LibraryFunctionParameter("queryStruct", `result from PositionQuery_Source function."`, true), new LibraryFunctionParameter("entity", `the entity used to check goal."`, true)], true, false, `PositionQuery_Filter_InClaimedLocation( queryResult, self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionQuery_Filter_Sight", `Sight filter do sight check on each of the positions to a target position, and store the result in pointStruct.visibility (boolean).`, null, [new LibraryFunctionParameter("queryStruct", `result from PositionQuery_Source function. each point contained here will be used to check sight against <targetPosition>. "`, true), new LibraryFunctionParameter("targetPosition", `the position to check sight."`, true), new LibraryFunctionParameter("offset", `offset to add on each point before sight checking. this is usually something like: offset = ai GetEye() - ai.origin. default to (0,0,0). "`, false), new LibraryFunctionParameter("visibleBy_Ent", `if defined, the corresponding sight check function on Actor or Vehicle will be called. Otherwise the checks just do simple bullet tracing."`, false), new LibraryFunctionParameter("numOfPassedToEarlyOut", `if defined and bigger than 0, the filter will early out after found this many passed sight checks. this is useful if the points are pre sorted by score and we don't care about lower scored ones."`, false), new LibraryFunctionParameter("ignoreEnt", `ignore entity during trace. if [visibleBy_Ent] is defined, it is already ignored internally. "`, false), new LibraryFunctionParameter("resultVarName", `by default the results will be stored in pointStruct.visibility, but can be override by this string. "`, false)], true, false, `PositionQuery_Filter_Sight( queryResult, self.enemy.origin, self GetEye() - self.origin, self, 30, self.enemy );`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionQuery_Source_Navigation", `Generate points around <origin>, between <minSearchRadius> and <maxSearchRadius> and within <halfHeight> height difference. For ground AI, the points will be on Nav Mesh; for flying AI, the points will be in Nav Volume. Only the points in pathable area will be kept. If the <origin> itself is in pathable area, all the points are guaranteed to be reachable from <origin>. If the <origin> is outside pathable area, all the points will still be in pathable areas surrounding <origin>, but reach-abilities cannot be guaranteed.`, null, [new LibraryFunctionParameter("origin", `Position to start the search around.`, true), new LibraryFunctionParameter("minSearchRadius", `the minimum radius away from origin.`, true), new LibraryFunctionParameter("maxSearchRadius", `the maximum radius away from origin. can equal to minSearchRadius.`, true), new LibraryFunctionParameter("halfHeight", `the max height difference (both positive and negative) away from origin.`, true), new LibraryFunctionParameter("innerSpacing", `the distance between points in.`, true), new LibraryFunctionParameter("reachableBy_Ent", `if defined, it will be used to make sure all the points are reachable by this entity from <origin> (not the entity's current position). Can pass in a float number radius to get points on NavMesh. Can also pass in string 'navvolume_small' or 'navvolume_big' to get points on navvolume. Note passing in entity radius only gives rough estimate, not correct result.`, false), new LibraryFunctionParameter("outerSpacing", `if defined, the distance between points will be Lerped from <innerSpacing> to [outerSpacing], to create a gradual distribution.`, false), new LibraryFunctionParameter("distributionBias", `(vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.`, false)], true, false, `queryResult = PositionQuery_Source_Navigation( goalpos, self.radius, self.radius * 8, heightRadius, AI_GOAL_POINT_STEP, self, AI_GOAL_POINT_STEP * 0.2 )if ( queryResult.centerOnNav ){foreach( pointStruct in queryResult.data ){position = pointStruct.origindist = pointStruct.distToOrigin2D...}}`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PositionWouldTelefrag", `Returns true if the passed in origin would telefrag a player if another player was spawned there.`, null, [new LibraryFunctionParameter("position", `The position of the potential spawn point`, true)], true, false, `if ( PositionWouldTelefrag( spawnpoints[i].origin ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PrecacheLeaderboards", `Precache a sp/mp leaderboard.`, null, [new LibraryFunctionParameter("leaderboard names", `The name of the leaderboards to precache`, true)], true, false, `PrecacheLeaderboards( "LB_KILLS LB_WINS LB_TOTALXP LB_ACCURACY" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictGrenade", `Predict where the grenade (self) will explode.`, "grenade", [], true, false, `grenade PredictGrenade()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictPosition", `Predict position of the entity at the end of the frames`, null, [new LibraryFunctionParameter("ent", `The entity to predict position of`, true), new LibraryFunctionParameter("frames", `The frame count`, true)], true, false, `prediction = PredictPosition( ent, 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictSpawnPoint", `Indicates to the Texture Streamer where we expect to spawn in.`, "player", [new LibraryFunctionParameter("origin", `The origin to spawn at`, true), new LibraryFunctionParameter("angles", `The angle.`, true)], true, false, `player predictSpawnPoint( origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Print", `Development only - write to the console`, null, [new LibraryFunctionParameter("text", `text to be written`, true)], true, false, `Print( "Stuff and things!" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PrintLn", `Development only - write line to the console`, null, [new LibraryFunctionParameter("text", `text to be written`, true)], true, false, `PrintLn( "I could be doing better!" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ProcessClientFieldsAsIfNew", `Process the client fields again`, "client", [], false, true, `self ProcessClientFieldsAsIfNew()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PropagateCurrentEvent", `Propagate the current event to other AI.`, "ai_or_player", [], true, false, `point = self PropagateCurrentEvent()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("QSortScoredSpawnPointsAscending", `Sort the scored spawn points in an ascending order`, null, [new LibraryFunctionParameter("input_array", `The array of points`, true)], true, false, `sorted_spawn_points = QSortScoredSpawnPointsAscending( scored_spawn_points )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("queuemeleeactionstate", `Sets the queued action state to melee for the player's default hand.`, null, [], true, false, `player QueueMeleeActionState()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RadioActive_FX", `Plays RadioActive/Fire FX`, "entity", [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity RadioActive_FX(0, true)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RadiusDamage", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReCacheLeaderboards", `recaches local client leaderboard`, null, [], false, true, `recacheleaderboards(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RecordBreadcrumbDataForPlayer", `record a breadcrumb data point for player at time`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RefreshShieldAttachment", `Re-attach the shield model to the player.`, "player", [], true, false, `player RefreshShieldAttachment()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RegisterClientField", `Register a client field. Client fields are variable bit length fields communicated from server to client.`, null, [new LibraryFunctionParameter("Client field pool name", `Which pool the field is allocated from. Currently supported : "world", "actor", "vehicle", "scriptmover"`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("version", `Number indicating version this field was added in - see _version.gsh for defines.`, true), new LibraryFunctionParameter("num bits", `How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.`, true), new LibraryFunctionParameter("type", `Type of the field. Currently supported types "int" or "float"`, true)], true, false, `RegisterClientField("world", "my_field", 2, "int"); // registers a world int field with 2 bits of resolution, that can hold the values 0,1,2,3.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RegisterSkipto", `Register a new skipto name`, null, [new LibraryFunctionParameter("skipto_name", `The skipto name to register`, true)], true, false, `struct.code_index = RegisterSkipto( msg )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReleaseClaimedTrigger", `Release a currently claimed trigger`, "trigger", [], true, false, `self.trigger releaseClaimedTrigger()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveAllFriendlyScramblers", `removes all friendly scramblers`, "player", [], false, true, `player RemoveAllFriendlyScramblers( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveAllSensorGrenadeAreas", `removes all sensor grenade areas`, "player", [], false, true, `player RemoveAllSensorGrenadeAreas( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveForceNoCull", `Removes the force-no-cull flag. Entity will now be culled by portals`, "entity", [], true, false, `helicopter RemoveForceNoCull()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveFriendlyScrambler", `removes new friendly scrambler from the compass using the same handle you gave when creating it`, "player", [new LibraryFunctionParameter("handle", `will be used to remove the scrambler`, true)], false, true, `player RemoveFriendlyScrambler( scrambler.handle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveInfluencer", `Removes the given influencer`, null, [new LibraryFunctionParameter("influencer id", `The influencer to remove`, true)], true, false, `RemoveInfluencer( influencer_id )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveNoSunShadow", `Removes the no-sunshadow flag.`, "entity", [], true, false, `helicopter RemoveNoSunShadow()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveSensorGrenadeArea", `Removes Sensor Grenade Area from the compass`, "player", [new LibraryFunctionParameter("handle", `will be used to remove the sensor`, true)], false, true, `player RemoveSensorGrenadeArea( sensor.handle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveZombieBoxWeapon", `Removes a zombie box weapon`, null, [new LibraryFunctionParameter("weapon", `The weapon to remove`, true)], false, true, `RemoveZombieBoxWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RenderHealthOverlay", `Returns the whether the health overlay should be rendered or not`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `yesno = RenderHealthOverlay( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RenderHealthOverlayHealth", `Returns the whether the health overlay health ratio`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the player`, true)], false, true, `yesno = RenderHealthOverlayHealth( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReportUser", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetAILimit", `Clears any previous restrictions on the max number of AI.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetDestructible", `Resets the destructible entity back to its start state`, "entity", [], true, false, `vehicle ResetDestructible()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetDoubleJumpRechargeTime", `Resets the double jump recharge timer as if the player had just used it`, "player", [], true, false, `player ResetDoubleJumpRechargeTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetFOV", `Replace the current FOV by the default FOV`, "player", [], true, false, `player ResetFOV()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetGlass", `Server side glass struct loops through all glass and resets to inital state`, null, [], true, false, `ResetGlass()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetMissileDetonationTime", `Resets the timer for a grenade or missile to its max fuse time.`, "entity", [new LibraryFunctionParameter("time", `Override the reset timer from the weapon and specify the time left.`, false)], true, false, `grenadeEnt ResetMissileDetonationTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetWeaponCosts", `Reset the zombie weapon costs`, null, [new LibraryFunctionParameter("local client num", `The local client num`, true)], false, true, `ResetWeaponCosts( <local client num>  )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetZombieBoxWeapons", `Reset the zombie box weapons`, null, [], false, true, `ResetZombieBoxWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReviveObituary", `Create an revive obituary for a character`, null, [new LibraryFunctionParameter("victim", `The victim entity`, true)], true, false, `Obituary( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RopeGetPosition", `Queries the position of the rope.`, null, [new LibraryFunctionParameter("ropeid", `The id of the rope`, true), new LibraryFunctionParameter("frac", `Value between 0 and 1 specifying what position we are querying.`, true)], false, true, `RopeGetPosition( ropeid, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RopePulse", `Creates a stimulus that will effect ropes in the area and radius of the event.  Amount of movement is based on damage calculation.  Cheaper than physics events, as it only effects ropes.  Zero network cost, as it's on the client.`, null, [new LibraryFunctionParameter("origin", `Where the event is.`, true), new LibraryFunctionParameter("innerRadius", `inner radius of event.  At this radius or lower, innerDamage is done.`, true), new LibraryFunctionParameter("outerRadius", `outer radius of event.  Maximum extent at which outerDamage is done.  Damage scales to innerDamage between outerRadius and innerRadius`, true), new LibraryFunctionParameter("innerDamage", `how much damage is applied at innerRadius, or lower.`, true), new LibraryFunctionParameter("outerDamage", `how much damage is applied at outerRadius.`, true)], false, true, `RopePulse(sRopePulse.origin, 10, 150, 100, 1); // 150 damage applied at 10 units or less, 1 damage applied at 150 units distance.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Rotate", `Causes a script entity to rotate, rotating around its origin`, null, [new LibraryFunctionParameter("rotation vector", `The direction of the bobbing`, true)], true, false, `self Rotate( rotationVir )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotatePitch", `Rotate this entity to the given pitch`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("pitch angle", `The new pitch angle in degrees`, true), new LibraryFunctionParameter("time", `The time to rotate in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `treeorg RotatePitch( -5, 0.26, 0.15, 0.1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotateRoll", `Rotate this entity to the given roll angle`, "model_origin_brushmodel", [new LibraryFunctionParameter("roll angle", `The new roll angle in degrees`, true), new LibraryFunctionParameter("time", `The time to rotate in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `self RotateRoll( (2 * 1500 + 3 * Randomfloat( 2500 )) * -1, 5, 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotateTo", `Rotate this entity to the given world rotation value`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("angles", `The new world angle to rotate to`, true), new LibraryFunctionParameter("time", `The time to rotate in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `shutter RotateTo( (shutter.angles[0], newYaw, shutter.angles[2]), newTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotateVelocity", `Rotate this entity at a particular velocity for a given time`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("rotate velocity", `The rotational velocity to rotate`, true), new LibraryFunctionParameter("time", `The time to rotate in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `self RotateVelocity( (x,y,z), 12 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotateYaw", `Rotate this entity to the given yaw`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("yaw angle", `The new yaw angle in degrees`, true), new LibraryFunctionParameter("time", `The time to rotate in seconds`, true), new LibraryFunctionParameter("acceleration time", `The time spent accelerating in seconds`, false), new LibraryFunctionParameter("deceleration time", `The time spent decelerating in seconds`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ScreenShake", `Create a screen shake event on the given point.`, null, [new LibraryFunctionParameter("sourcePoint", `The position of the earthquake.`, true), new LibraryFunctionParameter("scalepitch", `The scale of the shake in player's pitch. Max is 100; Accurate to 2 decimal places.`, true), new LibraryFunctionParameter("scaleyaw", `The scale of the shake in player's yaw. Max is 100; Accurate to 2 decimal places.`, true), new LibraryFunctionParameter("scaleroll", `The scale of the shake in player's roll. Max is 100; Accurate to 2 decimal places.`, true), new LibraryFunctionParameter("duration", `Duration in seconds.`, true), new LibraryFunctionParameter("durationfadeup", `Duration in seconds, included in base duration. Default is 0. Value of -1 means duration - durationfadeup.`, false), new LibraryFunctionParameter("durationfadedown", `Duration in seconds, included in base duration. Default is -1. Value of -1 means duration - durationfadedown.`, false), new LibraryFunctionParameter("radius", `The radius of shake, dampens as you move away from entity. Default is 0 = shake is global`, false), new LibraryFunctionParameter("frequencypitch", `The scaled speed of the shake's pitch. Default is 1. Max is 100; Accurate to 2 decimal places.`, false), new LibraryFunctionParameter("frequencyyaw", `The scaled speed of the shake's yaw. Default is 1. Max is 100; Accurate to 2 decimal places.`, false), new LibraryFunctionParameter("frequencyroll", `The scaled speed of the shake's roll. Default is 1. Max is 100; Accurate to 2 decimal places.`, false), new LibraryFunctionParameter("exponent", `The scale is multiplied by itself 'exponent' times to determine how the shake falls off. Default is 1 which is a linear falloff. Max is 100; Accurate to 2 decimal places`, false), new LibraryFunctionParameter("target", `Target is given if screen shake is to be shown to particular client only`, false)], true, false, `ScreenShake( jolt.origin, 0.3, 0.3, 0.3, 3, 0.2, 3, 850, 0.5, 0.25, 0.25 ); // locationalScreenShake( (0,0,0), 0.3, 0.3, 0.3, 3, 0.2, 3, 0, 0.5, 0.25, 0.25, player ); // non locational for one player only`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SendFaceEvent", `Broadcast to the client a face event`, "entity", [new LibraryFunctionParameter("index", `Face event index (string)`, true)], true, false, `self SendFaceEvent( <index> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SendKillstreakDamageEvent", `Send a killstreak damage event to the client`, null, [new LibraryFunctionParameter("damage", `How much damage was done`, false)], true, false, `killstreakOwner SendKillstreakDamageEvent( 25 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerFieldGetValue", `Get the value of a serverfield from a given player`, null, [new LibraryFunctionParameter("player", `player to get value from`, true), new LibraryFunctionParameter("name", `name of field to retrieve`, true)], true, false, `ServerFieldGetValue(self, "my_field"); `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerFieldIncrement", `increment the value in a server field.  wrap on overflow.  `, null, [new LibraryFunctionParameter("player", `the player to operate on`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true)], false, true, `ServerFieldIncrement(player, "my_field")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("serverfieldregister", `Register a server field. Server fields are variable bit length fields communicated from client to server`, null, [new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("num bits", `How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.`, true), new LibraryFunctionParameter("type", `Type of the field. Currently supported types "int" or "float"`, true), new LibraryFunctionParameter("callback", `Function that gets called when the value changes (each client can toggle this bit independently of the others)`, true)], true, false, `RegisterServerField("my_field", 2, "int"); // registers an int field with 2 bits of resolution, that can hold the values 0,1,2,3.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("serverfieldsetval", `Register a server field.  server fields are variable bit length fields communicated from client to server`, null, [new LibraryFunctionParameter("player", `the player to operate on`, true), new LibraryFunctionParameter("name", `Unique name to identify the field.`, true), new LibraryFunctionParameter("value", `the value of the field`, true)], false, true, `RegisterServerField("my_field", VERSION_SHIP, 2, "int", ::my_cb_func); // registers a world int field with 2 bits of resolution, that can hold the values 0,1,2,3.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjective", `Returns the index of the objective or undefined if it does not exist`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveName", `The name of the objective`, true)], false, true, `objective_num = ServerObjective_GetObjective( localClientNum, "dom_a" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjectiveEntity", `Returns the entity of the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true)], false, true, `origin = ServerObjective_GetObjectiveEntity( localClientNum, objective_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjectiveGameModeFlags", `Returns the origin of the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true)], false, true, `origin = ServerObjective_GetObjectiveGameModeFlags( localClientNum, objective_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjectiveOrigin", `Returns the index of the objective or undefined if it does not exist`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true)], false, true, `origin = ServerObjective_GetObjectiveOrigin( localClientNum, objective_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjectiveProgress", `Returns the origin of the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true)], false, true, `origin = ServerObjective_GetObjectiveProgress( localClientNum, objective_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServerObjective_GetObjectiveTeam", `Returns the origin of the objective`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("objectiveID", `The index of objective`, true)], false, true, `origin = ServerObjective_GetObjectiveTeam( localClientNum, objective_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServiceEvent", `Set the specified event to serviced.`, "ai", [new LibraryFunctionParameter("eventId", `The identifier of the event (integer)`, true)], true, false, `point = self ServiceEvent( 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ServiceEventsInRadius", `Set the events within a radius to serviced.`, "ai", [new LibraryFunctionParameter("origin", `Source position`, true), new LibraryFunctionParameter("radius", `Radius of events to service (-1 for all)`, true)], true, false, `self ServiceEventsInRadius( self.origin, 500 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeAbbreviation", `Returns abbreviation of the current session mode, or "default" if none`, null, [], true, false, `spawnpointname = SessionModeAbbreviation() + "_frontend_camera`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsCampaignDeadOpsGame", `Returns true/false if the current session mode is DeadOps game`, null, [], false, true, `if ( SessionModeIsCampaignDeadOpsGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsCampaignGame", `Returns true/false if the current session mode is a campaign game`, null, [], true, false, `if ( SessionModeIsCampaignGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsCampaignZombiesGame", `Returns true/false if the current session mode is a campaign game and the campaign mode is set to zombies.`, null, [], true, true, `if ( SessionModeIsCampaignZombiesGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsMultiplayerGame", `Returns true/false if the current session mode is a multiplayer game`, null, [], true, false, `if ( SessionModeIsMultiplayerGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsOnlineGame", `Returns true/false if the current session mode is onlinegame`, null, [], true, false, `if ( SessionModeIsOnlineGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsPrivate", `Returns true/false if the current session mode is a private game`, null, [], true, false, `if ( SessionModeIsPrivate() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsPrivateOnlineGame", `Returns true/false if the current session mode is a private onlinegame`, null, [], true, false, `if ( SessionModeIsPrivateOnlineGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsSystemlink", `Returns true/false if the current session mode is a systemlink game`, null, [], true, false, `if ( SessionModeIsSystemlink() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SessionModeIsZombiesGame", `Returns true/false if the current session mode is a zombies game`, null, [], true, false, `if ( SessionModeIsZombiesGame() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetActorWeapon", `Sets the actor weapon.`, "entity", [new LibraryFunctionParameter("weaponname", `The weapon name. (string)`, true), new LibraryFunctionParameter("weapon options", `options value computed using calcweaponoptions`, false)], true, false, `self SetActorWeapon( "weapon_name" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAILimit", `Allows you to specify a max number of active AI - which over-rides the MAX_AI functionality in the engine, when it comes time to spawn in new AI.  Setting the value higher will not give you more AI than the system supports.`, null, [], true, false, `SetAILimit( 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAISpread", `Sets the spread of this turret when used by an AI`, "turret", [new LibraryFunctionParameter("spread", `The spread of the turret in degrees`, true)], true, false, `roof_turret SetAISpread( 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAmbientSnapshot", `Sets the ambient snapshot`, null, [new LibraryFunctionParameter("name", `Name of the snapshot`, true)], false, true, `SetAmbientSnapshot( level._sndActiveSnapshot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnim", `Restart": These functions cause the animation to restart. If they had been previously playing, without this they would continue from their current time.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnim( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimForceNew", `Debug only functionality that adds a new instance of an animation to an animtree setting its time to a specific point.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to set this animation to after adding it. Defaults to 0.`, false), new LibraryFunctionParameter("goalTime", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimForceNew( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnob", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnob( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobAll", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("root", `An ancestor of the animation.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobAll( %precombatrun1, %body, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobAllLimited", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("root", `An ancestor of the animation.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobAllLimited( %precombatrun1, %body, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobAllLimitedRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("root", `An ancestor of the animation.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobAllLimitedRestart( %precombatrun1, %body, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobAllRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("root", `An ancestor of the animation.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobAllRestart( %precombatrun1, %body, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobLimited", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobLimited( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobLimitedRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobLimitedRestart( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimKnobRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], true, false, `self SetAnimKnobRestart( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimLimited", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], false, true, `self SetAnimLimited( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimLimitedRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], false, true, `self SetAnimLimitedRestart( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimRestart", `See "SetAnim.`, "entity", [new LibraryFunctionParameter("animation", `The animation or animtree node to change.`, true), new LibraryFunctionParameter("weight", `Goal weight of this animation. Defaults to 1.0.`, false), new LibraryFunctionParameter("time", `Time to transition to this weight in seconds. Defaults to 0.2.`, false), new LibraryFunctionParameter("rate", `Playback rate of the animation. Defaults to 1.0.`, false)], false, true, `self SetAnimRestart( %precombatrun1, 1, 0.1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimTime", `Get the animation time for the given animation.`, "entity", [new LibraryFunctionParameter("animation", `animation to manipulate`, true)], true, false, `if ( (self GetAnimTime( %walk_and_run_loops ) ) < 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAnimTimeByName", `Set the animation normalized time for the given animation.`, "entity", [new LibraryFunctionParameter("animation", `animation to manipulate`, true), new LibraryFunctionParameter("time", `0->1`, true)], true, false, `self SetAnimTimeByName( "ai_anim_walk",  0.5)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetArchive", `deprecated function, does nothing`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAssassinationEnabled", `Enable or disable assassinations on the AI.  Also turns on/off the can assassinate indicator.`, null, [new LibraryFunctionParameter("flag", `Whether to use infrared material or not (boolean)`, true)], true, false, `quadtank SetAssassinationEnabled( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAttachmentCosmeticVariantIndex", `Set the attachment cosmetic variant index for the weapon`, "weapon", [new LibraryFunctionParameter("weapon", `The weapon full name`, true), new LibraryFunctionParameter("attachment name", `The attachment name of the weapon`, true), new LibraryFunctionParameter("acvi", `The attachment cosmetic variant index`, true)], true, false, `level.weapon_clientscript_cac_model[type] SetAttachmentCosmeticVariantIndex( weaponFullName, level.attachment_names[i], 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAttachmentCosmeticVariantIndexes", `Sets the previously calculated SetAttachmentCosmeticVariantIndexes of the entity. The entity should not be a player`, "entity", [new LibraryFunctionParameter("acvi", `The AttachmentCosmeticVariantIndexes to set`, true)], true, false, `killcamEnt SetAttachmentCosmeticVariantIndexes( acvi )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAttachmentCosmeticVariants", `Set the AttachmentCosmeticVariantIndexes data to be passed in to the weapon`, null, [new LibraryFunctionParameter("weaponname", `the name of the base weapon to return`, true), new LibraryFunctionParameter("attachmentname_1", `the name of the first attachment`, false), new LibraryFunctionParameter("variantindex_1", `the index of the cosmetic variant to use for the first attachment`, false), new LibraryFunctionParameter("attachmentname_2", `the name of the second attachment`, false), new LibraryFunctionParameter("variantindex_2", `the index of the cosmetic variant to use for the second attachment`, false), new LibraryFunctionParameter("attachmentname_3", `the name of the third attachment`, false), new LibraryFunctionParameter("variantindex_3", `the index of the cosmetic variant to use for the third attachment`, false), new LibraryFunctionParameter("attachmentname_4", `the name of the fourth attachment`, false), new LibraryFunctionParameter("variantindex_4", `the index of the cosmetic variant to use for the fourth attachment`, false), new LibraryFunctionParameter("attachmentname_5", `the name of the fifth attachment`, false), new LibraryFunctionParameter("variantindex_5", `the index of the cosmetic variant to use for the fifth attachment`, false), new LibraryFunctionParameter("attachmentname_6", `the name of the sixth attachment`, false), new LibraryFunctionParameter("variantindex_6", `the index of the cosmetic variant to use for the sixth attachment`, false), new LibraryFunctionParameter("attachmentname_7", `the name of the seventh attachment`, false), new LibraryFunctionParameter("variantindex_7", `the index of the cosmetic variant to use for the seventh attachment`, false), new LibraryFunctionParameter("attachmentname_8", `the name of the eighth attachment`, false), new LibraryFunctionParameter("variantindex_8", `the index of the cosmetic variant to use for the eighth attachment`, false)], true, false, `SetAttachmentCosmeticVariants( "mp7_mp", "acog", 2, "grip", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAvoidanceMask", `Set the avoidance mask of this Havok character.`, "entity", [new LibraryFunctionParameter("Mask", `(const string) Mask must be 'avoid all', 'avoid none', 'avoid actor', 'avoid ai'(actors+vehicles), 'avoid player', or 'avoid vehicle'`, true)], true, false, `randEnemy SetAvoidanceMask("avoid none")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAvoidanceProperty", `Set the avoidance properties of this Havok character.`, "entity", [new LibraryFunctionParameter("Property", `(const string) Property must be 'collision penalty' or 'dodge penalty'`, true), new LibraryFunctionParameter("Value", `(float) The value to set the property to`, true)], true, false, `randAlly SetAvoidanceProperty("collision penalty", 0.1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBallPassAllowed", `Enables or disables ball passing for the given player.`, null, [], true, false, `player SetBallPassAllowed( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBeastModeIconMaterial", `sets the material used by beast mode icons`, null, [new LibraryFunctionParameter("iconid", `1 melee 2 electricity 3 grapple`, true), new LibraryFunctionParameter("materialname", `material name`, true)], false, true, `SetBeastModeIconMaterial( 1, "cool_icon_1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBGBCost", `Sets the current BGB cost`, null, [new LibraryFunctionParameter("local client num", `The local client num`, true), new LibraryFunctionParameter("cost", `The cost of a BGB`, true)], false, true, `SetBGBCost( 115935 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBlur", `Blur the screen over a period of time.`, "entity", [new LibraryFunctionParameter("target_blur", `The final blur. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.`, true), new LibraryFunctionParameter("time", `Time in seconds`, true)], true, false, `setblur( 10.3, 3.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBlurByLocalClientNum", `Sets the blur for the local client given`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("blurFinalValue", `The blur value (must be positive)`, true), new LibraryFunctionParameter("blurTime", `The time to blur (must be positive)`, true)], false, true, `SetBlurByLocalClientNum( localClientNum, curr_info.magnitude, curr_info.transition_in )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBodyRenderOptions", `Sets the entity body, helmet and head render options.`, "entity", [new LibraryFunctionParameter("bodyRenderOptions", `The packed body render options - calculated with GetHeroBodyRenderOptions`, true), new LibraryFunctionParameter("helmetRenderOptions", `The packed helmet render options - calculated with GetHeroHelmetRenderOptions`, true), new LibraryFunctionParameter("headRenderOptions", `The packed head render options - calculated with GetHeroHeadRenderOptions`, true)], true, false, `heroModel SetBodyRenderOptions( bodyRenderOptions, helmetRenderOptions, headRenderOptions )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBodyRenderOptionsPacked", `Sets the packed value of body render options (body type, style, colors)`, "entity", [new LibraryFunctionParameter("value", `Usually returned value from GetBodyRenderOptionsPacked()`, true)], false, true, `gibEntity SetBodyRenderOptionsPacked( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBombTimer", `Bomb timer set in the match state`, null, [new LibraryFunctionParameter("flag bit", `The flag bit to change`, true), new LibraryFunctionParameter("value", `The new value of the bit`, true)], true, false, `SetBombTimer( "A", 50000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBurn", `Set the entity burning for the given time`, "entity", [new LibraryFunctionParameter("time", `Time to burn for ( greater than 0 )`, true)], true, false, `self SetBurn( 3.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeActive", `Sets the state of a player's camera spike.`, "player", [new LibraryFunctionParameter("toggle", `0 for off, 1 for on`, true)], true, false, `player SetCameraSpikeActive( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCanDamage", `Set the candamage flag for this entity - this means that it can respond to notifies from bullets and grenade hits`, "script_model, script_origin or script_brushmodel", [new LibraryFunctionParameter("can damage", `The can damage flag`, true)], true, false, `self SetCanDamage( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClearanceCeiling", `Sets a new clearance ceiling. If the value is larger than the current ceiling, cut faces will be invalidated.`, null, [], true, false, `SetClearanceCeiling( 15.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientNameMode", `alters the way that the player name is updated, to prevent cheating by spectators altering their name to communicate with active players.`, null, [new LibraryFunctionParameter("name mode", `either 'auto_change' or 'manual_change'`, true)], true, false, `SetClientNameMode( "auto_change" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClone", `Sets the contents for the clone.`, "entity", [], true, false, `clone SetClone()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCompassIcon", `Sets the icon to be shown on the minimap`, "entity", [new LibraryFunctionParameter("iconName", `Name of compass material`, true)], false, true, `plane setCompassIcon(iconName)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetContents", `Sets contents of the entity to the given content`, "entity", [new LibraryFunctionParameter("content", `The content to set for the entity`, true)], true, false, `reconModel SetContents( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCorpseGibState", `Sets the gib state for the body rendering.`, "entity", [new LibraryFunctionParameter("leg state", `0 - 3 state: 0 is no gib, 1 right, 2 left, 3 both`, true), new LibraryFunctionParameter("arm state", `0 - 3 state: 0 is no gib, 1 right, 2 left, 3 both`, true)], false, true, `corpse SetCorpseGibState( leg_state, arm_state )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCullDist", `Set the cull distance for a level`, null, [new LibraryFunctionParameter("cull distance", `The cull distance`, true)], true, false, `SetCullDist( 7200 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCursorHint", `Attach a cursor hint to the entity.`, "entity", [], true, false, `self setCursorHint( cursor_hint, cursor_hint_weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDamageDirectionIndicator", `Use the armor version of the hit indicator`, null, [new LibraryFunctionParameter("indicator", `0 = regular, 1 = armor`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDangerous", `Set this node to be a dangerous node for a particular team. works only on pathnodes. `, "pathnode", [new LibraryFunctionParameter("team", `Name of the team.`, true), new LibraryFunctionParameter("flag", `True if dangerous. False otherwise`, true)], true, false, `self SetDangerous( self.team, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDedicatedShadow", `Enabled or Disables dedicated shadow for a model`, "entity", [new LibraryFunctionParameter("flag", `True or False, enabled or disabled`, false)], true, false, `thing SetDedicatedShadow( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDefaultDropPitch", `Set the default drop pitch that the turret attempts to return to when it is not in use.`, "turret", [new LibraryFunctionParameter("pitch", `yaw of the turret (side to side) in degrees.`, true)], true, false, `turret SetDefaultDropPitch( -90 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDemoIntermissionPoint", `Sets the intermission point for the demos.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `setDemoIntermissionPoint( spawnpoint.origin, spawnpoint.angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDepthOfField", `Set the Depth of Field.`, "entity", [new LibraryFunctionParameter("nearStart", `Near start (should be greater than 0)`, true), new LibraryFunctionParameter("nearEnd", `Near end (should be greater than 0)`, true), new LibraryFunctionParameter("farStart", `Far start (should be greater than 0)`, true), new LibraryFunctionParameter("farEnd", `Far end (should be greater than 0)`, true), new LibraryFunctionParameter("nearBlur", `Near blur`, true), new LibraryFunctionParameter("farBlur", `Far blur`, true)], true, false, `self SetDepthOfField( 0, 0, 512, 4000, 4, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDoubleJumpEnergy", `Sets a double jump energy amount on the player`, "player", [new LibraryFunctionParameter("energy", `% energy to set on the player`, true)], true, false, `player SetDoubleJumpEnergy( <energy> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDrawInfrared", `Draw this entity using infrared material when using infrared scope.`, null, [new LibraryFunctionParameter("flag", `Whether to use infrared material or not (boolean)`, true)], true, false, `helicopter SetDrawInfrared( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDrawName", `Sets the drawnname of client ent`, "entity", [new LibraryFunctionParameter("text", `The name.`, true), new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `dude SetDrawName( "dJVahn" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDrawOwnerName", `Draws the entity's owners name above the entity.`, "entity", [new LibraryFunctionParameter("bool", `Enable/Disable using the owners name.`, true), new LibraryFunctionParameter("bool", `Whether to always draw the name rega`, false)], false, true, `entity SetDrawOwnerName( true, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDvar", `Sets the value of a dvar.`, null, [new LibraryFunctionParameter("dvar", `The dvar name as a string.`, true), new LibraryFunctionParameter("value", `The dvar value.`, true)], true, false, `SetDvar( "r_eyesAdjust", "1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDynEntBodyRenderOptionsPacked", `Sets the packed value of body render options (body type, style, colors)`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("packed render options", `Usually returned value from GetBodyRenderOptionsPacked()`, true)], false, true, `SetDynEntBodyRenderOptionsPacked( gibEntity, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDynEntEnabled", `Set this dyn ent to enabled or disabled.  Disabled stops the physics and hides the dyn ent.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("enabled", `1 if dynent is enabled, 0 otherwise`, false)], false, true, `SetDynEntEnabled( brick, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetElectrified", `Electrify the entity for the given time`, "entity", [new LibraryFunctionParameter("time", `Time to get electrified for ( greater than 0 )`, true)], true, false, `self SetElectrified( 3.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEMPJammed", `Sets whether a player/client is affected by EMP`, null, [new LibraryFunctionParameter("isJammed", `Whether the player should be jammed or not. ( boolean )`, true)], true, false, `player SetEMPJammed( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEnableNode", `Disables or enabled this node.`, null, [new LibraryFunctionParameter("node", `the node to enable/disable`, true), new LibraryFunctionParameter("truefalse", `whether it should be enabled`, false)], true, false, `SetEnableNode( node, false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEnemyGlobalScrambler", `Set to true if there is a global enemy scrambler active`, "player", [new LibraryFunctionParameter("bool", `true if there is a scrabler active, false otherwise`, true)], false, true, `player SetEnemyGlobalScrambler( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEnemyModel", `Sets the model of the actor that actors enemies will see to the given model name`, "actor", [new LibraryFunctionParameter("model name", `The name of the model to set this actor to`, true)], true, false, `dog SetEnemyModel( "german_shepard_black" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEnemyScramblerAmount", `Sets the amount alpha of the scrambler applied to the compass`, "player", [new LibraryFunctionParameter("float", `Between 0.0 and 1.0`, true)], false, true, `player SetEnemyScramblerAmount( 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntBeastModeIconType", `sets the beast mode icon shown for a particular entity`, null, [new LibraryFunctionParameter("iconid", `1 melee 2 electricity 3 grapple`, true), new LibraryFunctionParameter("location", `icon location`, false)], false, true, `object SetBeastModeIconMaterial( 2, object.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntGravityTrajectory", `Sets the gravity trajectory type for the entity.`, "player", [new LibraryFunctionParameter("trajectory", `0 = TR_GRAVITY, 1 = TR_MOON_GRAVITY`, true)], true, false, `player SetEntGravityTrajectory( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntityAnimRate", `set the entity animation rate - ZOMBIES ONLY`, "entity", [new LibraryFunctionParameter("rate", `animation rate`, true)], true, false, `self SetEntityAnimRate( 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntityPaused", `Sets whether a given entity will advance normally.`, "entity", [new LibraryFunctionParameter("ignore", `Whether or not to advance normally.`, true)], true, false, `ent SetEntityPaused( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntityWeapon", `Set weapon ent field from script.`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `ent SetEntityWeapon( "kniferang_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExcludeTeamForTrigger", `Set the team that this trigger will not react to. Reacts to all other teams.`, "trigger", [new LibraryFunctionParameter("team name", `The name of the team that the trigger will not respond to. Must be either 'axis', 'allies', 'team3', 'team4', 'team5', 'team6' or 'none'`, true)], true, false, `self SetExcludeTeamForTrigger( game["attackers"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExpFog", `Creates an exponential fog.`, null, [new LibraryFunctionParameter("startDist", `The distance, in world units, at which the fog begins.`, true), new LibraryFunctionParameter("halfwayDist", `The distance, beyond the startDist, at which the scene will be 50% fogged.`, true), new LibraryFunctionParameter("red", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("green", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("blue", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("transition time", `transition time in seconds`, true)], true, false, `SetExpFog(.0001144, 131/255, 116/255, 71/255, 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFakeFire", `Simulates gun fire.  Sound and radar blip.`, null, [], true, false, `entity SetFakeFire( <enabled> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFlagAsAway", `Sets a flag as away/home.`, "flag", [new LibraryFunctionParameter("localClientNum", `Local client number`, true), new LibraryFunctionParameter("away", `A value of 1 sets the flag as away, 0 sets the flag as home`, true)], false, true, `flag SetFlagAsAway( localClientNum, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetForceNoCull", `Sets the force-no-cull flag. Entity will not be culled by portals`, "entity", [], true, false, `helicopter SetForceNoCull()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetForceNotSimple", `Set the forceNotSimple flag on the entity`, "entity", [], false, true, `self SetForceNotSimple()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFOVForKillcam", `Sets the fov for use with this killcam entity.  Setting it to zero makes it use the default fov.`, "entity", [new LibraryFunctionParameter("fov", `The fov you want to use for the killcam`, true)], true, false, `killCamEnt SetFOVForKillcam( 25 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFriendlyNameDraw", `turns on or off local client friendly name drawing`, null, [new LibraryFunctionParameter("onOff", `True if friendly name drawing is turned on`, true)], false, true, `SetFriendlyNameDraw( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFriendlyScramblerAmount", `Sets the amount alpha of the friendly scrambler applied`, "player", [new LibraryFunctionParameter("float", `Between 0.0 and 1.0`, true)], false, true, `player SetFriendlyScramblerAmount( 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGameEndTime", `Sets the time the current match will end`, null, [new LibraryFunctionParameter("time", `The time to set`, true)], true, false, `setGameEndTime( getTime() + int(timeLeft) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGametypeSetting", `Sets the value of a gametype setting.`, null, [new LibraryFunctionParameter("setting", `The setting name as a string.`, true), new LibraryFunctionParameter("value", `The new value for the setting.`, true)], true, false, `SetGametypeSetting( "timeLimit", 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGlobalFutz", `Sets the global futz`, null, [new LibraryFunctionParameter("name", `The Futz name`, true)], false, true, `SetGlobalFutz( futz_name )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGrapplableType", `Set how an entity is grappled.`, null, [], true, false, `platform SetGrapplableType( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGravity", `sets the gravity in inches per second per second.`, null, [new LibraryFunctionParameter("gravity", `The gravity to set`, true)], true, false, `SetGravity( 800 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGroupSnapshot", `Sets the group snapshot`, null, [new LibraryFunctionParameter("name", `Name of the snapshot`, true)], false, true, `SetGroupSnapshot( level._sndActiveSnapshot )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHealthSnapshot", `Sets the health snapshot`, null, [new LibraryFunctionParameter("name", `The snapshot name`, true), new LibraryFunctionParameter("amount", `The amount`, true)], false, true, `SetHealthSnapshot( sn_name, sn_amount )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHideonClientWhenScriptedAnimCompleted", `hides the entity on the client side onces its scripted animation ends`, null, [new LibraryFunctionParameter("entity", `An entity`, true)], true, false, `SetHideonClientWhenScriptedAnimCompleted( ent )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHideWhenScriptedAnimationCompleted", `When playing a scene this will hide the entity when the scripted animation ends on it.`, "entity", [], false, true, `entity SetHideWhenScriptedAnimationCompleted()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHighDetail", `Enabled or Disables High Detail rendering for a model`, "entity", [new LibraryFunctionParameter("flag", `True or False, enabled or disabled`, false)], true, false, `thing SetHighDetail( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHintLowPriority", `Sets this as a low priority hint which is lower priority then everything other then turrets and dropped weapons`, null, [new LibraryFunctionParameter("bool", `True\False if its on or off`, true)], true, false, `m_e_hack_trigger SetHintLowPriority( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHintString", `Set the hint string for the entity`, "entity", [new LibraryFunctionParameter("hint string", `The hint string that will be displayed to the player`, true), new LibraryFunctionParameter("...", `Additional arguments may be appended to the hint string`, false)], true, false, `t_door SetHintString( "Press and Hold ^3[{+activate}]^7 to transmit unlock code" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHintStringForPerk", `Shows this hint string to the player if the player has the specified perk`, null, [new LibraryFunctionParameter("perk", `The perk that the player needs to have to see this hint string`, true), new LibraryFunctionParameter("hint string", `The hint string that will be displayed to the player that has the perk`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHintStringForPlayer", `Sets the trigger hint string for one specific player`, null, [new LibraryFunctionParameter("player", `The player that will see the hint string`, true), new LibraryFunctionParameter("hint string", `The hint string that will be displayed to the player`, true), new LibraryFunctionParameter("...", `Additional arguments may be appended to the hint string in the same way as SetHintString.`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetIgnoreEntForTrigger", `Ignores this entity when doing trigger sight traces. Currently only works for trigger_radius_use`, "trigger", [new LibraryFunctionParameter("entity to ignore", `The entity that will be ignored during sight trace checks`, true)], true, false, `self SetIgnoreEntForTrigger( camera_spike_ent )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetIgnorePauseWorld", `Sets whether a given entity will advance normally when the world is paused.`, "entity", [new LibraryFunctionParameter("ignore", `Whether or not to advance normally when the world is paused.`, true)], true, false, `ent SetIgnorePauseWorld( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetIncludeMeshes", `Sets a streamer hint entity to include mesh data`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `self setIncludeMeshes( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInfluenceAt", `Sets the influence value on the influence map, returns true/false if the value was set.`, null, [new LibraryFunctionParameter("influenceMapIndex", `Index of the influence map`, true), new LibraryFunctionParameter("origin", `The location to set the influence value`, true), new LibraryFunctionParameter("influence", `The influence value to set`, true)], true, false, `SetInfluenceAt(influenceMapIndex, origin, influence)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInfluencerTeamMask", `Sets the team mask for the given influencer`, null, [new LibraryFunctionParameter("influencer id", `The influencer id`, true), new LibraryFunctionParameter("team mask", `The team mask to apply`, true)], true, false, `SetInfluencerTeamMask( influencer_id, team_mask )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInfluencerTimeout", `Sets the timeout for the influencer in seconds from current time`, null, [new LibraryFunctionParameter("influencer id", `The influencer id`, true), new LibraryFunctionParameter("time", `The timeout for the influencer`, true)], true, false, `SetInfluencerTimeout( influencer_id, 2.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInfraredVision", `Switches using the infrared vision (infrared visionset and thermal characters)`, "player", [new LibraryFunctionParameter("is infrared vision", `Whether using infrared vision`, true)], true, false, `player SetInfraredVision( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInfraredVisionSet", `Set the vision when using infrared`, "entity", [new LibraryFunctionParameter("visionNameInfrared", `name of the vision set`, true)], false, true, `entity SetInfraredVisionSet("visionName")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInitialPlayersConnected", `Set initialPlayersConnected bool in match state to true`, null, [], true, false, `SetInitialPlayersConnected()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setInTacticalHud", `Sets if the player has the tactical hud open`, null, [new LibraryFunctionParameter("onOff", `false = off, true = on`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInvisibleToAll", `Set entity invisible to all players`, "entity", [], true, false, `use_trigger SetInvisibleToAll()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInvisibleToPlayer", `Make the entity invisible to the player`, null, [new LibraryFunctionParameter("player", `The player to set the entity invisible to.`, true), new LibraryFunctionParameter("setInvisible", `True if entity has to be invisible to player. False otherwise`, false)], true, false, `hackable._trigger SetInvisibleToPlayer( player, false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetJumpHeight", `Set the global jump height of all players.  Minimum value of 0, maximum value of 1023.`, null, [new LibraryFunctionParameter("height_in_inches", `The height to jump in inches`, true)], true, false, `SetJumpHeight( 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLevelFadeSnapshot", `Sets the level fade snapshot`, null, [new LibraryFunctionParameter("name", `The snapshot name`, true), new LibraryFunctionParameter("amount", `The level fade amount`, true)], false, true, `SetLevelFadeSnapshot( sn_name, sn_amount )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightColor", `Sets the current color of the light, as an RGB vector.`, "light", [new LibraryFunctionParameter("color", `An RGB vector with components in the range 0 to 1. The given values get rounded before they are stored. (vector3)`, true)], true, false, `self SetLightColor( (0.5, 0.75, 1.0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightExponent", `Sets the current exponent of the light.`, "light", [new LibraryFunctionParameter("exponent", `A new value for the exponent of the light. This should be an integer in the range of 0 to 100. (integer)`, true)], true, false, `self SetLightExponent( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightFovRange", `Sets the current fov range of the light.`, "light", [new LibraryFunctionParameter("fov_outer", `A new value for the outer FOV of the light, in degrees. This cannot be larger than the fov when the map was compiled, or less than 1. (float)`, true), new LibraryFunctionParameter("fov_inner", `A new value for the inner FOV of the light, in degrees. This cannot be larger than fov_outer, or less than 0. If not specified, the map value is used. (float)`, false)], true, false, `self SetLightFovRange( 200, 50 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightingOnly", `Sets a streamer hint entity to only hint lighting data`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `self SetLightingOnly( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightingState", `Changes lighting state for the map`, null, [new LibraryFunctionParameter("new light state", `new state to change to. Lighting state defaults to 1 at start of game`, true)], true, false, `SetLightingState( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightIntensity", `Sets the current intensity of the light.`, "light", [new LibraryFunctionParameter("intensity", `A new value for the intensity of the light. 1 is fullbright, but values can be larger than 1. (float)`, true)], true, false, `self SetLightIntensity( 1.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLightRadius", `Sets the current radius of the light.`, "light", [new LibraryFunctionParameter("radius", `A new value for the radius of the light. This cannot be larger than the radius when the map was compiled. (float)`, true)], true, false, `self SetLightRadius( 200 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLocalRadarEnabled", `Sets whether a client's local radar is enabled.`, null, [new LibraryFunctionParameter("localClientNum", `Client number to set local radar on`, true), new LibraryFunctionParameter("enabled", `0 if disabled, 1 if enabled`, true)], false, true, `SetLocalRadarEnabled( localClientNum, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLocalRadarPosition", `Sets the position of a client's local radar.`, null, [new LibraryFunctionParameter("localClientNum", `Client number to set local radar position on`, true), new LibraryFunctionParameter("position", `New position of the local radar`, true)], false, true, `SetLocalRadarPosition( localClientNum, self.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLoopState", `set pitch and volume per entity/alias`, null, [new LibraryFunctionParameter("aliasname", `The sound alias to play`, true), new LibraryFunctionParameter("attenuation", `The desired volume attenuation`, true), new LibraryFunctionParameter("pitch", `The desired pitch`, true), new LibraryFunctionParameter("attenuation_rate", `The desired attenuation rate`, false), new LibraryFunctionParameter("pitch_rate", `The desired pitch rate`, false)], false, true, `car SetLoopState( "peugeot_idle_low", 0.5, 1.0, 0.5, 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMapCenter", `Set the center of the map (used by the network code to optimize position data)`, null, [new LibraryFunctionParameter("mapCenter", `The map center`, true)], true, false, `SetMapCenter( level.mapCenter )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMapLatLong", `Sets the map's real world latitude & longitude and their corresponding map coordinates.`, null, [new LibraryFunctionParameter("mapX", `map X coordinate for which the longitude is given`, true), new LibraryFunctionParameter("mapY", `map Y coordinate for which the longitude is given`, true), new LibraryFunctionParameter("longitude", `world longitude of the given map position`, true), new LibraryFunctionParameter("latitude", `world latitude of the given map position`, true)], false, true, `SetMapLatLong( 1000, 500, -118.448689, 34.021566 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMatchFlag", `Flags a bit in the match state`, "player", [new LibraryFunctionParameter("flag bit", `The flag bit to change`, true), new LibraryFunctionParameter("value", `The new value of the bit`, true)], true, false, `SetMatchFlag( "bomb_timer", "1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMatchTalkFlag", `Flags a bit in the match talk state`, null, [new LibraryFunctionParameter("flag bit", `The flag bit to change`, true), new LibraryFunctionParameter("value", `The new value of the bit`, true)], true, false, `SetMatchTalkFlag( "DeadChatWithDead", "1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMaterialOverride", `Set the material override`, "entity", [new LibraryFunctionParameter("surfaceName", `The new material`, true)], false, true, `self SetMaterialOverride("water")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetmaxHealth", `Sets the max health of this entity`, "entity", [new LibraryFunctionParameter("health", `The new max health`, true)], true, false, `self SetMaxHealth( required_amount )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMiniMap", `Sets the minimap bounds and material`, null, [new LibraryFunctionParameter("material", `Sets the material`, true), new LibraryFunctionParameter("upperLeftX", `Upper left X value`, true), new LibraryFunctionParameter("upperLeftY", `Upper left Y value`, true), new LibraryFunctionParameter("lowerRightX", `Lower right X value`, true), new LibraryFunctionParameter("lowerRightY", `Lower right Y value`, true)], true, false, `setMiniMap(material, northwest[0], northwest[1], southeast[0], southeast[1])`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMissileBrake", `Tells a remote missile to disable brake`, "missile", [new LibraryFunctionParameter("flag", `True to enable or disable missile brake.`, true)], true, false, `missile DisableMissileBrake( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMissileCoasting", `Tells a remote missile to start coasting at a reduced speed.`, "missile", [new LibraryFunctionParameter("flag", `True to start coasting at reduced speed.`, true)], true, false, `missile SetMissileCoasting( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMissileOwner", `Sets the missile entity owner.`, "missile", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `grenade SetMissileOwner( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMode", `Set the mode of a turret.`, "turret", [new LibraryFunctionParameter("mode", `The turret mode. Possible modes are "auto_ai", "manual", "manual_ai" and "auto_nonai`, true)], true, false, `turret SetMode( "auto_ai" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetModel", `Set the model for the entity`, "entity", [new LibraryFunctionParameter("model alias", `Name of the model`, true)], true, false, `raps_meteor SetModel( "veh_t7_drone_raps" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMoveSpeedScale", `Sets the speed scale multiplier for the entity`, "entity", [new LibraryFunctionParameter("speed scale multiplier", `The speed scale multiplier (float)`, true)], true, false, `self SetMoveSpeedScale( HOLDING_CRATE_MOVEMENT_SPEED )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMovingPlatformEnabled", `Enbles the moving platfrom.`, null, [], true, false, `platform SetMovingPlatformEnabled( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNearestEnemyScrambler", `Set the nearest enemy scrambler`, "player", [new LibraryFunctionParameter("cent", `scrambler centity`, true)], false, true, `player AddEnemyScrambler( scrambler )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNemesisXUID", `Sets the Nemesis XUID`, null, [new LibraryFunctionParameter("nemesisXuidString", `The Nemesis XUID string`, true)], true, false, `player setNemesisXuid( player.pers["nemesis_xuid"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNodePriority", `Enable or disable the priority for this node.`, null, [new LibraryFunctionParameter("node", `(node) A priority allowed node.`, true), new LibraryFunctionParameter("enable", `(boolean) True if this node is enabled.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNormalHealth", `Set health of entity. Input health is normalized.`, "entity", [new LibraryFunctionParameter("normal health", `Health in normalized form. Range 0 - 1`, true)], true, false, `self SetNormalHealth( 0.8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNoSunShadow", `Sets the no-sunshadow flag.`, "entity", [], true, false, `helicopter SetNoSunShadow()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetObjectivePointStatus", `Objective status set in the match state`, null, [new LibraryFunctionParameter("objective_index", `The objective index in the matchstate`, true), new LibraryFunctionParameter("team", `The team of the objective`, true), new LibraryFunctionParameter("percent", `Percentage completed`, true)], true, false, `SetObjectivePointStatus( 1, "allies", 80 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOnTargetAngle", `Set the angle range at which the turret_on_target notify will occur.`, "turret_or_vehicle", [new LibraryFunctionParameter("angle", `In degrees (float)`, true), new LibraryFunctionParameter("gunnerIndex", `Which gun, 0-3.`, false)], true, false, `boat SetOnTargetAngle( 0, 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOwner", `Sets the entity owner.`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `grenade SetOwner( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPauseWorld", `pauses playback of animations and effects, but doesn't affect the server tick the way slomo does`, null, [new LibraryFunctionParameter("pause", `Whether or not to pause the world`, true)], true, false, `SetPauseWorld( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPerkForTrigger", `Set the perk that the player must have for this trigger will react to`, "trigger", [new LibraryFunctionParameter("perk name", `The name of the perk that the trigger will respond to.`, true)], true, false, `self SetPerkForTrigger( "specialty_fastinteract" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerCollision", `Use to turn on off the collision with the player.`, "entity", [new LibraryFunctionParameter("on_off", `True for on and false for off`, true)], true, false, `self SetPlayerCollision( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerCurrentObjective", `Sets the current objective information on the player`, "player", [new LibraryFunctionParameter("objective_index", `The objective index in the matchstate`, true), new LibraryFunctionParameter("objective_type", `Type of the objective`, true)], true, false, `SetPlayerCurrentObjective( "flag_a", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerCurrentStreak", `Sets the current kill streak count on the player`, "player", [new LibraryFunctionParameter("current streak", `The current kill streak count`, true)], true, false, `SetPlayerCurrentStreak( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerGravity", `Sets the gravity override value for the player.`, "player", [new LibraryFunctionParameter("gravity", `The gravity to set`, true)], true, false, `player SetPlayerGravity( 600 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerIgnoreRadiusDamage", `Set the player to take or ignore radius damage`, null, [new LibraryFunctionParameter("flag", `true to ignore radius damage, false otherwise`, true)], true, false, `SetPlayerIgnoreRadiusDamage( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerSpread", `Sets the spread of this turret when used by the player`, "turret", [new LibraryFunctionParameter("spread", `The spread of the turret in degrees`, true)], true, false, `roof_turret SetPlayerSpread( 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerStateLoadoutBonusCards", `Set the player state to have bonus card info, for codcaster to view it`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true)], true, false, `self SetPlayerStateLoadoutBonusCards( class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerStateLoadoutWeapons", `Set the player state to have primary and secondary weapon info, for codcaster to view it`, "player", [new LibraryFunctionParameter("custom Class", `Class Num`, true)], true, false, `self SetPlayerStateLoadoutWeapons( class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRenderInThirdPersonSpectate", `render the entity when spectated in 3rd person.`, null, [new LibraryFunctionParameter("enable", `Enable or disable redering the entity in 3rd person`, true)], false, true, `SetRenderInThirdPersonSpectate( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetReviveHintString", `Set the revive hint string to show to all or to a team.`, null, [new LibraryFunctionParameter("hint string", `The hint string that will be displayed to the player that has the perk`, true), new LibraryFunctionParameter("team", `The team to show the hint to`, false)], true, false, `self.revivetrigger setReviveHintString( &"GAME_BUTTON_TO_REVIVE_PLAYER", self.team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRoundsPlayed", `Set rounds played in match state`, null, [new LibraryFunctionParameter("value", `The number of rounds played`, true)], true, false, `SetRoundsPlayed( game["roundsplayed"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSAnim", `Set the anim shot to play on a static model`, "entity", [new LibraryFunctionParameter("string anim name", `name of a SANIM asset`, true), new LibraryFunctionParameter("string shot name", `shot name of the sub animation to play, pass in <int> 0 to play the first one.`, false), new LibraryFunctionParameter("float time", `frame to start playing on, default is 0.`, false)], false, true, `thing SetSAnim( anim, shot, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetScale", `Set the model scale on a script mover.`, "entity", [new LibraryFunctionParameter("scale", `The scale factor. (float)`, true)], true, false, `entity SetScale(2.0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetScanningPitch", `Set the pitch that the turret attempts to use while scanning for enemies.`, "turret", [new LibraryFunctionParameter("pitch", `of the turret (up and down) in degrees.`, true)], true, false, `turret SetScanningPitch( -45 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetScoreboardColumns", `Set the scoreboard columns.`, null, [new LibraryFunctionParameter("column1", `to <column5>`, true), new LibraryFunctionParameter("...", `More columns if needed.`, false)], true, false, `SetScoreboardColumns( "score", "kills", "deaths", "kdratio", "assists" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetScriptMoverFlag", `Sets flag 0-7 on the script mover ent.`, "non_player_entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `some_script_model SetScriptMoverFlag( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetScriptStreamBias", `Sets the base importance of materials being forced from script`, null, [new LibraryFunctionParameter("bias", `Streaming bias (0 is the highest importance)`, true)], false, true, `setScriptStreamBias( 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSessStat", `Sets the indicated stat`, "player", [new LibraryFunctionParameter("stat path", `The path to the stat to set the value for.`, true)], true, false, `self SetSessStat( "byteStat", 0, 12 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setshaderconstant", `Set the value of a previously-mapped shader constant`, null, [new LibraryFunctionParameter("localClientNum", `Local client for which to set the shader constant`, true), new LibraryFunctionParameter("index", `An 0-based index that refers to a previously-mapped shader constant(see MapShaderConstant)`, true), new LibraryFunctionParameter("x", `A float value, x component of the shader constant`, true), new LibraryFunctionParameter("y", `A float value, y component of the shader constant`, true), new LibraryFunctionParameter("z", `A float value, z component of the shader constant`, true), new LibraryFunctionParameter("w", `A float value, w component of the shader constant`, true)], false, true, `ent setshaderconstant( 0, "shaderColor" , 0, 0, 0, 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSharedViewPort", `Sets the view mode to either shared or independent, shared combines all views into a single shared viewport, modifies the way input is handled, and places the camera into scripted camera mode (i.e. control it with script).`, null, [new LibraryFunctionParameter("mode", `true if shared viewport, false for independent (default splitscreen behavior)`, true)], true, false, `SetSharedViewPort(true)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetShowcaseWeaponPaintshopXUID", `Set the showcase weapon paintshop XUID for the given local client num`, null, [], false, true, `SetShowcaseWeaponPaintshopXUID( localClientNum, xuid )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSkipTos", `Set skip tos`, null, [new LibraryFunctionParameter("skipto", `The skipto name`, true)], true, false, `SetSkiptos( ToLower( skipto ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSlowMotion", `sets the current slow motion timescale interpolation.`, null, [new LibraryFunctionParameter("startTimescale", `The initial timescale.`, true), new LibraryFunctionParameter("endTimescale", `The final timescale. Default to 1.`, false), new LibraryFunctionParameter("deltaTime", `The time to go from start to end timescale. Default to 1. (in seconds)`, false)], true, false, `SetSlowMotion( 1.0, 0.25, 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSModelSAnimShot", `Set the anim shot to play on a static model`, null, [new LibraryFunctionParameter("target name", `target name of the static model or <int index> The index of the static model or <array int indices> The indices of the static models (string)`, true), new LibraryFunctionParameter("shot name", `shot name of the sub animation to play, pass in <int> 0 to play the first one. (string)`, false), new LibraryFunctionParameter("time", `frame to start playing on, pass in -1 to use the static model random frame, this is the default. (float)`, false), new LibraryFunctionParameter("loop", `this is unused, looping is set in the asset editor. (integer)`, false), new LibraryFunctionParameter("append", `If !0 the animation will be played after the current animation(s), any loop flags in current animations are ignored. If 0, it will replace the current and any appended animation with the current one.(integer)`, false), new LibraryFunctionParameter("blend", `If !0 new animation will blend into the new one. default is 0 (integer)`, false), new LibraryFunctionParameter("frames to blend", `If number of frames to blend over (float)`, false)], false, true, `SetSModelSAnimShot("tiny_bot_blend", "", -1, true, false, true, 5*30)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSonarAttachmentEnabled", `Set the sonar attachment to be enabled or disabled`, "entity", [new LibraryFunctionParameter("enable", `true/false`, true)], false, true, `entity SetSonarAttachmentEnabled(false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundContext", `Set the sound context`, null, [new LibraryFunctionParameter("type", `The type of context`, true), new LibraryFunctionParameter("value", `The value for that type`, true)], false, true, `SetSoundContext ("ringoff_plr", "outdoor"); //for weapon decay's`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundEntContext", `Sets the entity sound context`, "entity", [new LibraryFunctionParameter("type", `Sound Context type`, true), new LibraryFunctionParameter("value", `Sound Context value`, true)], false, true, `car SetSoundEntContext("type", "value")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundPitch", `Set the sound pitch`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true), new LibraryFunctionParameter("pitch", `The new pitch`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundPitchRate", `Set the sound pitch rate`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true), new LibraryFunctionParameter("pitchRate", `The new pitch rate`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundVolume", `Set the sound volume`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true), new LibraryFunctionParameter("attenuation", `The attenuation of the sound`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSoundVolumeRate", `Set the sound volume rate`, null, [new LibraryFunctionParameter("playbackId", `The sound id`, true), new LibraryFunctionParameter("attenuationRate", `The new volume rate`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpawnClientFlag", `Set a flag on a client's spawn client data in the spawning system.`, "player", [new LibraryFunctionParameter("flag", `Flag to set`, true)], true, false, `player SetSpawnClientFlag( "SCDFL_DISABLE_LOGGING" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpawnPointRandomVariation", `Random value will be added into the spawn point weighting calculation.`, null, [new LibraryFunctionParameter("variation", `random range will be [0, variation]`, true)], true, false, `SetSpawnPointRandomVariation( 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpawnPointsBaseWeight", `If the spawn point is facing the objective position then it will have an additional score applied`, null, [new LibraryFunctionParameter("team mask", `teams that this command will affect`, true), new LibraryFunctionParameter("objective position", `Position of the objective that will be used in the facing calculations`, true), new LibraryFunctionParameter("angle", `max angle that will be accepted`, true), new LibraryFunctionParameter("score", `additional score that will be applied`, true)], true, false, `SetSpawnPointsBaseWeight( team_mask, point, 30, 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStableMissile", `Set the stable missile flag of the entity`, "entity", [new LibraryFunctionParameter("flag", `Set to true if the stable flag should be set. False otherwise`, true)], true, false, `self SetStableMissile( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStance", `Sets the stance of the player. It only works for the player.`, "player", [new LibraryFunctionParameter("stance", `The stance.  Possible values are 'crouch', 'prone' and 'stand'`, true)], true, false, `player SetStance( "stand" );`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStepTriggerSound", `Set the sound that is triggered by steps`, "entity", [new LibraryFunctionParameter("sound alias", `The sound name`, true)], false, true, `trigPlayer SetStepTriggerSound(self.script_label + suffix)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStowedWeapon", `Sets the stowed weapon for the player`, "entity", [new LibraryFunctionParameter("weaponName", `The weapon name to attach (string).`, true)], true, false, `self SetStowedWeapon( "mp40_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStreamerRequest", `Put a streamer hint asset into a request slot (0-7)`, null, [new LibraryFunctionParameter("slot", `Request slot`, true), new LibraryFunctionParameter("name", `Name of the streamer hint asset`, true)], false, true, `setStreamerRequest(0, "apple_pie")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStunned", `Puts the vehicle or takes the vehicle out of stun mode.  Only works for nitrous vehicles.`, "vehicle", [new LibraryFunctionParameter("stunned", `True/false stun state`, true)], false, true, `vehicle SetStunned( 0, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetEntity", `Sets the target of this turret`, "turret", [new LibraryFunctionParameter("target", `the turret target`, true)], true, false, `roof_turret SetTargetEntity( target )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetOrigin", `Sets the target origin of this turret or vehicle weapon`, "turret_or_vehicle", [new LibraryFunctionParameter("origin", `the turret target origin`, true)], true, false, `roof_turret SetTargetOrigin( origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeam", `Sets the entity team.`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `panzer SetTeam( team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeamForTrigger", `Set the team that this trigger will react to`, "trigger", [new LibraryFunctionParameter("team name", `The name of the team that the trigger will respond to. Must be either 'axis', 'allies', 'team3' or 'none'`, true)], true, false, `self SetTeamForTrigger( game["attackers"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeamReviveIcon", `Set the revive icon used by particular teams`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("material", `The icon to use`, true)], false, true, `SetTeamReviveIcon( "allies", "waypoint_revive_cdc_zm" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeamSatellite", `Sets whether a team has Spyplane or not`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.`, true), new LibraryFunctionParameter("availability", `Whether the team has Satellite; defaults to false`, true)], true, false, `SetTeamSatellite( "allies", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeamScore", `Set a team's score`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either 'axis' or 'allies' or 'team3'.`, true), new LibraryFunctionParameter("score", `The new team score`, true)], true, false, `SetTeamScore( "allies", 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTeamSpyplane", `Sets whether a team has Spyplane or not`, null, [new LibraryFunctionParameter("team", `The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.`, true), new LibraryFunctionParameter("availability", `Whether the team has Spyplane; defaults to false`, true)], true, false, `SetTeamSpyplane( "allies", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetThirdPerson", `Sets the camera mode to third person if true`, null, [new LibraryFunctionParameter("onOff", `set third person mode to this value`, true)], false, true, `SetThirdPerson( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTmodeProvider", `Enables (or disables) the actor to provide tmode traces to the player.`, "entity", [new LibraryFunctionParameter("value", `(int) 1-enable 0-disable`, true)], true, false, `entity SetTmodeProvider( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTopDownCameraYaw", `Set the top down camera yaw that is used in DOA to get the player controls to work correctly in bgpmove.`, null, [new LibraryFunctionParameter("yaw_angle", `The yaw angle to set`, true)], true, false, `SetTopDownCameraYaw( 180 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTopScorer", `Sets the top scorer for the end game screen.`, null, [new LibraryFunctionParameter("index", `position [0..2] of the player`, true), new LibraryFunctionParameter("player", `player who is the top scorer`, true), new LibraryFunctionParameter("taunt", `players selected taunt index`, true), new LibraryFunctionParameter("gesture0", `players selected gesture type 0 index`, true), new LibraryFunctionParameter("gesture1", `players selected gesture type 1 index`, true), new LibraryFunctionParameter("gesture2", `players selected gesture type 2 index`, true), new LibraryFunctionParameter("weapon", `players weapon`, true), new LibraryFunctionParameter("weapon render options", `players weapon renderoptions`, false), new LibraryFunctionParameter("acvi", `players attachment cosmetic variant indexes`, false)], true, false, `SetTopScorer( 0, player, weapon, renderoptions, acvi)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretAccuracy", `Currently does nothing.`, "turret", [], true, false, `roof_turret SetTargetAccuracy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretCarried", `Sets whether a turret is being carried.`, "turret", [new LibraryFunctionParameter("flag", `True if the turret is being carried`, true)], true, false, `turret SetTurretCarried( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretMinimapVisible", `Sets whether a turret is visible on the minimap.`, "entity", [new LibraryFunctionParameter("flag", `True if the turret is visible on the minimap`, true)], true, false, `sentry SetTurretMinimapVisible( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretNode", `Set this turretnode to use this turret.`, null, [new LibraryFunctionParameter("node", `The turret node to connect to the turret`, true), new LibraryFunctionParameter("turret", `The turret to connect to the node`, true)], true, false, `SetTurretNode( node, turret )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretOwner", `Sets the turret entity owner.`, "turret", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `turret SetTurretOwner( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretSpinning", `Set the minigun spin for the turret on this entity. Works for vehicles also.`, "turret", [new LibraryFunctionParameter("onoff", `Turn it on or off (boolean)`, true)], true, false, `roof_turret SetTurretSpinning( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretType", `Sets the turret Type, Sentry or TOW.`, "turret", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `turret SetTurretType( "sentry" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetUnderwaterVisionSet", `Set the vision when underwater`, "entity", [new LibraryFunctionParameter("visionNameUnderwater", `name of the vision set`, true)], false, true, `entity SetUnderwaterVisionSet("visionName")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetupClientFieldAnimSpeedCallbacks", `Registers a code callback for each of the given clientfield names in a field pool.`, null, [], false, true, `SetupClientFieldAnimSpeedCallbacks( "world", 1, "flag_a_owner" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setupclientfieldcodecallbacks", `Registers a LUI code callback for each of the given clientfield names in a field pool.`, null, [], false, true, `SetupClientFieldLuiCodeCallbacks( "world", 1, "flag_a_owner" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetupClientFieldLuiCodeCallbacks", `Registers a LUI code callback for each of the given clientfield names in a field pool.`, null, [], false, true, `SetupClientFieldLuiCodeCallbacks( "world", 1, "flag_a_owner" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetupFieldOpsKitLoadouts", `Sets up all the field ops custom classes (using slots 6 through 9)`, null, [new LibraryFunctionParameter("mapname", `The map to load the field ops kits for`, true)], true, true, `SetupFieldOpsKitLoadouts( mapname )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetViewAngleResistance", `Sets the zones in the player's view cone in which resistance will be applied in the direction of the view limit`, "player", [new LibraryFunctionParameter("right arc", `Angle to resist against the right plane of the view cone.`, true), new LibraryFunctionParameter("left arc", `Angle to resist against the left plane of the view cone.`, true), new LibraryFunctionParameter("top arc", `Angle to resist against the top plane of the view cone.`, true), new LibraryFunctionParameter("bottom arc", `Angle to resist against the bottom plane of the view cone.`, true), new LibraryFunctionParameter("snap to", `false when the resistance will be blended to over time. True by default.`, false)], true, false, `level.player SetViewAngleResistance( 40, 40, 20, 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetViewModelDepthOfField", `Set the view model depth of field of the player`, "player", [new LibraryFunctionParameter("start", `Start DOF ( >= 0 )`, true), new LibraryFunctionParameter("end", `End DOF ( >= 0 )`, true)], true, false, `self SetViewModelDepthOfField(0,1000)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVisibleToAll", `Make the entity visible to all players`, "entity", [], true, false, `trigger SetVisibleToAll()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVisibleToAllExceptTeam", `Set self visible to all teams except the selected teams`, "entity", [new LibraryFunctionParameter("team", `Which to teams not to show this entity too`, true)], true, false, `plane SetVisibleToAllExceptTeam( self.team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVisibleToPlayer", `Make the entity visible to the player`, "entity", [new LibraryFunctionParameter("player", `The player to set the entity visible to.`, true)], true, false, `trigger SetVisibleToPlayer( self )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVisibleToTeam", `Set self visible only to selected team`, "entity", [new LibraryFunctionParameter("team", `Which to show this entity to`, true)], true, false, `plane SetVisibleToSquad( self.team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVisionSetForPlayer", `Specify the server override visionset and the transition time into it.`, null, [new LibraryFunctionParameter("visionset name", `Vision set to transition into (string)`, true), new LibraryFunctionParameter("transition time", `How long, in seconds, to take transitioning to the new vision set if a transition is possible. Default is one second. (float)`, false)], true, false, `player SetVisionSetForPlayer( "mortar_thermal", 1.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVolFog", `Creates an exponential fog.`, null, [new LibraryFunctionParameter("startDist", `The distance, in world units, at which the fog begins.`, true), new LibraryFunctionParameter("halfwayDist", `The distance at which the scene will be 50% fogged.`, true), new LibraryFunctionParameter("halfwayHeight", `The height at which the scene will be 50% fogged.`, true), new LibraryFunctionParameter("baseHeight", `The ground-level Z position at which the fog will start from.`, true), new LibraryFunctionParameter("red", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("green", `The green component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("blue", `The blue component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("transition time", `transition time in seconds`, true), new LibraryFunctionParameter("startDist", `The distance, in world units, at which the fog begins.`, true), new LibraryFunctionParameter("halfwayDist", `The distance at which the scene will be 50% fogged.`, true), new LibraryFunctionParameter("halfwayHeight", `The height at which the scene will be 50% fogged.`, true), new LibraryFunctionParameter("baseHeight", `The ground-level Z position at which the fog will start from.`, true), new LibraryFunctionParameter("red", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("green", `The green component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("blue", `The blue component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("fogColorScale", `The scaler for the colors as a value between 1 and 10000.0`, true), new LibraryFunctionParameter("sunFogRed", `The red component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("sunFogGreen", `The green component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("sunFogBlue", `The blue component of the fog as a value between 0.0 and 1.0`, true), new LibraryFunctionParameter("sunFogDirX", `The X component of the fog direction as a value between -1.0 and 1.0`, true), new LibraryFunctionParameter("sunFogDirY", `The Y component of the fog direction as a value between -1.0 and 1.0`, true), new LibraryFunctionParameter("sunFogDirZ", `The Z component of the fog direction as a value between -1.0 and 1.0`, true), new LibraryFunctionParameter("sunFogStartAng", `The starting angle of the sun fog as a value between 0 and 180`, true), new LibraryFunctionParameter("sunFogEndAng", `The ending angle of the sun fog as a value between 0 and 180`, true), new LibraryFunctionParameter("fog max opacity", `The maximum opacity of the fog as a value between 0 and 1`, true), new LibraryFunctionParameter("transition time", `transition time in seconds`, true)], true, false, `SetVolFog(0.0001144, 0.01, 131/255, 116/255, 71/255, 0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVoteNoCount", `Sets the number of No votes`, null, [new LibraryFunctionParameter("no count", `Number of 'no' votes`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVoteString", `Sets the string for a vote`, null, [new LibraryFunctionParameter("string", `The vote string`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVoteTime", `Sets the start time for a vote`, null, [new LibraryFunctionParameter("time", `The vote time in ms`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVoteYesCount", `Sets the number of Yes votes`, null, [new LibraryFunctionParameter("no count", `Number of 'yes' votes`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWaterDisturbanceParams", `Sets parameters describing the water disturbance created by the (script mover) entity`, "entity", [new LibraryFunctionParameter("force", `The force of the disturbance influences the height and size of the wave`, true), new LibraryFunctionParameter("length", `How long the wave is in the direction of travel`, true), new LibraryFunctionParameter("width", `How wide the wave is (across direction of travel)`, true), new LibraryFunctionParameter("damping", `How much the wave damps the water after it travels; larger values (>1) will cause the wave to leave very little wake, smaller values will leave lots of disturbance behind the wave.  Keep > 0.`, true), new LibraryFunctionParameter("angle", `The angle of the surge line in degrees; 0 -> +X`, true)], false, true, `self SetWaterDisturbanceParams( 0.5, 500, 1500, 0.2, 70 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWaterDrops", `Sets water drops equal to the count`, "player", [new LibraryFunctionParameter("count", `Number of water drops (should be >= 0)`, true)], true, false, `self SetWaterDrops( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWaveWaterEnabled", `Makes a water completely appear or disappear`, null, [new LibraryFunctionParameter("water name", `The name of the water affected, or empty string for all`, true), new LibraryFunctionParameter("enable", `whether water should be visible`, true)], false, true, `SetWaveWaterEnabled( "huge_lake", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWaveWaterGeneratorAmplitude", `Sets the wave water amplitude of the generator.`, null, [new LibraryFunctionParameter("generator name", `The generator name`, true), new LibraryFunctionParameter("amplitude", `The amplitude for the generator`, true)], true, false, `SetWaveWaterGeneratorAmplitude( "exampleGenerator", 1.1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWaveWaterHeight", `Sets the height of one or all waters in a level`, null, [new LibraryFunctionParameter("water name", `The name of the water affected, or empty string for all`, true), new LibraryFunctionParameter("height", `The new height value in world coordinates`, true)], false, true, `SetWaveWaterHeight( "huge_lake", 15.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeapon", `Sets the weapon of the entity. The entity should not be a player`, "entity", [new LibraryFunctionParameter("weapon", `The weapon to set`, true)], true, false, `killcamEnt SetWeapon( self.weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponCosts", `Sets the cost of a weapon for use by prompts`, null, [new LibraryFunctionParameter("local client num", `The local client num`, true), new LibraryFunctionParameter("weapon", `The weapon to add`, true), new LibraryFunctionParameter("weaponCost", `Cost to buy the weapon`, true), new LibraryFunctionParameter("ammoCost", `Cost to buy ammo`, true), new LibraryFunctionParameter("playerAmmoCost", `Cost to buy ammo through secret shopper`, true)], false, true, `SetWeaponCosts( weapon, weapon.cost, weapon.ammoCost, weapon.secretshopperCost )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponOptions", `Sets the previously calculated weapon options of the entity. The entity should not be a player`, "entity", [new LibraryFunctionParameter("weaponOptions", `The weapon options to set`, true)], true, false, `killcamEnt SetWeaponOptions( weapon_options )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponRenderOptions", `Sets the weapon render options in the entity.`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `level.weapon_clientscript_model SetWeaponRenderOptions( level.camo_index, level.reticle_index, level.show_player_tag, level.show_emblem, level.show_paintshop )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWinningPlayer", `Sets a player to be the winner`, null, [new LibraryFunctionParameter("player", `The player to set as the winning player`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWinningTeam", `Sets a team to be the winner`, null, [new LibraryFunctionParameter("team", `The team name of the winning team. Must be 'axis', 'allies' or 'none'`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWorldFogActiveBank", `Sets world fog volumes active bank mask.`, "client", [new LibraryFunctionParameter("bankMask", `Active bank`, true)], true, false, `self setworldfogactivebank(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetZBarrierColModel", `Sets the collision model for a zbarrier.`, "entity", [new LibraryFunctionParameter("model", `The model.`, true)], true, false, `ent SetZBarrierColModel("p6_anim_zm_barricade_board_collision")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetZBarrierPieceState", `Set's the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true), new LibraryFunctionParameter("state", `State to set - valid states are open, opening, closed and closing.`, true), new LibraryFunctionParameter("animation scalar", `Valid range 0.1 - 2.0, changes the playback speed of the animation in the set state - numbers less than 1.0 are faster.`, false)], true, false, `ent SetZBarrierPieceState(1, "open", 0.8)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetZombieName", `Set this actors name`, "actor", [], true, false, `guy SetZombieName( "zombie11" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShellShock", `Start a shell shock sequence for the entity for given duration.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("duration", `duration in seconds. The duration must be between 0 and 60 seconds.`, true), new LibraryFunctionParameter("allowReduceShellShockPerk", `true if shell shock perk should be reduced`, false)], true, false, `self shellShock( "frag_grenade_mp", 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShootTurret", `Shoots a turret`, "turret", [], true, false, `roof_turret ShootTurret()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShootUp", `Gives an entity vertical movement`, null, [new LibraryFunctionParameter("float", `upwards velocity`, true)], true, false, `betty ShootUp( 350 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldDoInitialWeaponRaise", `Set weaponstate to force or prevent first raise animation the next time the player switches to it. Only works if the player currently has it`, "player", [new LibraryFunctionParameter("weapon", `The weapon to set the first raise anim state for`, true), new LibraryFunctionParameter("bool shouldDoRaise", `Whether the weapon should do the initial raise`, true)], true, false, `old_state = self ShouldDoInitialWeaponRaise( "ak47", false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Show", `Show the entity`, "entity", [], true, false, `self Show()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowAllParts", `Show all parts of an entity.`, "entity", [], true, false, `self ShowAllParts()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowInfoVolume", `Enables an info volume to be drawn with the specified color`, null, [new LibraryFunctionParameter("entnum", `The entity number of the info volume`, true), new LibraryFunctionParameter("rgb color", `The rgb color that the info volume will be drawn with`, false), new LibraryFunctionParameter("alpha", `The alpha that the info volume will be drawn with`, false)], true, false, `InfoVolumeDebug_ShowVolume( info_volume GetEntityNumber(), ( 0.2, 0.2, 0.5 ), 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowMiscModels", `Show all misc models with this targetname`, null, [new LibraryFunctionParameter("targetname", `targetname of misc model(s).`, true)], true, false, `ShowMiscModels( "crash_destruct" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowPart", `Show part of an entity.`, "entity", [new LibraryFunctionParameter("tagname", `The tag to show. All surfaces with a vertex weighted to the tag will be shown. (string)`, true), new LibraryFunctionParameter("modelname", `The optional model name to help specify the part location. (string)`, false), new LibraryFunctionParameter("bApplyToChildren", `Optional flag to specify if we should apply the operation to children bones as well. (boolean)`, false)], true, false, `self ShowPart( "tag_weapon", "weapon_saw" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowToPlayer", `Show the entity to a given client`, "entity", [new LibraryFunctionParameter("player", `The player to show the entity to.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowToTeam", `Show the entity to a particular team`, "entity", [new LibraryFunctionParameter("team", `The team to show the entity to.`, true)], true, false, `self ShowToTeam( team )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowZBarrierPiece", `Allows the indexed piece to be drawn.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ShowZBarrierPiece(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SiegeCmd", `Apply a number of anim commands on a siege model`, "entity", [new LibraryFunctionParameter("string cmd", `cmd to execute.`, true), new LibraryFunctionParameter("string cmd", `more cmd's...`, false)], false, true, `thing SiegeCmd( "set_shot", "myshot", "unpause`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SightConeTrace", `Determines how much the entity can be seen from the given position, using the same check that is used by grenades. Performs multiple sight traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.`, "entity", [new LibraryFunctionParameter("sight position", `The point the sight starts at`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore when doing the traces`, false), new LibraryFunctionParameter("cone forward", `The forward direction of the cone, whose base is at the <sight position>.  Must be normalized.`, false), new LibraryFunctionParameter("cone angle", `Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.`, false)], true, false, `tankVisibilityFraction = tank SightConeTrace( player.origin, player, player.angles, 65)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SightTracePassed", `Does a sight trace from start to end. Returns true if doesnt hit anything`, null, [new LibraryFunctionParameter("start", `The bullet start point`, true), new LibraryFunctionParameter("end", `The bullet end point`, true), new LibraryFunctionParameter("hit characters", `An entity to ignore`, true), new LibraryFunctionParameter("ignore entity", `An entity to ignore`, true)], true, false, `passed = SightTracePassed( player.origin + ( 0, 0, 64 ), self.origin + ( 0, 0, 64 ), false, undefined )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SModelAnimCmd", `Apply a number of anim commands on a siege model`, null, [new LibraryFunctionParameter("target", `target name of the static model or <int index> The index of the static model or <array int indices> The indices of the static models (string)`, true), new LibraryFunctionParameter("cmd", `cmd to execute. (string)`, true), new LibraryFunctionParameter("cmd", `more cmd's... (string)`, false)], false, true, `SModelAnimCmd("targetName","pause")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SnapshotAcknowledged", `Returns 1 if all clients have acknowledged the snapshot or the timeout has expired. Otherwise returns undefined.`, null, [new LibraryFunctionParameter("array", `The array returned by GetSnapshotIndexArray.`, true)], true, false, `acked = SnapshotAcknowledged( snapindices )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Solid", `Set the solid flag, so that this object is collidable.`, "ent", [], true, false, `self Solid()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundExists", `Returns true if the given sound exists`, null, [new LibraryFunctionParameter("soundName", `The sound alias`, true)], true, false, `if( SoundExists( soundAlias )) { //do something }`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundGetAlias", `The the string alias of a sound from the hashed sound id. Will return undefined if no sound is found`, null, [new LibraryFunctionParameter("soundId", `the hashed sound id of the alias`, true)], true, false, `soundAlias =  SoundGetAlias( soundId )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundGetPlaybackTime", `Get the playback time for the sound`, null, [new LibraryFunctionParameter("soundName", `The sound alias`, true)], true, false, `playbackTime = SoundGetPlaybackTime( "evt_infection_record_oneshot" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundLineEmitter", `Play a sound from start point to end point`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("origin 1", `start point`, true), new LibraryFunctionParameter("origin 2", `end point`, true)], false, true, `SoundLineEmitter( "wpn_micro_turret_loop", start, end )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundLoopEmitter", `Play a sound loop at the position`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("position", `The position to play sound at`, true)], false, true, `SoundLoopEmitter("evt_beacon_loop_red", self.origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundPlayAutoFX", `This function is used to play audio on createfx ents.`, null, [new LibraryFunctionParameter("fxid", `The ID of the FX you want to play alias off.`, true), new LibraryFunctionParameter("alias", `Audio alias.`, true), new LibraryFunctionParameter("offsetx", `Offset x from effect origin to play the sound.`, false), new LibraryFunctionParameter("offsety", `Offset y from effect origin to play the sound.`, false), new LibraryFunctionParameter("offset", `Offset z from effect origin to play the sound.`, false), new LibraryFunctionParameter("onground", `Do a trace to ground to ensure audio is played above ground.`, false), new LibraryFunctionParameter("area", `If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.`, false), new LibraryFunctionParameter("threshold", `If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.`, false), new LibraryFunctionParameter("alias_override", `If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.`, false)], false, true, `SoundPlayAutoFX( "fx_fire_barrel", "amb_fire_small", 5, -10, 5, false, 20, 5, "amb_fire_large" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundPlaying", `Returns true if the sound given by sound id is playing`, null, [new LibraryFunctionParameter("playbackId", `The sound  id`, true)], false, true, `while( soundplaying( soundId ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundRattle", `Set the rattle sound's origin, min distance and max distance`, null, [new LibraryFunctionParameter("origin", `The position`, true), new LibraryFunctionParameter("minDist", `The min distance to play sound`, true), new LibraryFunctionParameter("maxDist", `The max distance to play sound`, false)], false, true, `soundrattle(origin,min,max)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundRattleSetup", `Play a rattle sound at the position`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("position", `The position to play sound at`, true)], false, true, `SoundRattleSetup(rattles[i].script_sound, rattles[i].origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundSetMusicState", `Set the music state for the sound`, null, [new LibraryFunctionParameter("state id", `The state identifier`, true)], false, true, `SoundSetMusicState( state_id )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundStopLineEmitter", `Stops the sound playing from start point to end point`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("origin 1", `start point`, true), new LibraryFunctionParameter("origin 2", `end point`, true)], false, true, `SoundStopLineEmitter( "wpn_micro_turret_loop", start, end )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundStopLoopEmitter", `Stop the sound loop emitter at the position`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("position", `The position`, true)], false, true, `SoundStopLoopEmitter("evt_beacon_loop_green", self.origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundTimeScale", `Set the sound time scale`, null, [new LibraryFunctionParameter("time", `The new time scale`, true)], false, true, `SoundTimeScale( 1.1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SoundUpdateLineEmitter", `Updates the sound playing from previous start point to previous end point`, null, [new LibraryFunctionParameter("alias", `The sound alias name`, true), new LibraryFunctionParameter("previous origin 1", `start point`, true), new LibraryFunctionParameter("previous origin 2", `end point`, true), new LibraryFunctionParameter("origin 1", `start point`, true), new LibraryFunctionParameter("origin 2", `end point`, true)], false, true, `SoundUpdateLineEmitter( "wpn_micro_turret_loop", previousStart, previousEnd, start, end )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Spawn", `Spawn an entity.`, null, [new LibraryFunctionParameter("classname", `The classname of the entity to spawn`, true), new LibraryFunctionParameter("origin", `The position to spawn at`, true), new LibraryFunctionParameter("spawnflags", `Optional spawn flags (up to 5)`, false)], true, false, `Spawn( "trigger_radius", trigger_origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnActor", `Spawns an actor from an actor spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag)`, null, [new LibraryFunctionParameter("AIType", `AI type (constant string)`, true), new LibraryFunctionParameter("origin", `The position of the vehicle (vector)`, true), new LibraryFunctionParameter("angles", `The angle to spawn the vehicle at (vector)`, true), new LibraryFunctionParameter("targetname", `sets the targetname of the spawned entity`, false), new LibraryFunctionParameter("forcespawn", `forces a guy to spawn even if the spawn may be visible to the player`, false), new LibraryFunctionParameter("fullyaware", `gives the AI full awareness of all enemies`, false), new LibraryFunctionParameter("spawnerEnt", `if passed in, then the fields of the spawnerEnt will be duplicated to the newly spawned actor`, false)], true, false, `spawned = SpawnActor( "spawner_bo3_soldier_ally_sniper_tool", origin, angles, "george", false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnCollision", `Spawns a script mover thats used only for collision`, null, [new LibraryFunctionParameter("modelname", `The name of the model to spawn (constant string)`, true), new LibraryFunctionParameter("targetname", `target name (constant string)`, true), new LibraryFunctionParameter("origin", `The position of the collision (vector)`, true), new LibraryFunctionParameter("angles", `The angle to spawn the collision at (vector)`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("spawndynent", `Spawn a dynent`, null, [new LibraryFunctionParameter("model", `The model of the dynent`, true), new LibraryFunctionParameter("origin", `The position`, true), new LibraryFunctionParameter("angles", `The angles`, true)], false, true, `twig = spawndynent( "trashcan", origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnFromSpawner", `Spawns an actor or vehicle from a spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag) Unsupplied optional fields will use flag values from the entity`, "actor_or_vehicle_spawner", [new LibraryFunctionParameter("targetname", `sets the targetname of the spawned entity`, false), new LibraryFunctionParameter("forcespawn", `forces a guy to spawn even if the spawn may be visible to the player`, false), new LibraryFunctionParameter("makeroom", `will remove an undeletable entity if necessary to spawn a new one`, false), new LibraryFunctionParameter("infinitespawn", `don't increment the spawn count`, false), new LibraryFunctionParameter("classnameOverride", `override the spawner's classname`, false)], true, false, `spawned = spawnerent SpawnFromSpawner( "george", false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnFX", `Spawn an FX`, null, [new LibraryFunctionParameter("fx name", `Name of the fx. Fx has to be cached`, true), new LibraryFunctionParameter("position", `Position to play the fx at`, true), new LibraryFunctionParameter("forward", `The forward vector of the fx`, false), new LibraryFunctionParameter("up", `The up vector of the fx`, false)], true, false, `fx = SpawnFx( level._effect[player.light_playFX], monkey.origin + (0,0,-12),(1,0,0),(0,0,1) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnHelicopter", `Spawns a helicopter`, null, [new LibraryFunctionParameter("owner", `the owner entity`, true), new LibraryFunctionParameter("origin", `the location`, true), new LibraryFunctionParameter("angles", `the angles`, true), new LibraryFunctionParameter("vehicle name", `the vehicle name`, true), new LibraryFunctionParameter("model name", `the model name`, true)], true, false, `heliGuard = spawnHelicopter( self, startPos, startAng, "heli_guard_mp" , "veh_t6_drone_overwatch_light" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnNapalmGroundFlame", `Spawn a napalm ground flame at the origin with the direction.`, "entity", [new LibraryFunctionParameter("origin", `The origin of the flame`, true), new LibraryFunctionParameter("weapon", `The weapon`, true), new LibraryFunctionParameter("direction", `The direction of the flame`, true), new LibraryFunctionParameter("time", `The time to live`, false)], true, false, `self SpawnNapalmGroundFlame( bot_pos , weapon, forward)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnPathNode", `Spawn a dynamically created path node or cover node`, null, [new LibraryFunctionParameter("classname", `The class name`, true), new LibraryFunctionParameter("origin", `The origin`, true), new LibraryFunctionParameter("angles", `The view angles`, true), new LibraryFunctionParameter("key1", `Key 1`, false), new LibraryFunctionParameter("value1", `Value for key 1`, false), new LibraryFunctionParameter("key2", `Key 2`, false), new LibraryFunctionParameter("value2", `Value for key 2`, false)], true, false, `node = SpawnPathNode( cover_left, origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnPlane", `Spawns a plane at the origin`, null, [new LibraryFunctionParameter("player", `the owner`, true), new LibraryFunctionParameter("classname", `class of entity`, true), new LibraryFunctionParameter("origin", `location to spawn at`, true), new LibraryFunctionParameter("spawnflags", `optional spawn flags`, false)], true, false, `plane = spawnplane( owner, "script_model", origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnTimedFX", `Spawns a broadcast entity that plays an oriented timed FX using the weapon's property projExplosionEffect`, null, [new LibraryFunctionParameter("weapon", `weapon to spawn fx on`, true), new LibraryFunctionParameter("origin", `the position to spawn fx at`, true), new LibraryFunctionParameter("direction", `default (0,0,1)`, false), new LibraryFunctionParameter("time", `default 10 seconds`, false), new LibraryFunctionParameter("team", `defaults to TEAM_FREE`, false)], true, false, `ent = SpawnTimedFX( smokeGrenade, position, directionUp, duration )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnTurret", `Unsupported function. Do not use.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnVehicle", `Spawns a new vehicle and returns a reference to it`, null, [new LibraryFunctionParameter("vehicletype", `vehicle type (constant string)`, true), new LibraryFunctionParameter("origin", `The position of the vehicle (vector)`, true), new LibraryFunctionParameter("angles", `The angle to spawn the vehicle at (vector)`, true), new LibraryFunctionParameter("targetname", `vehicle target name (constant string)`, false), new LibraryFunctionParameter("destructibledef", `The destructibledef to use to make this vehicle a destructible`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartBinocs", `Start Binoculars on player`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `player StartBinocs()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartFadingBlur", `Blurs the screen, then fades out the blur to 0, over a period of time.`, "entity", [new LibraryFunctionParameter("blur_amount", `The initial blur amount. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.`, true), new LibraryFunctionParameter("time", `Time in seconds, how long the fade out will take`, true)], true, false, `player StartFadingBlur( 3, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartFiring", `Starts a turret firing`, "turret", [], true, false, `turret StartFiring()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartMission", `Start the (server side) mission script for the specified mission - all loading (on all clients) should be completed before calling - use client side LoadMission to load missions`, null, [new LibraryFunctionParameter("mission_index", `index of the mission name to start - mission names can be retrieved by calling GetMissions to return the available mission array`, true)], true, false, `StartMission()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartPoisoning", `Start poisoning player`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `player StartPoisoning()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartRagdoll", `Begin ragdoll physics for this entity.  Does nothing if the entity is already a ragdoll.`, "player_or_playercorpse", [new LibraryFunctionParameter("immediate", `Start the ragdoll immediately and don't do the velocity capture on the client.`, false)], true, false, `self StartRagdoll()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartResurrectViewAngleTransition", `Finishes the flashback`, null, [], true, false, `self StartResurrectViewAngleTransition()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopAllLoopSounds", `Stops a loop sound`, null, [new LibraryFunctionParameter("fade", `The fade out time`, false)], false, true, `car StopAllLoopSounds( 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopAllRumbles", `Stop all the rumbles playing right now`, null, [], true, false, `StopAllRumbles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopAnimScripted", `Halts animscript on this entity.`, "entity", [new LibraryFunctionParameter("blend", `The blend out time for the animation`, false), new LibraryFunctionParameter("ImmediateStop", `Stop the animation immediatly on the client side (no client/server time sync)`, false)], true, false, `self StopAnimScripted()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopBinocs", `Stop Binoculars on player`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `player StopBinocs()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopDemoRecording", `Stops demo recording`, null, [], true, false, `Demo_End()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopFiring", `Stops a turret firing`, "turret", [], true, false, `turret StopFiring()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopForceStreamingMaterial", `Forces the streamer to load the texture LODs for a material even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingMaterial when you no longer need it, or Steve will be upset that you're wasting Streamer memory.`, null, [new LibraryFunctionParameter("material", `Material to stop force streaming`, true)], false, true, `StopForceStreamingMaterial( material )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopForceStreamingXModel", `Forces the streamer to load model and texture LODs for a model even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingXModel when you no longer need it, or Steve will be upset that you're wasting Streamer memory.`, null, [new LibraryFunctionParameter("model", `The model to stop force streaming`, true)], false, true, `areAllForcedLodsLoaded = CScr_StopForceStreamingXModel( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopForcingStreamer", `Remove all streamer forcing`, null, [], false, true, `StopForcingStreamer()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopJukeMove", `Stops the player juke movement in progress`, "player", [], true, false, `player StopJukeMove()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopLoopSound", `Stops the looping sound with an optional fadetime.`, "entity", [new LibraryFunctionParameter("fadetime", `Time to fade the sound in. Range is between 1 and 31 inclusive.`, false)], true, false, `m_chasm stoploopsound( 5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopMission", `fire Mission_Stop event to terminate the current mission`, null, [], true, false, `StopMission()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopMoveSlide", `Stops the movement caused by MoveSlide().`, "model_origin_brushmodel", [], true, false, `self StopMoveSlide()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopPoisoning", `Stop poisoning player`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `player StopPoisoning()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopRumble", `Plays a looping rumble on the given entity.`, "entity", [new LibraryFunctionParameter("rumble name", `The name of the rumble to play`, true)], true, false, `self StopRumble( "damage_heavy" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopShellShock", `Stops the shell shock sequence for the player`, "player", [], true, false, `player StopShellShock()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopShootTurret", `Stops a turrent from firing.`, "turret", [], true, false, `roof_turret StopShootTurret()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopSound", `Stop a particular sound on an entity *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.`, null, [], true, false, `beatBox StopSound("alias");`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopSounds", `Stop all sounds on an entity.  *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.`, "entity", [], true, false, `beatBox StopSounds()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StreamerModelHint", `Force a model to be loaded for a set period of time.`, null, [new LibraryFunctionParameter("modelname", `The name of the model.`, true), new LibraryFunctionParameter("duration", `Length of time (in seconds) to keep it loaded.`, true)], true, false, `streamerModelHint( "c_hro_hendricks_base_fb", 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StreamerNotify", `Send a streamer notify to the server indicating that the streamer is ready`, null, [new LibraryFunctionParameter("id", `integer value indicating the current streamer notify`, true)], false, true, `StreamerNotify(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StreamerRequest", `Streamer request`, null, [new LibraryFunctionParameter("command", `"set", "clear" or "play"`, true), new LibraryFunctionParameter("name", `Name of the streamer hint asset`, true)], true, false, `streamerRequest( "set", "ramses_igc1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StreamerSkiptoDebug", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StreamTextureList", `Specify a texture list file for the streamer to load`, null, [new LibraryFunctionParameter("name", `Texturelist to stream`, true)], false, true, `StreamTextureList( "igc1" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SubtitlePrint", `print to the subtitle channel`, null, [new LibraryFunctionParameter("localClientNum", `The localClientNum to flush the subtitles for`, true), new LibraryFunctionParameter("msec", `The time to display the subtitle for`, true), new LibraryFunctionParameter("subtitle", `The message to display`, true)], false, true, `SubtitlePrint( 0, 100, "zombies everywhere") `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchMap_Load", `Start loading a map/level.`, null, [new LibraryFunctionParameter("map name", `the name of the map to preload`, true)], true, false, `SwitchMap_Load( "cp_sh_cairo", "coop", 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchMap_Preload", `Start preloading a map/level.  A 'switchmap_preload_finished' notify is sent to the level when its finished.`, null, [new LibraryFunctionParameter("map name", `the name of the map to preload`, true)], true, false, `SwitchMap_Preload( "cp_sh_cairo" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchMap_SetLoadingMovie", `Set the loading movie to play`, null, [new LibraryFunctionParameter("movie_name", `The name of the movie`, true)], true, false, `SwitchMap_SetLoadingMovie( str_intro_movie )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchMap_Switch", `Switch to the loaded map/level`, null, [], true, false, `SwitchMap_Switch()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_BoundingIsUnderReticle", `Returns true if the player's cursor is roughly inside of the target's bounding box.`, null, [new LibraryFunctionParameter("player", `The player entity`, true), new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("maxDistance", `The maximum distance to check for target intersection`, true)], true, false, `player Target_BoundingIsUnderReticle( player, enemy_chopper, 1000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_ClearReticleLockOn", `Cancels any lock-on sequence on the hud.`, null, [], true, false, `Target_ClearReticleLockOn()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_GetArray", `Gets an array of entities that are set as targets`, null, [], true, false, `mytargets = Target_GetArray()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_GetOffset", `Gets the target offset`, null, [new LibraryFunctionParameter("entity", `The entity that is the target`, true)], true, false, `offset = Target_GetOffset( entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_IsInCircle", `Returns whether a target is within a given radius from the center of the player's screen`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("player", `The player entity`, true), new LibraryFunctionParameter("fov", `The player's field of view`, true), new LibraryFunctionParameter("radius", `radius of the circle, centered at the center of the screen`, true), new LibraryFunctionParameter("zoffset", `if entity is not in target array, use optional zoffset for target pos`, false)], true, false, `player Target_IsInCircle( enemy_chopper, player, 65, 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_IsInRect", `Returns whether a target is within a given rectangle, centered in the center of the player's screen`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("player", `The player entity`, true), new LibraryFunctionParameter("fov", `The player's field of view`, true), new LibraryFunctionParameter("halfwidth", `half the width of the rectangle`, true), new LibraryFunctionParameter("halfheight", `half the height of the rectangle`, true)], true, false, `player Target_IsInRect( enemy_chopper, player, 65, 100, 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_IsTarget", `Returns whether an entity has been marked as a target`, null, [new LibraryFunctionParameter("entity", `The entity to check`, true)], true, false, `if ( Target_IsTarget( foundEnt ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_OriginIsInCircle", `Returns whether a target is within a given radius from the center of the player's screen`, null, [new LibraryFunctionParameter("origin", `The origin to test`, true), new LibraryFunctionParameter("player", `The player entity`, true), new LibraryFunctionParameter("fov", `The player's field of view`, true), new LibraryFunctionParameter("radius", `radius of the circle, centered at the center of the screen`, true)], true, false, `player Target_IsInCircle( enemy_chopper, player, 65, 100 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_Remove", `Removes a target`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true)], true, false, `Target_Remove( enemy_chopper )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_ScaleMinMaxRadius", `Returns the ratio from 0-1 of where the target is in relation to the radius min and radius max`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("player", `The player entity`, true), new LibraryFunctionParameter("fov", `The player's field of view`, true), new LibraryFunctionParameter("radius_min", `radius of the circle, centered at the center of the screen`, true), new LibraryFunctionParameter("radius_max", `radius of the circle, centered at the center of the screen`, true)], true, false, `scale = Target_ScaleMinMaxRadius( target, self, level.hackerToolLockOnFOV, radiusInner, radiusOuter )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_Set", `Adds a new target to draw on the hud`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("target offset", `The offset of the target position from the entity's origin`, false)], true, false, `Target_Set( enemy_chopper )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetAllowHighSteering", `Target will allow incoming missiles to steer more making the target easier to hit`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("bool", `true/false"`, true)], true, false, `Target_SetAllowHighSteering( enemy_tank, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetAttackMode", `Sets how missiles and rockets should approach the target.`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("mode name", `"top" or "direct"`, true)], true, false, `Target_SetAttackMode( enemy_tank, "top" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetJavelinOnly", `Target will only draw on player's hud when they are looking through the Javelin-weapon's site.`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("mode name", `"top" or "direct"`, true)], true, false, `Target_SetJavelinOnly( enemy_tank, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetOffscreenShader", `Sets the material that is used when a target clamps to the edge of the screen.  The target must have already been created with target_set()`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("materialname", `The shader for the quad drawn over the target`, true)], true, false, `Target_SetOffscreenShader( enemy_chopper, "arrow" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetOffset", `Sets the offset for a particular target`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("target offset", `The offset of the target position from the entity's origin`, false)], true, false, `Target_SetOffset( enemy_chopper, ( 0, 0, -100 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetShader", `Changes the material of a target.  The target must have already been created with target_set()`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("materialname", `The shader for the quad drawn over the target`, true)], true, false, `Target_SetShader( enemy_chopper, "locked_on_shader" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_SetTurretAquire", `Sets if the target can be attacked by SAM turrets`, null, [new LibraryFunctionParameter("entity", `The entity to set the flag`, true), new LibraryFunctionParameter("bool", `false if you want the SAM turret to ignore the targe. default is true.`, false)], true, false, `Target_SetTurretAquire( chopper, false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Target_StartReticleLockOn", `Begins the lock-on sequence for the target on the hud.  This affects the animation of the vehicle reticle.`, null, [new LibraryFunctionParameter("target entity", `The entity that is the target`, true), new LibraryFunctionParameter("duration", `The amount of time between now and fully locked-on, in seconds.`, true)], true, false, `Target_StartReticleLockOn( enemy_chopper, 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TestSpawnPoint", `Returns true if the player would not be in a solid when spawned at the given point.`, null, [new LibraryFunctionParameter("point", `the point to test`, true)], true, false, `TestSpawnPoint( self.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TmodeSetServerUser", `informs the server if the entity is using tmode`, "entity", [new LibraryFunctionParameter("value", `(int) 1-using 0-not usuing`, true)], true, false, `entity TmodeSetServerUser( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ToggleNoVehicleFaceTraversability", `Set whether the entity can use NoVehicleFaces. This should only be used in MP map for now.`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TracePassedOnNavMesh", `Run a trace on NavMesh to see if a character can go straight from start to end.`, null, [new LibraryFunctionParameter("start", `start of the trace`, true), new LibraryFunctionParameter("end", `end of the trace`, true), new LibraryFunctionParameter("characterRadius", `the radius of the capsule used in trace. default to 0.`, false), new LibraryFunctionParameter("materialFlags", `the flags marking whether a face type can be used`, false)], true, false, `posOnNavMesh = TracePassedOnNavMesh( (10,20,30), 25, 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TracePoint", `Traces a poitn throught the world with MASK_SHOT. Returns hit position, hit surface normal.`, null, [new LibraryFunctionParameter("start", `Start point`, true), new LibraryFunctionParameter("end", `End point`, true)], false, true, `trace = TracePoint( p0, p1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TriggerEnable", `Enables or disables the trigger`, "trigger", [new LibraryFunctionParameter("flag", `True if trigger should be enabled, false otherwise`, true)], true, false, `trig TriggerEnable( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TriggerFX", `Trigger the fx after some time delay`, null, [new LibraryFunctionParameter("entity", `The fx entity`, true), new LibraryFunctionParameter("time delay", `The time delay for the fx to play`, false)], true, false, `triggerFx( domFlag.enemyBaseEffect, 0.001 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TriggerIgnoreTeam", `Trigger ignores team`, "trigger", [], true, false, `trig TriggerIgnoreTeam()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Underwater", `checks if the player or actor is underwater`, "player_actor", [], false, true, `if( player Underwater() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Unlink", `Unlinks a linked entity from another entity`, "entity", [], true, false, `guy Unlink()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnlinkNodes", `Disconnects node1 from node2. Call it again with arguments flipped if you want to completely disconnect the two nodes.`, null, [new LibraryFunctionParameter("node1", `first node to unlink`, true), new LibraryFunctionParameter("node2", `second node to unlink`, true)], true, false, `UnlinkNodes( node_moving_elev_left, node_moving_elev_right )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnlinkTraversal", `Destroys a user edge connecting two path nodes`, null, [new LibraryFunctionParameter("node", `Negotiation begin node`, true)], true, false, `UnlinkTraversal( beginNode )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnloadSiegeAnim", `Unload a siege anim from memory`, null, [new LibraryFunctionParameter("anim_name", `Name of the siege anim to unload`, true)], false, true, `UnloadSiegeAnim( "flappy_bird" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnlockSongByAlias", `Unlock the the sound alias`, "entity", [new LibraryFunctionParameter("aliasname", `The sound alias to play (string)`, true)], true, false, `self UnlockSongByAlias( "frag_out" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnSetTurretNode", `Unset the turret from this node.`, null, [new LibraryFunctionParameter("node", `The turret node to disconnect`, true)], true, false, `UnSetTurretNode( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UpdateClientNames", `Update all of the client names: only works in 'manual_change' mode`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UpdateNavTriggers", `Optimized code that performs the update_nav_triggers() script functionality`, null, [], true, false, `UpateNavTriggers()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UpdateUnlockedAttachmentBits", `Updates client->unlockedAttachments`, "entity", [], true, false, `self UpdateUnlockedAttachmentBits()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseAlternateAimParams", `Forces the local player to use alternate values for aim assist. Only works in zombie/campaign mode. Can only be called on players`, "player", [], false, true, `self UseAlternateAimParams( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseAlternateHud", `Use the alternate HUD in lui. Zombies only`, null, [new LibraryFunctionParameter("onOff", `0 = regular, 1 = alternate`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseAnimTree", `Sets the anim tree for the entity`, "entity", [new LibraryFunctionParameter("anim tree", `The anim tree to set`, true)], true, false, `self UseAnimTree( #animtree )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseBuildKitWeaponModel", `Use a build kit weapon model`, null, [new LibraryFunctionParameter("player", `The player whose build kit data will be used`, true), new LibraryFunctionParameter("weapon", `The weapon to base the build kit on`, true), new LibraryFunctionParameter("camoIndex", `The index of the camo to override the build kit's camo with`, false), new LibraryFunctionParameter("upgraded", `bool whether this should be the upgraded version. If so extclip and fmj will be added`, false)], true, false, `wall_weapon_model UseBuildKitWeaponModel( player, magicbox.weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseBy", `Uses the entity with the passed in entity as the activator`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `self UseBy( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseServerVisionset", `Switches using the server supplied (via SetVisionSetForPlayer()) visionset.`, "player", [new LibraryFunctionParameter("use it", `Whether using the server override visionset`, true)], true, false, `player UseServerVisionset( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseTriggerIgnoreUseHoldTime", `Set the require look at flag for the trigger`, "trigger", [], true, false, `e_trig_mobile_armory UseTriggerIgnoreUseHoldTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseTriggerRequireLookAt", `Set the require look at flag for the trigger`, "trigger", [], true, false, `e_trig_plaza_igc UseTriggerRequireLookAt()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseTriggerRequireLookToward", `Set the require look along flag for the trigger`, "trigger", [], true, false, `e_trig_plaza_igc UseTriggerRequireLookToward()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseWeaponHideTags", `Hides tags on this entity based on the hidetags value of the provided weaponname`, null, [new LibraryFunctionParameter("weaponName", `The name of the weapon to base the tags to hide on`, true)], true, false, `wall_weapon_model UseWeaponHideTags()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseWeaponModel", `Use a weapon model`, null, [new LibraryFunctionParameter("weaponName", `The name of the weapon to base the tags to hide on`, true), new LibraryFunctionParameter("model", `The name of a model to use. If none is specified the world model for the weapon will be used`, false), new LibraryFunctionParameter("weapon options", `The weapon options`, false)], true, false, `wall_weapon_model UseWeaponModel("m16_zm")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Vibrate", `Causes a script entity to vibrate, rotating around its origin, along a given vector dir`, null, [new LibraryFunctionParameter("direction vector", `The direction of the vibration`, true), new LibraryFunctionParameter("amplitude", `The amount of the vibration in degrees`, true), new LibraryFunctionParameter("period", `The period of the vibration in seconds`, true), new LibraryFunctionParameter("time", `The length of time of the vibration in seconds`, true)], true, false, `self Vibrate( directionVir, 0.3, 0.4, 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VideoPause", `Pause video playback`, null, [new LibraryFunctionParameter("name", `name of movie to pause.  do not add a file suffix (like .mp4)`, true)], true, false, `VideoPause( "MyAwesomeMovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VideoPrime", `Preload the first second of a movie.  Call this several seconds before the movie needs to play to prevent any delay`, null, [new LibraryFunctionParameter("name", `name of movie to play.  do not add a file suffix (like .mp4)`, true), new LibraryFunctionParameter("loop", `Set this to true if the movie should automatically restart when it reaches the end.`, false)], true, false, `VideoPrime( "MyAwesomeMovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VideoStart", `Start a video for playback on an in-game surface`, null, [new LibraryFunctionParameter("name", `name of movie to play.  do not add a file suffix (like .mp4)`, true), new LibraryFunctionParameter("loop", `Set this to true if the movie should automatically restart when it reaches the end.`, false)], true, false, `VideoStart( "MyAwesomeMovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VideoStop", `Stop a video being played on an in-game surface`, null, [new LibraryFunctionParameter("name", `name of movie to stop.  do not add a file suffix (like .mp4)`, true)], true, false, `VideoStop( "MyAwesomeMovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VideoUnpause", `Unpause video playback`, null, [new LibraryFunctionParameter("name", `name of movie to pause.  do not add a file suffix (like .mp4)`, true)], true, false, `VideoUnpause( "MyAwesomeMovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ViewKick", `Give the player a view kick`, "player", [new LibraryFunctionParameter("damage", `The damage to inflict`, true), new LibraryFunctionParameter("origin", `The origin of the kick`, true)], true, false, `entity ViewKick( 25, self.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ViewmodelHasTag", `undefined`, null, [new LibraryFunctionParameter("local_client_num", `The client number`, true), new LibraryFunctionParameter("tag", `The tag to see if it exists on the current weapon`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VisionSetLastStand", `Sets players' laststand vision.  Optionally give a transition time from the current vision.`, null, [new LibraryFunctionParameter("vision name", `Vision to transition to.`, true), new LibraryFunctionParameter("transition time", `How long, in seconds, to take transitioning to the new vision set if a transition is possible.  Default is one second.`, false)], true, false, `VisionSetLastStand( "armada", 1.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VisionSetLerpRatio", `Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.`, null, [new LibraryFunctionParameter("float", `ratio between 0 and 1`, true)], true, false, `self VisionSetLerpRatio ( currentDistance / maxDistance )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VisionSetNaked", `Set the vision and its duration`, null, [new LibraryFunctionParameter("name", `The vision set name`, true), new LibraryFunctionParameter("duration", `The duration of the vision`, false)], true, false, `VisionSetNaked( "cp_igc_chinatown_intro", 0.05 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VrIsActive", `Returns whether the game is currently in VR mode.`, null, [], false, true, `do_vr_stuff = VrIsActive() ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WalkUnderwater", `Sets if a player should walk while underwater`, "player", [new LibraryFunctionParameter("boolean", `true if player should walk underwater.  False if player should swim`, true)], true, false, `depth = get_players()[0] WalkUnderwater( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponCyclingEnabled", `Determine if weapon cycling is enabled for the player`, "player", [], true, false, `enabled = player WeaponCyclingEnabled()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponFriendlyHacking", `Returns the value of the friendlyHacking bit on the specified weapon of the specified player`, null, [new LibraryFunctionParameter("localClientNum", `Local client number of the player`, true), new LibraryFunctionParameter("localClientNum", `Weapon to check`, true)], false, true, `currentWeapon = GetCurrentWeapon( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponHasAttachment", `Does the weapon have all the attachments specified?`, null, [], true, false, `WeaponHasAttachment( weapon, "extbarrel", "damage, "fmj" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponHasAttachmentAndUnlocked", `Does the weapon have all the attachments specified? And are they all unlocked for challenge stat purposes?`, null, [new LibraryFunctionParameter("weapon", `weapon`, true), new LibraryFunctionParameter("string", `string id for attachment`, true)], true, false, `player WeaponHasAttachmentAndUnlocked( weapon, "extbarrel", "damage, "fmj" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WorldEntNumber", `Returns the entity number for the world`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WorldToLocalCoords", `Transform the given world point into the local space of the entity`, "entity", [new LibraryFunctionParameter("world coords", `The point in world coordinates (vector3)`, true)], true, false, `local_point = self WorldToLocalCoords( world_point )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WorldTrace", `Trace from start to end`, null, [new LibraryFunctionParameter("start", `The trace start point`, true), new LibraryFunctionParameter("end", `The trace end point`, true)], true, false, `trace = WorldTrace( start_pos, end_pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierGetPiece", `Gets the entity for the zbarrier's given piece index`, "entity", [new LibraryFunctionParameter("piece_index", `piece index to get`, true)], false, true, `zbarrier ZBarrierGetPiece( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierPieceUseAlternateModel", `Sets the indexed piece to use the alternate model.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ZBarrierPieceUseAlternateModel(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierPieceUseAttachWeapon", `Sets the indexed piece to attach the zbarrier's weapon to tag_weapon (and tag_weapon_left if it's dual wield).`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ZBarrierPieceUseAttachWeapon( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierPieceUseBoxRiseLogic", `Sets the indexed piece to use the box rise logic.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ZBarrierPieceUseBoxRiseLogic(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierPieceUseDefaultModel", `Sets the indexed piece to use the default model.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ZBarrierPieceUseDefaultModel(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierPieceUseUpgradedModel", `Sets the indexed piece to use the upgraded model.`, "entity", [new LibraryFunctionParameter("piece number", `The piece index.`, true)], true, false, `ent ZBarrierPieceUseUpgradedModel(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierSupportsZombieReachThroughAttacks", `Returns true if this zbarrier supports zombie reach through attacks.`, "entity", [], true, false, `useAttack = ent ZBarrierSupportsZombieReachThroughAttacks()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZBarrierSupportsZombieTaunts", `Returns true if this zbarrier supports zombie taunt anims.`, "entity", [], true, false, `useTaunt = ent ZBarrierSupportsZombieTaunts()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZeroGravityVolumeOff", `Disables Zero Gravity Volume.`, null, [new LibraryFunctionParameter("volume name", `The volume name.`, true)], true, false, `ZeroGravityVolumeOff( "area_four" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZeroGravityVolumeOn", `Enables Zero Gravity Volume.`, null, [new LibraryFunctionParameter("volume name", `The volume name.`, true)], true, false, `ZeroGravityVolumeOn( "area_four" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddSentientEventListener", `Registers entity to listen to a specific event. Call waittill(<event>) to get the notification in script.`, "sentient", [new LibraryFunctionParameter("event", `The event name`, true)], true, false, `self AddSentientEventListener("bulletwhizby")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("aithrowgrenade", `Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.`, "actor", [], true, false, `self GrenadeThrow()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowPitchAngle", `Allows AI to pitch on stairs`, "actor", [new LibraryFunctionParameter("on_off", `1 to allow and 0 to disallow`, true)], true, false, `guy AllowPitchAngle ( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnimMode", `Set the way that animation deltas are interpreted by the game engine`, "entity", [new LibraryFunctionParameter("mode", `which animmode to use. Must be 'gravity', 'nogravity', 'angle deltas', 'pos deltas', 'normal', 'normal_nogravity', 'zonly_physics', 'nophysics', 'none'`, true), new LibraryFunctionParameter("clear path", `The clear path flag`, false)], true, false, `self AnimMode( "gravity" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AtDangerousNode", `Determine whether this actor is near a dangerous node.`, "actor", [], true, false, `if ( ai atDangerousNode() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AttackedRecently", `Returns true if given sentient has attacked the entity within last "time" sec.`, "sentient", [new LibraryFunctionParameter("entity", `The enemy entity`, true), new LibraryFunctionParameter("time", `Time interval in seconds.`, true)], true, false, `self AttackedRecently(self.enemy)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CalcApproximatePathToPosition", `Returns an array of world positions representing the approximate path an actor will take.  Calculating an approximate path will cause the AI to clear their current path.`, "actor", [new LibraryFunctionParameter("position", `The goal position for the path`, true), new LibraryFunctionParameter("clear path", `True to clear path, false otherwise. Defaults to True`, false)], true, false, `self CalcApproximatePathToPosition( position )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CalcLookaheadPos", `Calculate a lookahead point based on a given starting location and number of iterations. Returns an array with these keys: "position", "node" and "next_node", which contain vectors for the actual lookahead position and the next two nodes on the path, respectively.`, "actor", [new LibraryFunctionParameter("startPos", `Starting position of the lookahead traces`, true), new LibraryFunctionParameter("numIter", `Number of times to iterate (more gives better results, but is more expensive). Set to 0 to get current lookahead.`, true)], true, false, `self CalcLookaheadPos( self.origin, 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanAttackEnemyNode", `Checks if this actor can attack its enemies node.`, "actor", [], true, false, `self CanAttackEnemyNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanSee", `Check to see if the AI can see the given entity.`, "sentient", [new LibraryFunctionParameter("target", `(entity) The entity to check.`, true), new LibraryFunctionParameter("cacheLength", `(integer) The cache length`, false)], true, false, `if( self CanSee( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanShoot", `Check to see if the actor can shoot the given position.`, "actor", [new LibraryFunctionParameter("shoot at position", `(vector) The position to shoot at.`, true), new LibraryFunctionParameter("offset from gun", `(vector) The offset from the gun muzzle from which to calculate collision.`, false)], true, false, `canShoot = self CanShoot( eye, offset )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanShootEnemy", `Check to see if the actor can shoot his current enemy.`, "actor", [new LibraryFunctionParameter("cache duration", `(int) When set, uses a custom time value for the cache.`, false)], true, false, `canShootEnemy = self CanShootEnemy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanThrowGrenade", `Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector`, "actor", [new LibraryFunctionParameter("hand offset", `(vector) the estimated offset of the hand for the throw`, true), new LibraryFunctionParameter("random range", `(float) random range from target position to throw at`, true)], true, false, `throwvel = self CanThrowGrenade( armOffset, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanThrowGrenadePos", `Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector`, "actor", [new LibraryFunctionParameter("hand offset", `(vector) the estimated offset of the hand for the throw`, true), new LibraryFunctionParameter("targetpos", `(vector) The target position, should be at ground level of potential target`, true)], true, false, `throwvel = self CanThrowGrenadePos( armOffset, targetPos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CheckGrenadeThrow", `Checks whether the actor can throw a grenade at his target. If he can't then result will be undefined, otherwise the result is the resultant velocity vector`, "actor", [new LibraryFunctionParameter("hand offset", `(vector) the estimated offset of the hand for the throw`, true), new LibraryFunctionParameter("method", `(string) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'`, true), new LibraryFunctionParameter("random range", `(float) random range from target position to throw at`, true)], true, false, `throwvel = self CheckGrenadeThrow( armOffset, "min energy", 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CheckGrenadeThrowPos", `Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector`, "actor", [new LibraryFunctionParameter("hand offset", `(vector) the estimated offset of the hand for the throw`, true), new LibraryFunctionParameter("method", `(vector) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'`, true), new LibraryFunctionParameter("targetpos", `(vector) The target position, should be at ground level of potential target`, true)], true, false, `throwvel = self CheckGrenadeThrowPos( armOffset, "min energy", targetPos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CheckProne", `Returns true when a character can go prone at the specified position. Specifically setup for use by AI characters.`, "actor", [new LibraryFunctionParameter("position", `(vector) The position of the prone character.`, true), new LibraryFunctionParameter("yaw", `(float) The world yaw in degrees.`, true), new LibraryFunctionParameter("is prone", `(bool) Flag if the character is already prone.`, true)], true, false, `canFitProne = self CheckProne( origin, yaw, alreadyProne )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ChooseBetterCoverNode", `Chooses a better cover node for an ai`, "actor", [], true, false, `newNode = behaviorTreeEntity ChooseBetterCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearEnemy", `Clear the actor's current enemy entity.`, "actor", [], true, false, `self ClearEnemy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearEntityOwner", `Clears an AI's entity owner.`, "actor", [], true, false, `self ClearEntityOwner()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearEntityTarget", `Clears an AI's entity target.`, "actor", [], true, false, `self ClearEntityTarget( vehicle_entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearFixedNodeSafeVolume", `Clears this actor's fixed node safe volume.`, "actor", [], true, false, `self ClearFixedNodeSafeVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearForcedGoal", `Clears the forcedGoal for this AI's goal.`, "sentient", [], true, false, `self ClearForcedGoal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearGoalVolume", `Clears this actor's goal volume.`, "sentient", [], true, false, `self ClearGoalVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPath", `Clears the AI's current path.`, "actor", [], true, false, `self ClearPath()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPitchOrient", `Clear pitch orientation`, "actor", [], true, false, `self clearPitchOrient()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPotentialThreat", `Clear the potential threat direction. See SetPotentialThreat for more info on potential threats`, "entity", [new LibraryFunctionParameter("dir", `direction of the threat. This is the angle from which the NPC should expect danger`, true)], true, false, `self ClearPotentialThreat( 90 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearUsePosition", `Clear the override for the goal pos.`, "actor", [], true, false, `self ClearUsePosition()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CollideWithActors", `Toggles collision with other actors. Actor will go through each other, when its toggled off.`, "actor", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `entity CollideWithActors( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateThreatBiasGroup", `Create a new threat bias group. If it already exists, do nothing`, null, [new LibraryFunctionParameter("name", `threat bias group name.`, true)], true, false, `CreateThreatBiasGroup( "flanking_team" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DamageMode", `Set the damage mode of this actor.`, "actor", [new LibraryFunctionParameter("damage mode", `(const string) DamageMode must be 'normal' or 'next_shot_kills'`, true)], true, false, `randAlly DamageMode("next_shot_kills")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DropWeapon", `Drop the actor's weapon`, "actor", [new LibraryFunctionParameter("weapon name", `(string) The name of the weapon.`, true), new LibraryFunctionParameter("hand", `(string) The tag to throw the weapon from.`, true), new LibraryFunctionParameter("velocity", `(vector) The initial velocity of the weapon.`, false), new LibraryFunctionParameter("angular velocity", `(vector) The initial angular velocity of the weapon.`, false), new LibraryFunctionParameter("scavenger", `(bool) If the weapon requires the player to have scavenger perk to pick up the weapon.`, false)], true, false, `self DropWeapon(self.weapon, self.anim_gunHand, throwVel)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindBestCoverNode", `Find the best cover node for a given NPC given his state.`, "actor", [], true, false, `self FindBestCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindBestCoverNodes", `Find the best cover nodes for a given NPC given his state. Sorted by best`, "actor", [new LibraryFunctionParameter("radius", `search radius`, true), new LibraryFunctionParameter("origin", `search origin`, true)], true, false, `nodes = self FindBestCoverNodes(radius,origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindCoverNodeAtLocation", `Finds a near by cover node for the character.`, "actor", [new LibraryFunctionParameter("radius", `search radius`, true), new LibraryFunctionParameter("origin", `search origin`, true)], true, false, `guy FindCoverNodeAtLocation(512,loc)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindReacquireDirectPath", `Finds a path directly to the enemy. Call ReacquireMove to use the path.`, "actor", [new LibraryFunctionParameter("ignore suppression", `Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindReacquireNode", `Finds a reacquire node when exposed.`, "actor", [], true, false, `guy FindReacquireNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindReacquireProximatePath", `Finds a path to a point that can see the enemy without leaving goal. Call ReacquireMove to use the path.`, "actor", [new LibraryFunctionParameter("ignore suppression", `Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.`, false)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FinishActorDamage", `Does damage to an actor - usually as part of the damage callback`, "actor", [new LibraryFunctionParameter("Inflictor", `The entity that causes the damage.(e.g. a turret)`, true), new LibraryFunctionParameter("Attacker", `The entity that is attacking.`, true), new LibraryFunctionParameter("Damage", `Integer specifying the amount of damage done`, true), new LibraryFunctionParameter("Damage Flags", `Integer specifying flags that are to be applied to the damage`, true), new LibraryFunctionParameter("Means Of Death", `Integer specifying the method of death`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true), new LibraryFunctionParameter("Direction", `(vector) The direction of the damage`, true), new LibraryFunctionParameter("Hit Loc", `The location of the hit`, true), new LibraryFunctionParameter("Damage Origin", `Position of the originator of the damage`, true), new LibraryFunctionParameter("Offset Time", `The time offset for the damage`, true), new LibraryFunctionParameter("Bone Index", `Index of nearest bone`, true), new LibraryFunctionParameter("Surface Type", `The surface type of the hit location`, false), new LibraryFunctionParameter("Surface Normal", `The surface normal at hit location`, false)], true, false, `self FinishActorDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, vDamageOrigin, psOffsetTime, iBoneIndex, iSurfaceType, vSurfaceNormal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceTeleport", `Force Teleport the actor to a new position with the given origin and angles, regardless of wether it will be visible to the player or not.`, "actor", [new LibraryFunctionParameter("position", `(point) The actor's new position.`, true), new LibraryFunctionParameter("angles", `(vector) The actor's new angles.`, false), new LibraryFunctionParameter("updategoalpos", `(bool) Update the script goal position to the teleport location. True by default.`, false), new LibraryFunctionParameter("resetEntity", `(bool) Reset the entity behaviors.`, false)], true, false, `self ForceTeleport( org, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GenerateRadioEvent", `Searches animation selector table and returns an animation alias based on current state of the blackboard.`, "actor", [new LibraryFunctionParameter("type of event", `The type of radio event`, true)], true, false, `self GenerateRadioEvent("radio_event_low")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAimLimitsFromEntry", `Searches animation selector table and returns an animation alias based on current state of the blackboard.`, "actor", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBehaviorTreeStatus", `Returns current status/BHTN_STATUS of the behavior tree for an actor.`, "actor", [], true, false, `isBehaviorTreeInRunningState = behaviorTreeEntity GetBehaviortreeStatus() == BHTN_RUNNING`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetClosestEnemySqDist", `Get the distance to the nearest enemy`, "sentient", [], true, false, `dist = self GetClosestEnemySqDist()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDropToFloorPosition", `Gets the floor position for dropping an AI or player to the ground. Returns undefined if the AI is in solid.`, "entity", [new LibraryFunctionParameter("position", `test position. Defaults to entity's current origin`, false)], true, false, `position = ai GetDropToFloorPosition( ai.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFinalPathPos", `Get the last position in the path`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFireMode", `returns the firemode`, "actor", [], true, false, `soldier GetFireMode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFixedNodeSafeVolume", `Get this actor's fixed node safe volume.`, "actor", [], true, false, `volume = self GetFixedNodeSafeVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFlashBangedStrength", `Retrieves how strongly the actor was initially hit by a flashbang. 1.0 is full strength, 0.0 is none at all.`, "actor", [], true, false, `flashedPercent = self GetFlashBangedStrength()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGoalVolume", `Get this actor's goal volume.`, "sentient", [], true, false, `goalVolume = self GetGoalVolume()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGroundEntType", `Get the entity type of the 'ground' that the actor is on.`, "actor", [], true, false, `self GetGroundEntType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHitEntType", `Get the type of entity that the actor has hit. Can be 'hit', 'obstacle' or 'world'.`, "actor", [], true, false, `self GetHitEntType()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHitYaw", `Get the direction in degrees that the player has hit an obstacle at. Returns an error if nothing was hit.`, "actor", [], true, false, `self GetHitYaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetIgnoreEnt", `Returns if a specific sentient entity is ignored by this sentient entity or not`, "sentient", [new LibraryFunctionParameter("sentient", `Another sentient entity`, true)], true, false, `if ( aiGuy GetIgnoreEnt( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNextFindBestCoverTime", `Generates a new next find cover time`, null, [new LibraryFunctionParameter("minEngageDist", `Min engage enemy dist.`, true), new LibraryFunctionParameter("maxEngageDist", `Max engage enemy dist.`, true), new LibraryFunctionParameter("noEnemyInterval", `How often cover should be searched when without an enemy`, true)], true, false, `behaviorTreeEntity.nextFindBestCoverTime = GetActorNextFindBestCoverTime( behaviorTreeEntity.engageMinDist, behaviorTreeEntity.engagemaxdist, behaviorTreeEntity.coversearchinterval )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeOffsetAngles", `Returns the angles the actor thinks the node is facing, this can contain additional rotation from the node's actual angles.`, "actor", [], true, false, `self GetNodeOffsetAngles( self.node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNodeOffsetPosition", `Returns the position the actor thinks the node's origin is at, this can be offset from where the actual node's position in the world is.`, "actor", [], true, false, `self GetNodeOffsetPosition( self.node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOrientMode", `Set the orient mode of this actor.`, "actor", [], true, false, `orientMode = randAlly GetOrientMode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathLength", `Gets the length of the path being used by this actor`, "actor", [], true, false, `self GetPathLength()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathMode", `Get the path mode of this actor.`, "actor", [], true, false, `pathMode = randAlly GetPathMode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPerfectInfo", `Forces the AI to become aware of this entity regardless of whether it can be seen or not.`, "actor", [new LibraryFunctionParameter("entity", `An entity to become aware of. Must be a sentient (i.e. AI or player)`, true), new LibraryFunctionParameter("update sight", `If true then it will update the last seen position also.`, false)], true, false, `self GetPerfectInfo( get_players()[0] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPersonalThreatBias", `return the personal threat bias for this sentient versus the other sentient`, "sentient", [new LibraryFunctionParameter("sentient", `Self`, true), new LibraryFunctionParameter("enemy", `The enemy to get threat bias for`, true)], true, false, `value = self GetPersonalThreatBias( self.enemy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetReacquireNode", `Gets the reacquire node of this actor.`, "actor", [], true, false, `guy GetReacquireNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetStealthSightValue", `Get the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)`, "sentient", [new LibraryFunctionParameter("otherSentient", `other sentient you want to get the value on this sentient for`, true)], true, false, `aiGuy GetStealthSightValue( forOtherGuy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetThreatBias", `Get threat bias of first group against second group`, null, [new LibraryFunctionParameter("of group", `(string) threat bias group for.`, true), new LibraryFunctionParameter("against group", `(string) threat bias group against.`, true)], true, false, `GetThreatBias( "axis", "flanking_team" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetThreatBiasGroup", `Get the threat bias group of an AI or player`, "entity", [], true, false, `GetThreatBiasGroup()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurnExitYaw", `Predicts exit yaw vector using havok pathfinding.`, "actor", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GrenadeThrow", `Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.`, "actor", [], true, false, `self GrenadeThrow()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasPath", `returns true/false if AI has a path`, "sentient", [], true, false, `self HasPAth()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasValidInterrupt", `Return true if there is a valid interrupt with the given name alive on the current server frame.`, "actor", [new LibraryFunctionParameter("interrupt name", `The name of the interrupt`, true)], true, false, `if ( entity HasValidInterrupt("pain") )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsActorShooting", `Checks whether this entity is an ai is shooting`, "actor", [new LibraryFunctionParameter("entity", `An actor`, true)], true, false, `if ( meanGuy IsActorShooting() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsApproachingGoal", `returns true/false if actor at the goal or approaching the goal.`, "actor", [], true, false, `self IsApproachingGoal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAtCoverNode", `returns true/false if actor is at cover node. (exposed node is considered as covernode)`, "actor", [], true, false, `self IsAtCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAtCoverNodeStrict", `returns true/false if actor is at cover node. (exposed node is not considered as covernode)`, "actor", [], true, false, `self IsAtCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsAtGoal", `returns true/false if actor has at/reached its current goal, similar to waiting for "goal" notify.`, "actor", [], true, false, `self IsAtGoal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsBadGuy", `Returns true if the sentient is on the bad guy team (not 'allies', not 'neutral').`, "entity", [], true, false, `if ( ai IsBadGuy() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCoverValid", `Return true if the passed in node is a valid cover node.`, "actor", [new LibraryFunctionParameter("pathnode", `The pathnode to check for validity`, true)], true, false, `if( self IsCoverValid( pathnode ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCurrentBTActionLooping", `Return true if there is an action running and its looping.`, "actor", [], true, false, `if( behaviorTreeEntity IsCurrentBTActionLooping() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDeflected", `Check if the actor has been deflected.`, "actor", [], true, false, `self IsDeflected()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFlankedAtCoverNode", `returns true/false if actor is at is flanked at cover node`, "actor", [], true, false, `self IsFlankedAtCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGrenadePosSafe", `Checks a grenade throw target position is safe.`, "actor", [new LibraryFunctionParameter("throw pos", `(vector) position to throw at`, true), new LibraryFunctionParameter("radius", `(float) safety radius`, false)], true, false, `if ( self IsGrenadeThrowSafe( throwPos, 200 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInAnyBadPlace", `Returns whether the AI is in a bad place.`, "actor", [], true, false, `self IsInAnyBadPlace()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInGoal", `Determine whether a given point is in the actor's current goal area`, "sentient", [new LibraryFunctionParameter("point", `which point to check.`, true)], true, false, `if ( ai IsInGoal( point ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInScriptedState", `Checks if actor is in a scripted state (animscripted, custom, negotiation)`, "actor", [], true, false, `self isInScripteState()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsKnownEnemyInRadius", `Checks if there is a known enemy in a radius for an AI.`, "actor", [new LibraryFunctionParameter("position", `center of radius to check.`, true), new LibraryFunctionParameter("radius", `.`, true)], true, false, `if ( self IsKnownEnemyInRadius( pos, radius ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsKnownEnemyInVolume", `Checks if there is a known enemy in a volume for an AI.`, "actor", [new LibraryFunctionParameter("volume", `volume entity to check in.`, true)], true, false, `if ( self isKnownEnemyInVolume( volume ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMoveSuppressed", `Checks whether this actor is in a suppressed state ( blocked by friendly fire ).`, "actor", [], true, false, `while ( self IsMoveSuppressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsNoTarget", `returns if the sentient is marked no target`, "sentient", [], true, false, `if ( self IsNoTarget() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPathDirect", `Check whether the actor's current path is direct`, "actor", [], true, false, `self IsPathDirect()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPosAtGoal", `returns true/false if position is inside the current goal`, "actor", [], true, false, `self IsPosAtGoal(position)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPosInClaimedLocation", `returns true/false if position is claimed by another sentient`, "sentient", [], true, false, `self IsPosInClaimedLocation( position )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSafeFromGrenade", `returns true/false if actor is within a blast radius of a grenade.`, "actor", [], true, false, `self IsSafeFromGrenade()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStanceAllowed", `Checks whether this actor can go to the given stance.`, "actor", [new LibraryFunctionParameter("stance", `(string) A stance, can be 'prone', 'crouch', 'stand'.`, true)], true, false, `if ( self IsStanceAllowed( "stand" ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSuppressed", `Checks whether this actor is in a suppressed state ( under fire ).`, "actor", [], true, false, `while ( self IsSuppressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSuppressionWaiting", `Checks whether this actor is still doing suppression wait.`, "actor", [], true, false, `while ( self IsSuppressionWaiting() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsThreateningMyProtectEntity", `Returns true if the enemy is currently threatening my protect entity.`, "sentient", [new LibraryFunctionParameter("target", `(sentient) The sentient to check.`, true)], true, false, `if ( self IsThreateningMyProtectEntity( self.enemy ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Knockback", `Turn knockback on and off for an actor`, "actor", [new LibraryFunctionParameter("true/false", `if true, actor affected by knockback`, true)], true, false, `self Knockback( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LastKnownPos", `Return the last known pos of an AI.`, "sentient", [new LibraryFunctionParameter("target", `(sentient) The sentient to check.`, true)], true, false, `if ( self lastKnownPos( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LastKnownTime", `Return the last time an AI was aware of target. Includes visibility and ai events like footstep, gunshot etc.`, "sentient", [new LibraryFunctionParameter("target", `(sentient) The sentient to check.`, true)], true, false, `if( self lastKnownTime( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LerpPosition", `Interpolate an actor's position, and angles.`, "actor", [new LibraryFunctionParameter("origin", `(vector) the position to interpolate to.`, true), new LibraryFunctionParameter("angles", `(vector) the angles to interpolate to.`, true)], true, false, `self LerpPosition( entry['origin'], entry['angles'] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MayMoveFromPointToPoint", `Check whether the actor can move from a given point to a given point. Does not check friendly fire and in goal radius unlike maymovetopoint`, "actor", [new LibraryFunctionParameter("start", `(point) start position.`, true), new LibraryFunctionParameter("end", `(point) end position.`, true), new LibraryFunctionParameter("check drop", `checks if the point would cause the AI to drop. Defaults to true.`, false), new LibraryFunctionParameter("check direct", `checks if there are no obstructions between actor origin and <Position>.`, false)], true, false, `if ( !self MayMoveFromPointToPoint( startPoint endPoint ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MayMoveToPoint", `Check whether the actor can move to a given point.`, "actor", [new LibraryFunctionParameter("position", `(point) The position that the actor may be able to move to.`, true), new LibraryFunctionParameter("check drop", `checks if the point would cause the AI to drop. Defaults to true.`, false), new LibraryFunctionParameter("check direct", `checks if there are no obstructions between actor origin and <Position>.`, false)], true, false, `if ( !self MayMoveToPoint( endPoint ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Melee", `Makes this actor melee attack. Returns the entity hit, if any.`, "actor", [new LibraryFunctionParameter("direction", `direction to attack, if not specified, uses direction to current enemy.`, false)], true, false, `guy Melee()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MeleeWithOffset", `Makes this actor melee attack. Returns the entity hit, if any.`, "actor", [new LibraryFunctionParameter("offset", `A vector offset added to the actor's eye position from which to start the melee trace.`, true)], true, false, `guy MeleeWithOffset( (0,0,32) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NearClaimNode", `Determine whether this actor is near its claim node.`, "actor", [], true, false, `if ( ai NearClaimNode() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NearClaimNodeAndAngle", `Determine whether this actor is near its claim node and nearly matches the angle.`, "actor", [], true, false, `if ( ai NearClaimNodeAndAngle() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NearNode", `Determine whether this actor is near to a given path node.`, "actor", [new LibraryFunctionParameter("node", `The path node to check.`, true)], true, false, `if ( ai NearNode( node ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OrientMode", `Set the orient mode of this actor.`, "actor", [new LibraryFunctionParameter("orient mode", `(const string) OrientMode must be 'face angle', 'face current', 'face direction', 'face enemy', 'face enemy or motion', 'face goal', 'face motion', 'face point', or 'face default'`, true), new LibraryFunctionParameter("face angle", `(float) The yaw angle to face if orient mode is 'face angle'`, false), new LibraryFunctionParameter("direction vector", `(vector) The direction vector to face if orient mode is 'face direction'`, false), new LibraryFunctionParameter("face position", `(vector) The point to face if orient mode is 'face point'`, false)], true, false, `randAlly OrientMode("face direction", player.origin-randAlly.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathMode", `Set the path mode of this actor.`, "actor", [new LibraryFunctionParameter("path mode", `(const string) PathMode must be 'dont move', 'move allowed', or 'move delayed'`, true), new LibraryFunctionParameter("clear path", `(integer) 1 to clear path`, false), new LibraryFunctionParameter("path delay", `(float) Amount of time (seconds) to wait if path mode is 'move delayed'`, false)], true, false, `randAlly PathMode("dont move")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PickUpGrenade", `Pick up a grenade`, "actor", [], true, false, `self PickUpGrenade()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictArrival", `Predicts the arrival direction vector using havok corner predictor.`, "actor", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictExit", `Predicts the exit direction vector using havok corner predictor.`, "actor", [], true, false, `predictedLookAheadInfo = self PredictExit()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PredictPath", `Predicts the path to look for upcoming corner using havok corner predictor.`, "actor", [], true, false, `predictedLookAheadInfo = self PredictPath()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PushPlayer", `Set whether this character can push the player. Don't call this unless you know what you are doing.`, "actor", [new LibraryFunctionParameter("can push player", `(bool) True if this character can push the player.`, true)], true, false, `level.elder PushPlayer( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReacquireMove", `Start the reaquire move`, "actor", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReacquireStep", `Do side step move to safe place left or right while facing enemy.`, "actor", [new LibraryFunctionParameter("dist", `(floating point number) amount to side step left or right`, true)], true, false, `reacquirePos = entity ReacquireStep( step_size )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveSentientEventListener", `De-Registers entity to listen to a specific event. if event is undefined, entity will stop listening to all the evnets.`, "sentient", [new LibraryFunctionParameter("event", `The event name`, false)], true, false, `self RemoveSentientEventListener("bulletwhizby")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetVisibilityCacheWithinRadius", `Reset the viscache for sentients within the specified radius`, null, [new LibraryFunctionParameter("origin", `Center of reset bounds`, true), new LibraryFunctionParameter("radius", `Distance around the origin to scan for sentients`, true)], true, false, `ResetVisibilityCacheWithinRadius(origin, 500)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SeeRecently", `Check to see if the AI saw the given sentient in the past <time>. If called on a non-sentient, just does a cansee check`, "sentient", [new LibraryFunctionParameter("target", `(entity) The entity to check.`, true), new LibraryFunctionParameter("time", `(int) seconds.`, true)], true, false, `if( self SeeRecently( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntityOwner", `Set an entity as the AI's owner. The owner will never be targeted.`, "actor", [new LibraryFunctionParameter("entity", `An entity for owner.`, true)], true, false, `self SetEntityOwner( vehicle_entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEntityTarget", `Set an entity as the AI's target. This is for special cases only. Do not set AI or player targets with this.`, "actor", [new LibraryFunctionParameter("entity", `An entity to target (cannot be server only entity).`, true), new LibraryFunctionParameter("threat", `A fraction of maximum possible threat an AI can have. Must be in 0 to 1 range. Defaults to 1.`, false), new LibraryFunctionParameter("tag name", `Tag to aim/shoot at on this entity. Defaults to tag_eye for actors/players".`, false)], true, false, `self SetEntityTarget( vehicle_entity, 0.7, "tag_head" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFixedNodeSafeVolume", `Set this actor's fixed node safe volume.`, "actor", [new LibraryFunctionParameter("volume entity", `(entity) The safe volume entity.`, true)], true, false, `self SetFixedNodeSafeVolume( volume )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFlashBanged", `Sets whether an actor is under a flashbang effect.`, "actor", [new LibraryFunctionParameter("flashed", `Whether or not the actor is under the affect of a flashbang.`, true), new LibraryFunctionParameter("strength", `If actor is flashed, how severely they were initially affected. Between 0.0 and 1.0 (full strength).`, false)], true, false, `self SetFlashBanged( true, 0.8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFlashbangImmunity", `Sets whether an actor is succeptable to flashbangs.`, "actor", [new LibraryFunctionParameter("immune", `If the actor can be affected by flashbangs.`, true)], true, false, `level.suicideguy SetFlashbangImmunity( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFreeCameraLockOnAllowed", `Sets whether the ai is allowed to be locked onto in the demo free camera`, "actor", [new LibraryFunctionParameter("allowed", `boolean of whether it is allowed`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGoal", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setgoalentity", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setgoalnode", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setgoalpos", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setgoalvolume", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setgoalvolumeauto", `Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.`, "sentient", [new LibraryFunctionParameter("pos", `/<node>/<entity>/<volume>`, true), new LibraryFunctionParameter("forced", `(bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.`, false), new LibraryFunctionParameter("goalradius", `radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false), new LibraryFunctionParameter("goalheight", `height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.`, false)], true, false, `self SetGoal( node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetIgnoreEnt", `Set a sentient entity to ignore another specific sentient entity or not`, "sentient", [new LibraryFunctionParameter("sentient", `Another sentient entity`, true), new LibraryFunctionParameter("ignored", `true/false`, true)], true, false, `aiGuy SetIgnoreEnt( player, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetIgnoreMeGroup", `Make first group ignored by second group`, null, [new LibraryFunctionParameter("ignored group", `(string) ignored group.`, true), new LibraryFunctionParameter("ignoring group", `(string) ignoring group.`, true)], true, false, `SetIgnoreMeGroup( "flanking_team", "axis" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPersonalIgnore", `self will not pick enemy as target for the duration`, "sentient", [new LibraryFunctionParameter("sentient", `Self`, true), new LibraryFunctionParameter("enemy", `The enemy to set threat bias for`, true), new LibraryFunctionParameter("duration", `How long this threat bias lasts in seconds`, false)], true, false, `self SetPersonalIgnore( self.enemy, 5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPersonalThreatBias", `Sets a personal threat bias for this sentient versus the other sentient.  It lasts for the given duration.`, "sentient", [new LibraryFunctionParameter("sentient", `Self`, true), new LibraryFunctionParameter("enemy", `The enemy to set threat bias for`, true), new LibraryFunctionParameter("threatBias", `The threat bias amount`, true), new LibraryFunctionParameter("duration", `How long this threat bias lasts in seconds`, false)], true, false, `self SetPersonalThreatBias( self.enemy, -1000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPhysParams", `Sets the collision bounds for an actor.`, "actor", [new LibraryFunctionParameter("radius", `size of the actor.`, true), new LibraryFunctionParameter("minsz", `min height of the actor.`, true), new LibraryFunctionParameter("maxsz", `max height of the actor.`, true)], true, false, `self setPhysParams( 15, 0, 72 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPitchOrient", `Set pitch orientation`, "actor", [], true, false, `self setPitchOrient()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPotentialThreat", `In non-combat situations. This is mostly useful for friendlies.`, "entity", [new LibraryFunctionParameter("dir", `direction of the threat. This is the angle from which the NPC should expect danger`, true)], true, false, `self SetPotentialThreat( 90 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRepairPaths", `True allows havok to repath automatically if the AI moves off their predefined path.`, "actor", [new LibraryFunctionParameter("on_off", `true to enable repair paths, false otherwise`, true)], true, false, `self SetRepairPaths( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStairsExitTransform", `Sets the base transform for the exit stairs animation using the current position in the looping anim`, "actor", [], true, false, `self SetStairsExitTransform()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStealthSight", `Set the parameters for given awarenesslevel of stealth sight when active on an sentient`, null, [new LibraryFunctionParameter("awareness", `"unaware", "low_alert", "high_alert", or "combat"`, true), new LibraryFunctionParameter("timeDecay", `float value of seconds stealth sight takes to fall off completely (0 for never/infinite)`, true), new LibraryFunctionParameter("timeDistMin", `float value of seconds stealth sight takes to grow completely at min range (0 for never/infinite)`, true), new LibraryFunctionParameter("timeDistMax", `float value of seconds stealth sight takes to grow completely at max range (0 for never/infinite)`, true), new LibraryFunctionParameter("distMin", `float value of the min distance`, true), new LibraryFunctionParameter("distMax", `float value of the max distance`, true), new LibraryFunctionParameter("extendSight", `indicates of sight continues beyond max range at the max rate`, false)], true, false, `SetStealthSight( "high_alert", 2, 1, 10, 200, 1000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStealthSightAwareness", `Set the current stealth sight awareness state for this sentient`, "sentient", [new LibraryFunctionParameter("awareness", `"unaware", "low_alert", "high_alert", "combat", or undefined to disable it (default disabled)`, false), new LibraryFunctionParameter("decayEnabled", `if true stealth sight will decay when other sentient is not in sight (default true)`, false)], true, false, `aiGuy SetStealthSightAwareness( "unaware", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetStealthSightValue", `Set the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)`, "sentient", [new LibraryFunctionParameter("otherSentient", `other sentient you want to set the value on this sentient for`, true), new LibraryFunctionParameter("newValue", `The new stealth sight value`, true)], true, false, `aiGuy SetStealthSightValue( forOtherGuy, 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSteeringMode", `Sets the steering mode for the actor.  Valid modes are "normal steering", "slow steering", "vignette steering".`, "actor", [new LibraryFunctionParameter("steering mode", `Mode to set.`, true)], true, false, `self SetSteeringMode( "slow steering" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetThreatBias", `Set threat bias of second group against first group`, null, [new LibraryFunctionParameter("against group", `(string) threat bias group against.`, true), new LibraryFunctionParameter("for group", `(string) threat bias group for.`, true), new LibraryFunctionParameter("threat bias", `(int) threat bias value.`, true)], true, false, `SetThreatBias( "axis", "flanking_team", 120 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetThreatBiasAgainstAll", `Set the threatbias a group has against all others`, null, [new LibraryFunctionParameter("group", `(string) threat bias group name.`, true), new LibraryFunctionParameter("value", `(int) threat bias value.`, true)], true, false, `SetThreatBiasAgainstAll( "flanking_team", 120 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetThreatBiasGroup", `Set or clear threat bias group of an AI or player`, "entity", [new LibraryFunctionParameter("threat_bias_group", `(string) threat bias group name. If none, remove actor from current threat bias group`, false)], true, false, `SetThreatBiasGroup( "flanking_team" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Shoot", `Makes this actor shoot.`, "actor", [new LibraryFunctionParameter("accuracy modifier", `(floating point number)`, false), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `guy shoot()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldFaceMotion", `Determines if the AI should face the motion direction. Use self.faceMotion instead of this except when the AI is just beginning to move.`, "actor", [], true, false, `self ShouldFaceMotion()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldHoldGroundAgainstEnemy", `Return true if enemy is within pathEnemyFightDist.`, "actor", [], true, false, `if( behaviorTreeEntity ShouldHoldGroundAgainstEnemy() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldStartArrival", `returns true/false if actor should start arriving at given node`, "actor", [], true, false, `self ShouldStartArrival()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldStartTraversal", `returns true/false if actor should start traversal`, "actor", [], true, false, `self ShouldStartTraversal()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShouldUseCoverNode", `returns true/false if actor is at is safe at cover node and use it as a cover`, "actor", [], true, false, `self ShouldUseCoverNode()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartCoverArrival", `Runs cover arrival animscript on an actor.`, "actor", [new LibraryFunctionParameter("start pos", `the offset to start the arrival animation from`, true), new LibraryFunctionParameter("yaw angles", `the arrival angle`, true)], true, false, `soldier StartCoverArrival( pos, 45 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Teleport", `Teleport the actor to a new position with the given origin and angles.`, "actor", [new LibraryFunctionParameter("position", `(point) The actor's new position.`, true), new LibraryFunctionParameter("angles", `(vector) The actor's new angles.`, false)], true, false, `self Teleport( org, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ThreatBiasGroupExists", `Check if a threat bias group exists`, null, [new LibraryFunctionParameter("name", `threat bias group name.`, true)], true, false, `ThreatBiasGroupExists( "flanking_team" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TraverseMode", `Set the traverse mode of this actor.`, "actor", [new LibraryFunctionParameter("traverse mode", `(const string) Possible traverse modes are 'gravity', 'nogravity', or 'noclip'`, true)], true, false, `self TraverseMode( "nogravity" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TrimPathtoAttack", `Trims the path to attack.`, "actor", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseCoverNode", `Tells this actor to use the given cover node. This is invalid if the actor's keepclaimednode flag is set. Returns true or false depending on whether the actor can claim the node.`, "actor", [new LibraryFunctionParameter("path node", `The path node to use as cover`, true)], true, false, `guy UseCoverNode( covernode )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UsePosition", `Override where the actor should run to. This overrides the goal pos and the claimed node.`, "actor", [new LibraryFunctionParameter("position", `The position for the actor to run to.`, true), new LibraryFunctionParameter("arrivalfinalposition", `The arrivalfinalposition if this is an arrival.`, false)], true, false, `self UsePosition( pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseReacquireNode", `Use the given reacquire node.`, "actor", [new LibraryFunctionParameter("node", `(path node) the node to use.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddBoltedFXExclusionVolume", `Create a bolted volume that will exclude FX that are flagged as "Respect Exclusion Volumes". Returns volume ID.`, null, [new LibraryFunctionParameter("localClientNum", `The local client to create the volume on.`, true), new LibraryFunctionParameter("entity", `The entity to attach the volume to.`, true), new LibraryFunctionParameter("tag name", `The tag to use as the volume's origin.`, true), new LibraryFunctionParameter("half extents", `The half extents of the volume.`, true), new LibraryFunctionParameter("offset", `An offset from the tag name for the volume's origin; default is 0 0 0.`, false)], false, true, `volumeID = AddBoltedFXExclusionVolume( 0, entity, tag_origin, (10, 10, 10) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddDuplicateRenderOption", `Add a duplicate render option for the entity`, "entity", [new LibraryFunctionParameter("dupeType", `this is one of [DR_TYPE_FRAMEBUFFER|DR_TYPE_FRAMEBUFFER_DUPLICATE|DR_TYPE_OFFSCREEN], as defined in _duplicaterender.csc. Sets the duplicate type of this call`, true), new LibraryFunctionParameter("dupeMethod", `this is one of [DR_CULL_ALWAYS|DR_CULL_NEVER], as defined in _duplicaterender.csc. Sets the render method of this call`, true), new LibraryFunctionParameter("mappedMaterialId", `This is the mapped material id`, false), new LibraryFunctionParameter("dupeCull", `this is one of [DR_METHOD_OFF|DR_METHOD_DEFAULT_MATERIAL|DR_METHOD_THERMAL_MATERIAL|DR_METHOD_CUSTOM_MATERIAL|DR_METHOD_FORCE_CUSTOM_MATERIAL], as defined in _duplicaterender.csc. Sets the render method of this call`, false)], false, true, `myEnt AddDuplicateRenderOption( DR_TYPE_FRAMEBUFFER, DR_METHOD_THERMAL_MATERIAL, DR_CULL_ALWAYS )myEnt AddDuplicateRenderOption( DR_TYPE_OFFSCREEN, DR_METHOD_CUSTOM_MATERIAL, DR_CULL_NEVER, mapped_material_id(player,"gfx_my_material_2") )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddFXExclusionVolume", `Create a volume that will exclude FX that are flagged as "Respect Exclusion Volumes". Returns volume ID.`, null, [new LibraryFunctionParameter("localClientNum", `The local client to create the volume on.`, true), new LibraryFunctionParameter("center", `The center of the volume.`, true), new LibraryFunctionParameter("angles", `The rotation angles of the volume.`, true), new LibraryFunctionParameter("half extents", `The half extents of the volume.`, true)], false, true, `volumeID = AddFXExclusionVolume( 0, (0,0,0), (0, 45, 0), (10, 10, 10) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeamKill", `Kill the previously launched beam.`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the beam`, true), new LibraryFunctionParameter("beam handle", `The beam handle`, true)], false, true, `BeamKill(0, beamHandle)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeamLaunch", `Launch this beam and return the internal handle.`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the beam`, true), new LibraryFunctionParameter("entity from", `The originating entity`, true), new LibraryFunctionParameter("tag from", `The tag on the originating entity to start from`, true), new LibraryFunctionParameter("entity to", `The target entity`, true), new LibraryFunctionParameter("tag to", `The target tag`, true), new LibraryFunctionParameter("beam", `The beam`, true)], false, true, `handle = BeamLaunch(0, launcher, launcherTag, target, targetTag, beam)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BulletTracer", `creates a bullet tracer from the start to end point`, null, [new LibraryFunctionParameter("start", `The starting point bullet tracer`, true), new LibraryFunctionParameter("end", `The end point bullet tracer`, true)], false, true, `BulletTracer(self.origin, target.origin)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CaptureFrame", `Captures the current frame into the given code image - he image had to be already created with CreateSceneCodeImage()`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("name", `The code image name`, true)], false, true, `CaptureFrame( self.localClientNum, "freezeFrame" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearExtraCam", `Finds the extracam associated with an entity and removes it`, null, [], false, true, `cameraEnt ClearExtraCam()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("codeplaypostfxbundle", `Displays a postfx on the screen `, "entity", [], false, true, `entity PlayPostfxBundle( "myBundle" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("codestoppostfxbundle", `Ends a postfx `, "entity", [], false, true, `entity StopPostfxBundle( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateSceneCodeImage", `Creates a scene size code image`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("name", `A unique name`, true)], false, true, `CreateSceneCodeImage( self.localClientNum, "freezeFrame" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeleteFX", `Delete a spawned effect.`, null, [new LibraryFunctionParameter("localClientNum", `client on which to spawn effect.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by spawnfx`, true), new LibraryFunctionParameter("deleteImmediate", `whether effect will be deleted immediately. Default is 1.`, false)], false, true, `deletefx (0, fxRef)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableDuplicateRendering", `Disables duplicate rendering for the entity`, "entity", [], false, true, `entity DisableDuplicateRendering()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableFrontendLockedWeaponOverlay", `Enable or disable the draw of the locked gun postfx in script.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("enable", `0-disable 1-enable`, true)], false, true, `entity EnableFrontendLockedWeaponOverlay( 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableFrontendStreamingOverlay", `Enable or disable the draw of an alternate draw mode for high detail entities marked to use alt draw`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("enable", `0-disable 1-enable`, true), new LibraryFunctionParameter("extracam", `0-disable 1-enable - when enabled the overlay is drawn on extracam`, false)], false, true, `entity EnableFrontendStreamingOverlay( 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableFrontendTokenLockedWeaponOverlay", `Enable or disable the draw of the purchaseable gun postfx in script.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("enable", `0-disable 1-enable`, true)], false, true, `entity EnableFrontendTokenLockedWeaponOverlay( 0, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableThermalDraw", `Enables or disables the drawing entities into the thermal buffer`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("enable", `true/false`, true)], false, true, `EnableThermalDraw( player.localClientNum, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EVEnable", `Enable or disable ev mode`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity EVEnable( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EvStatus", `returns the status of EV`, null, [new LibraryFunctionParameter("localClientNum", `Local client to find the status of`, true)], false, true, `status = EVStatus( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindStaticModelIndex", `Returns an index of a static model whose origin matches the passed in position`, null, [new LibraryFunctionParameter("vector pos", `The position to match to the static model origin or <string targetname> for the targetname of the static model`, true)], false, true, `smodelIndex = FindStaticModelIndex()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindStaticModelIndexArray", `Returns an array indices of a static model whose name matches the passed in string`, null, [new LibraryFunctionParameter("string targetname", `The targetname of the static model's`, true)], false, true, `smodelIndexArray = FindStaticModelIndex()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FindVolumeDecalIndexArray", `Returns an array indices of a volume decal whose targetname matches the passed in string`, null, [new LibraryFunctionParameter("string targetname", `The targetname of the volume decal`, true)], false, true, `vdIndexArray = FindVolumeDecalIndexArray( "foo" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FreeCodeImage", `Frees a code image`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("name", `A unique name`, true)], false, true, `FreeCodeImage( self.localClientNum, "freezeFrame" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCameraSpikeCamStatic", `Returns 1 if a client sees static on the camera-spike cam, 0 otherwise`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the camera-spike cam owner`, true)], false, true, `GetCameraSpikeCamStatic( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFXFromSurfaceTable", `Returns the fx for a given surface type from the surfacefxtable.`, null, [new LibraryFunctionParameter("surfacefxtable", `Surface fx table.`, true), new LibraryFunctionParameter("surface type", `Surface type`, true)], false, true, `fx = GetFXFromSurfaceTable( fx_surface_table, surface_type )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetServerVolumetricFogDensity", `Get the density of server volumetric fog`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSurfaceStrings", `Returns an array containing all the surface names`, null, [], false, true, `surfaceStringArray = GetSurfaceStrings()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVisionSetNaked", `Gets players' naked vision.`, null, [new LibraryFunctionParameter("localClientNum", `The local client which will have his vampire vision set changed`, true)], false, true, `GetVisionSetNaked( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWorldFogScriptID", `current active .fsi fog volumes script identity value -1 = global volume.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideStaticModel", `Hide a static model`, null, [new LibraryFunctionParameter("smodelIndex", `The index of the static model to toggle`, true)], false, true, `HideStaticModel( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideVolumeDecal", `Hide a static model`, null, [new LibraryFunctionParameter("volume decal Index", `The index of the volume decal to toggle`, true)], false, true, `HideStaticModel( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IGCActive", `Flags if an IGC is on or off`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which the igc is running`, true), new LibraryFunctionParameter("enable", `1-enables, 0-disables`, true)], false, true, `IGCActive( 1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFXPlaying", `Return true if effect is still playing.`, null, [new LibraryFunctionParameter("localClientNum", `The local client the effect is playing on.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by playFx`, true)], false, true, `IsFXPlaying ( fxId )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsIGCActive", `returns the status of EV`, null, [new LibraryFunctionParameter("localClientNum", `Local client to find the status of`, true)], false, true, `status = IsIGCActive( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStereoOn", `Returns true if the stereo is on`, null, [], false, true, `isStereo = IsStereoOn()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("KillFX", `Force kills a given fx.`, null, [new LibraryFunctionParameter("localClientNum", `The local client the effect is playing on.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by playFx`, true)], false, true, `KillFX ( fxId )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("KillRadiantExploder", `Kill the specified Radiant exploder`, null, [new LibraryFunctionParameter("localClientNum", `The local client to play the effect on`, true), new LibraryFunctionParameter("exploderId", `The id of the exploder to be stopped.`, true)], false, true, `KillRadiantExploder( 0, "lights_on_exploder" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeLight", `Create a light`, "entity", [new LibraryFunctionParameter("primaryLightIndex", `The Primary Light Index`, true)], false, true, `self MakeLight(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MapMaterialIndex", `Maps the material to an index`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to map the material`, true), new LibraryFunctionParameter("materialName", `Material to map`, true)], false, true, `index = MapMaterial(1, "mymaterial")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_Enable", `Enable or disable the sitrep scan`, "entity", [new LibraryFunctionParameter("enable", `true to enable /false to disable`, true)], false, true, `entity motionpulse_enable( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetDesat", `Set the motion pulse desaturation level`, "entity", [new LibraryFunctionParameter("level", `The desat level (float)`, true)], false, true, `entity motionpulse_setdesat( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetFadeOut", `Set the motion pulse fadeout`, "entity", [new LibraryFunctionParameter("fadeout", `The fadeout (float)`, true)], false, true, `entity MotionPulse_SetFadeOut( fadeout )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetFalloff", `Set the motion pulse falloff`, "entity", [new LibraryFunctionParameter("falloff", `the falloff (float)`, true)], false, true, `entity motionpulse_setfalloff( falloff )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetLineWidth", `Set the motion pulse line width`, "entity", [new LibraryFunctionParameter("linewidth", `the line width (float)`, true)], false, true, `entity motionpulse_setlinewidth( linewidth )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetOutline", `Set the motion pulse outline level`, "entity", [new LibraryFunctionParameter("outlinelevel", `the outline level (float)`, true)], false, true, `entity motionpulse_setoutline( outlinelevel )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetRadius", `Set the motion pulse radius`, "entity", [new LibraryFunctionParameter("radius", `the radius (float)`, true)], false, true, `entity motionpulse_setradius( radius )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MotionPulse_SetSolid", `Set the motion pulse solid level`, "entity", [new LibraryFunctionParameter("level", `The solid level (float)`, true)], false, true, `entity motionpulse_setsolid( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_NightVision_Enable", `undefined`, "entity", [new LibraryFunctionParameter("enable", `true/false`, true)], false, true, `entity oed_nightvision_enable( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_NightVision_Reset", `Reset nightvision for entity`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity oed_nightvision_reset()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_NightVision_SetTextureLevel", `Set the night vision texture level for the entity`, "entity", [new LibraryFunctionParameter("level", `The texture level (float)`, true)], false, true, `entity oed_nightvision_settexturelevel( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_Enable", `Enable or disable the sitrep scan`, "entity", [new LibraryFunctionParameter("type", `0-disable 1-typeA 2-typeB`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitpepscan_enable( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetDesat", `Set the desaturation level for the sitrep scan`, "entity", [new LibraryFunctionParameter("level", `the desat level (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setdesat( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetFalloff", `Set the falloff for the sitrep scan`, "entity", [new LibraryFunctionParameter("falloff", `The falloff (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setfalloff( falloff )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetLineWidth", `Set the line width for the sitrep scan`, "entity", [new LibraryFunctionParameter("linewidth", `The line width (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setlinewidth( linewidth )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetOutline", `Set the outline level for the sitrep scan`, "entity", [new LibraryFunctionParameter("outlinelevel", `The outline level (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setoutline( outlinelevel )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetRadius", `Set the radius for the sitrep scan`, "entity", [new LibraryFunctionParameter("radius", `The radius (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setradius( radius )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OED_SitRepScan_SetSolid", `Set the solid level for the sitrep scan`, "entity", [new LibraryFunctionParameter("level", `the solid level (float)`, true), new LibraryFunctionParameter("AlphaType", `0-default 1-Alpha ( 0 by default )`, false)], false, true, `entity oed_sitrepscan_setsolid( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayExtraCamXCam", `Plays an XCam on the extra cam associated with the entity starting at the current client time`, null, [new LibraryFunctionParameter("xcam name", `The name of the xcam asset to play`, true), new LibraryFunctionParameter("lerp_duration", `The duration to lerp the start of the xcam over`, false), new LibraryFunctionParameter("camera_name", `The name of the sub camera from the XCam to play`, false), new LibraryFunctionParameter("animation_name", `The name of the frame (notetrack) to play`, false), new LibraryFunctionParameter("origin", `Base origin for the camera`, false), new LibraryFunctionParameter("angles", `Base angles for the camera`, false), new LibraryFunctionParameter("target", `If this xcam has model translation and rotation data, apply it to this entity.`, false)], false, true, `cameraEnt PlayExtraCamXCam( "ui_cam_ar_standard" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayFXOnDynEnt", `Play this effect and return the internal handle.`, null, [new LibraryFunctionParameter("effect id", `The effect id returned by loadfx`, true), new LibraryFunctionParameter("dynent", `The dyn entity to play the effect on`, true)], false, true, `handle = PlayFXOnDynEnt( spark, lamp )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayMainCamXCam", `Plays an XCam on the main camera associated with the player starting at the current client time`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true), new LibraryFunctionParameter("xcam name", `The name of the xcam asset to play`, true), new LibraryFunctionParameter("lerp_duration", `The duration to lerp the start of the xcam over`, false), new LibraryFunctionParameter("camera_name", `The name of the sub camera from the XCam to play`, false), new LibraryFunctionParameter("animation_name", `The name of the frame (notetrack) to play`, false), new LibraryFunctionParameter("origin", `Base origin for the camera`, false), new LibraryFunctionParameter("angles", `Base angles for the camera`, false), new LibraryFunctionParameter("target", `If this xcam has model translation and rotation data, apply it to this entity.`, false)], false, true, `PlayMainCamXCam( localClientNum, "ui_cam_ar_standard" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRadiantExploder", `Play the specified Radiant exploder`, null, [new LibraryFunctionParameter("localClientNum", `The local client to play the effect on`, true), new LibraryFunctionParameter("exploderId", `The id of the exploder to be triggered.`, true)], false, true, `PlayRadiantExploder( 0, "lights_on_exploder" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayRenderOverrideBundle", `Applys a render override bundle to an entitys model `, "entity", [], false, true, `entity PlayRenderOverrideBundle( "myBundle" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayTagFXSet", `Play a tagfx set on ajn entity. Do not specify loop fx`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the fx`, true), new LibraryFunctionParameter("tagfxset", `The string name of the tag fx set`, true), new LibraryFunctionParameter("entity", `The entity to play the effect on`, true)], false, true, `PlayTagFXSet ( 0, self, smoke )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayViewmodelFX", `undefined`, null, [new LibraryFunctionParameter("local_client_num", `The client number`, true), new LibraryFunctionParameter("name", `The name of the fx`, true), new LibraryFunctionParameter("tag", `The tag to play on`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RandomFade", `Fade the level randomly`, "entity", [new LibraryFunctionParameter("level", `0 to disable, any other value to enable (float)`, true)], false, true, `entity randomfade( level )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RegisterRewindFX", `Registers an fx with the killcam rewind system`, null, [new LibraryFunctionParameter("local_client_num", `The client number`, true), new LibraryFunctionParameter("name", `The name of the fx`, true)], false, true, `RegisterRewindFX(local_client_num, "fxName")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoveFXExclusionVolume", `Removes the given exclusion volume.`, null, [new LibraryFunctionParameter("localClientNum", `The local client to remove the volume from.`, true), new LibraryFunctionParameter("volumeID", `The volume to remove.`, true)], false, true, `RemoveFXExclusionVolume( 0, volumeID )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAllowXCamRightStickRotation", `Prevent or stop preventing right stick rotation on this xcam (the next playmaincamxcam resets this)`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true), new LibraryFunctionParameter("newValue", `True to allow, False, to disable right stick rotation`, true)], false, true, `SetAllowXCamRightStickRotation( 0, false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetArmPulse", `Sets arm pulse override values`, "entity", [], false, true, `entity SetArmPulse( 2.0, 4, 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetArmPulsePosition", `Sets arm pulse override values`, "entity", [], false, true, `entity SetArmPulsePosition( 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeCamActive", `Sets whether a client's camera-spike cam is active.`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the extra cam owner`, true), new LibraryFunctionParameter("active", `0 if inactive, 1 if active`, true)], false, true, `SetCameraSpikeCamActive( localClientNum, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeCamAngles", `Sets the orientation of a client's extra cam.`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the camera-spike cam owner`, true), new LibraryFunctionParameter("angles", `New pitch, yaw, and roll of the camera-spike cam`, true)], false, true, `SetCameraSpikeCamAngles( localClientNum, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeCamEntity", `Sets an camera-spike cam entity for the client.`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the extra cam owner`, true), new LibraryFunctionParameter("entity", `Camera entity, or undefined`, true)], false, true, `CScr_SetCameraSpikeCamEntity( localClientNum, cameraSpike )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeCamOrigin", `Sets the origin of a client's camera-spike cam`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the camera-spike cam owner`, true), new LibraryFunctionParameter("origin", `New origin of the camera-spike cam`, true)], false, true, `SetCameraSpikeCamOrigin( localClientNum, origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCameraSpikeCamStatic", `Sets whether a client sees static on the camera-spike cam`, null, [new LibraryFunctionParameter("localClientNum", `Client number of the camera-spike cam owner`, true), new LibraryFunctionParameter("active", `0 if inactive, 1 if active`, true)], false, true, `SetCameraSpikeCamStatic( localClientNum, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientVolumetricFog", `Set the client volumetric fog properties`, null, [new LibraryFunctionParameter("startDist", `The start distance of the volume`, true), new LibraryFunctionParameter("halfwayDist", `The halfway distance of the volume`, true), new LibraryFunctionParameter("halfwayHeight", `The halfway height of the volume`, true), new LibraryFunctionParameter("baseHeight", `The base height of the volume`, true), new LibraryFunctionParameter("red", `The red value`, true), new LibraryFunctionParameter("green", `The green value`, true), new LibraryFunctionParameter("blue", `The blue value`, true), new LibraryFunctionParameter("fogColorScale", `The color scale of the fog`, true), new LibraryFunctionParameter("sunFogColorR", `The sun fog red value`, false), new LibraryFunctionParameter("sunFogColorG", `The sun fog green value`, false), new LibraryFunctionParameter("sunFogColorB", `The sun fog blue value`, false), new LibraryFunctionParameter("sunFogDirX", `The sun direction X value`, false), new LibraryFunctionParameter("sunFogDirY", `The sun direction Y value`, false), new LibraryFunctionParameter("sunFogDirZ", `The sun direction Z value`, false), new LibraryFunctionParameter("sunFogStartAng", `Angle from the sun position where the sun fades in`, false), new LibraryFunctionParameter("sunFogEndAng", `Angle from the sun position where the sun has faded out`, false), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("fogMaxOpacity", `The maximum opacity of the fog as a value between 0 and 1`, false)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExposureActiveBank", `Set exposure volumes active bank bit mask.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("bank mask", `The new bank mask`, true)], false, true, `SetExposureActiveBank( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExposureIgnoreTeleport", `Always do fully adaptive exposure and ignore teleports`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("enable", `Enable or disable the exposure always adapt flag`, true)], false, true, `SetExposureIgnoreTeleport( localClientNum, newVal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExposureInstantSnap", `snap exposure to base calculated probe value, ignore iris adaption and damping`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("enable", `Enable or disable the exposure snap`, true)], false, true, `SetExposureInstantSnap( localClientNum, newVal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExtraCam", `Activates the extra cam and sets the given entity as cam reference.`, null, [new LibraryFunctionParameter("camera index", `which extra cam references this entity. Valid values are 0 - 3`, true), new LibraryFunctionParameter("rendered width", `Width of the extra cam rendered target. The width will be calculated from the height if width is negative (keeping the aspect ration at 16:9)`, false), new LibraryFunctionParameter("rendered height", `Height of the extra cam rendered target. The height will be calculated from the width if height is negative (keeping the aspect ration at 16:9)`, false)], false, true, `cameraEnt SetExtraCam( 1, 640, 480 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExtraCamFocalLength", `Sets the extra cam fov`, null, [new LibraryFunctionParameter("camera index", `which extra cam references this entity. Valid values are 0 - 3`, true), new LibraryFunctionParameter("fov", `camera fov`, true)], false, true, `cameraEnt SetExtraCamFOV( 1, 65 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterBitFlag", `Set or clear the filter bit flag`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("bitIndex", `Must be between 0 - 31`, true), new LibraryFunctionParameter("setOrClear", `Must be between 0 - 1`, true)], false, true, `SetFilterBitFlag( self.localClientNum, 1, 10 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterPassCodeTexture", `Sets a code texture for a filter pass - the tetxure has be to created beforehand`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("passIndex", `Must be between 0 - 15`, true), new LibraryFunctionParameter("texture Index", `Must be between 0 - 1`, true), new LibraryFunctionParameter("texture name", `has to have been created by captureFrame() before - if empty string sets to null.`, true)], false, true, `SetFilterPassMaterial( self.localClientNum, 1, 12, 0, "myBundle")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterPassConstant", `Sets the filter pass constant`, null, [new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("passIndex", `Must be between 0 - 16`, true), new LibraryFunctionParameter("constantIndex", `Must be between 0 - 16`, true), new LibraryFunctionParameter("value", `The value for the constant`, true)], false, true, `SetFilterPassConstant( self.localClientNum, 1, 12, 12, 2.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterPassEnabled", `Sets the filter pass enabled or disabled`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("passIndex", `Must be between 0 - 16`, true), new LibraryFunctionParameter("passEnable", `true/false`, true), new LibraryFunctionParameter("hdrFilter", `] true/false - if true the filter is applied to the scene (HDR) otherwise will be applied after the LDT and dof (default false)`, false), new LibraryFunctionParameter("firstPersonOnly", `] true/false - if true the filter is applied to the scene only if you are in or spectating a player in first person`, false)], false, true, `SetFilterPassEnabled( self.localClientNum, 1, 12, false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterPassMaterial", `Sets the filter pass material`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("passIndex", `Must be between 0 - 15`, true), new LibraryFunctionParameter("materialIndex", `Must be between 0 - 63`, true)], false, true, `SetFilterPassMaterial( self.localClientNum, 1, 12, 20 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFilterPassQuads", `Sets the filter pass quads`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("filterIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("passIndex", `Must be between 0 - 16`, true), new LibraryFunctionParameter("passQuads", `Must be between 0 - 2048`, true)], false, true, `SetFilterPassQuads( self.localClientNum, 1, 12, 200)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFXIgnorePause", `Tells an effect whether or not to respect a paused world state.`, null, [new LibraryFunctionParameter("localClientNum", `The local client the effect is playing on.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by playFx`, true), new LibraryFunctionParameter("ignore pause", `Whether or not to respect a paused world state.`, true)], false, true, `SetFXIgnorePause( localClientNum, fxId, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFXOutdoor", `Flag the FX as one that only plays outdoors.`, null, [new LibraryFunctionParameter("localClientNum", `The local client the effect is playing on.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by playFx`, true)], false, true, `SetFXOutdoor( fxId )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetFXTeam", `Set the team of the fx either by team or by entity which has a team set.`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the fx`, true), new LibraryFunctionParameter("effect handle ", `The handle from the created fx`, true), new LibraryFunctionParameter("entity or team", `The team`, true), new LibraryFunctionParameter("invert team", `Treat the team as the one to show the enemy fx for.`, false)], false, true, `handle = SetFXTeam(localClientNum, fxHandle, owner)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGenericSceneValue", `Sets one of the 16 generic scene vectors used by SW shaders.`, null, [new LibraryFunctionParameter("localClientNum", `Local client number.`, true), new LibraryFunctionParameter("index", `The scene vector index ( 0 - 15 )`, true), new LibraryFunctionParameter("value", `Some generic float used by SW shaders.`, true)], false, true, `SetGenericSceneValue(0, 20)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHotZone", `Sets HotZone control values`, "entity", [], false, true, `entity SetHotZone( 100, 1000, 5.0, 3.0, 0.5, 50  )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLitFogBank", `Sets which bank to use for all lit fog volumes with matching script id`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true), new LibraryFunctionParameter("scriptid", `Volume identifier set in Radiant. (0-255). -1 = all.`, true), new LibraryFunctionParameter("bank", `Bank selection (0-3).`, true), new LibraryFunctionParameter("time", `Time in seconds to make the transition over. -1 to use the 'fogtime' parameter set in the volume.`, true)], false, true, `SetLitFogBank( 0, 1, 5.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLutScriptIndex", `Set lut index from script.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("lut index", `The lut index`, true)], false, true, `SetLutScriptIndex( lcn, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLutVolumeActiveBank", `Set lut volumes active bank bit mask.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("bank mask", `The new bank mask`, true)], false, true, `SetLutVolumeActiveBank( localClientNum, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOverlayConstant", `Set the overlay constant`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("overlayIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("constantIndex", `Must be between 0 - 16`, true), new LibraryFunctionParameter("value", `The value to set`, true)], false, true, `SetOverlayConstant( self.lcoalClientNum, 2, 5, 1.4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOverlayEnabled", `Enables or disables the overlay`, null, [new LibraryFunctionParameter("overlayIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("enable", `true/false`, true)], false, true, `SetOverlayEnabled( self.localClientNum, 2, false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOverlayMaterial", `Set the overlay material`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("overlayIndex", `Must be between 0 - 3`, true), new LibraryFunctionParameter("materialIndex", `Must be between 0 - 63`, true), new LibraryFunctionParameter("sortIndex", `Must be between 0 - 2`, true)], false, true, `SetOverlayMaterial( self.localClientNum, 2, 20, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPBGActiveBank", `Set PBG bank mask from script.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("bank mask", `The bank bit mask`, true)], false, true, `SetPBGActiveBank( lcn, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRimIntensity", `Global character skin/cloth rim lighting intensity.`, null, [new LibraryFunctionParameter("localClientNum", `Local client number.`, true), new LibraryFunctionParameter("rimIntensity", `Character skin/cloth rim intensity.`, true)], false, true, `SetRimIntensity(0, 20)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRippleWave", `Trigger vertex ripple wave for material set to use it.`, null, [new LibraryFunctionParameter("client", `The local client`, true), new LibraryFunctionParameter("center xpos", `The x coord`, true), new LibraryFunctionParameter("center ypos", `The y coord`, true), new LibraryFunctionParameter("width", `The width of the wave`, true), new LibraryFunctionParameter("speed scale", `The speed modifier`, true), new LibraryFunctionParameter("amplitude width ratio", `The amplitude`, true), new LibraryFunctionParameter("fade in start", `The fade in at start`, true), new LibraryFunctionParameter("fade in end", `The fade in at the end`, true), new LibraryFunctionParameter("fade out start", `The fade out at start`, true), new LibraryFunctionParameter("fade out end", `The fade out at the end`, true)], false, true, `setripplewave( 0, 100.0, 100.0, 200.0, 1.0, 1.0, 0.0, 250.0, 1000.0, 1500.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetServerVolumetricFogDensity", `Set the density of server volumetric fog`, null, [new LibraryFunctionParameter("localClientNum", `The local client number`, true), new LibraryFunctionParameter("density", `The density to set`, true), new LibraryFunctionParameter("time", `The time to lerp to the new value`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetUkkoScriptIndex", `Set ukko index from script.`, null, [new LibraryFunctionParameter("localClientNum", `the local client`, true), new LibraryFunctionParameter("ukko index", `The ukko index`, true), new LibraryFunctionParameter("ukko blend", `The ukko index blend amount`, true)], false, true, `SetUkkoScriptIndex( lcn, 2, 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartWaterSheetingFX", `Play a fullscreen water effect.`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the fx`, true), new LibraryFunctionParameter("duration", `The number of seconds to play the fx before it stops automatically. Use 0 for infinite time. Defaults to 0.`, false), new LibraryFunctionParameter("magnitude", `default is from a dvar (r_waterSheetingFX_magnitude)`, false)], false, true, `StartWaterSheetingFX(localClientNum, 8)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopExtraCamXCam", `Stops an XCam on the extra cam associated with the entity`, null, [], false, true, `cameraEnt StopExtraCamXCam()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopFX", `Stops a given fx.`, null, [new LibraryFunctionParameter("localClientNum", `The local client the effect is playing on.`, true), new LibraryFunctionParameter("effect id", `The effect id returned by playFx`, true)], false, true, `StopFX ( fxId )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopMainCamXCam", `Stops an XCam on the main cam associated with the entity`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true)], false, true, `StopMainCamXCam( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopRadiantExploder", `Stop the specified Radiant exploder`, null, [new LibraryFunctionParameter("localClientNum", `The local client to play the effect on`, true), new LibraryFunctionParameter("exploderId", `The id of the exploder to be stopped.`, true)], false, true, `StopRadiantExploder( 0, "lights_on_exploder" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopRenderOverrideBundle", `Ends a Render Override Bundle`, "entity", [], false, true, `entity StopRenderOverrideBundle()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopWaterSheetingFX", `Stop the fullscreen water effect`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to play the fx`, true), new LibraryFunctionParameter("duration", `The number of seconds it takes the effect to fade. Use 0 for immediate turn off. Defaults to 0.`, false)], false, true, `StopWaterSheetingFX( localClientNum, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchToClientVolumetricFog", `Switch to the client volumetric fog`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchToServerVolumetricFog", `Switch to the server volumetric fog`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TmodeClearFlag", `Clears flag bit for tmode.`, "entity", [], false, true, `entity TmodeClearFlag( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TmodeEnable", `Enable or disable tactical mode`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity TmodeEnable( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TmodeSetFlag", `Sets flag bit for tmode.`, "entity", [], false, true, `entity TmodeSetFlag( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TmodeStatus", `returns the status of tmode`, null, [new LibraryFunctionParameter("localClientNum", `Local client to find the status of`, true)], false, true, `status = TmodeStatus( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("umbra_clearpersistenttometrigger", `clears the current tome trigger that persisted due to touching a prior tome trigger`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `umbra_clearpersistenttometrigger( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Umbra_SetAccurateOcclusionThreshold", `Set Umbra Accurate Occlusion Threshold parameter`, null, [], false, true, `Umbra_SetAccurateOcclusionThreshold( localClientNum, 2048 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Umbra_SetDistanceScale", `Set Umbra Distance Scale parameter`, null, [], false, true, `Umbra_SetDistanceScale( localClientNum, 2.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Umbra_SetMinimumContributionThreshold", `Set Umbra Accurate Occlusion Threshold parameter`, null, [], false, true, `Umbra_SetAccurateOcclusionThreshold( localClientNum, 8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("umbra_settometrigger", `Sets current active tome trigger`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("tometrigger name", `name of a tome trigger. Use empty string "" to deactivate tome triggers`, true)], false, true, `Umbra_SetTomeTrigger( localClientNum, "my_really_cool_tome_trigger" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("umbra_settometriggeronce", `Set the active tome trigger without interferring with any other tome logic.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("tometrigger name", `name of a tome trigger. Use empty string "" to deactivate tome triggers`, true)], false, true, `Umbra_SetTomeTriggerOnce( localClientNum, "my_really_cool_tome_trigger" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnhideStaticModel", `Unhide a static model`, null, [new LibraryFunctionParameter("smodelIndex", `The index of the static model to toggle`, true)], false, true, `UnhideStaticModel( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnhideVolumeDecal", `Unhide a static model`, null, [new LibraryFunctionParameter("volume decal Index", `The index of the volume decal to toggle`, true)], false, true, `UnhideStaticModel( model )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VisionSetLastStandLerp", `Sets players' last stand vision.  Optionally give a transition time from the current vision.`, null, [new LibraryFunctionParameter("localClientNum", `The local client which will have his vampire vision set changed`, true), new LibraryFunctionParameter("vision name to", `Vision to transition to.`, true), new LibraryFunctionParameter("vision name from", `Vision to transition from.`, true), new LibraryFunctionParameter("lerp fraction", `The lerp fraction to use when transitioning to the new vision set if a transition is possible.  Default is one second.`, true)], false, true, `VisionSetLastStandLerp( localClientNum, curr_info.visionset_to, curr_info.visionset_from, state.curr_lerp )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VisionSetNakedLerp", `Sets players' naked vision.  Optionally give a transition time from the current vision.`, null, [new LibraryFunctionParameter("localClientNum", `The local client which will have his vampire vision set changed`, true), new LibraryFunctionParameter("vision name to", `Vision to transition to.`, true), new LibraryFunctionParameter("vision name from", `Vision to transition from.`, true), new LibraryFunctionParameter("lerp fraction", `The lerp fraction to use when transitioning to the new vision set if a transition is possible.  Default is one second.`, true)], false, true, `VisionSetNakedLerp( localClientNum, curr_info.visionset_to, curr_info.visionset_from, state.curr_lerp )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeakPoint_Enable", `Enable or disable the weakpoint fx`, "entity", [new LibraryFunctionParameter("undefined", `undefined`, undefined)], false, true, `entity weakpoint_enable( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ZombieShooterSpotted", `Enables the Zombie Shooter Spotted HUD display`, null, [new LibraryFunctionParameter("localClientNum", `Local client on which to map the material`, true), new LibraryFunctionParameter("enable", `1-enables, 0-disables`, true)], false, true, `ZombieShooterSpotted(1, 1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Abs", `Returns the absolute value of a float`, null, [new LibraryFunctionParameter("value", `A float or integer value.`, true)], true, true, `x = Abs( x )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AbsAngleClamp180", `Returns abs angle value clamped between [0,180].`, null, [new LibraryFunctionParameter("angles", `Angle to be clamped`, true)], true, true, `deltaAngle = AbsAngleClamp180( currentAngle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AbsAngleClamp360", `Returns <angle> as a value in the range of 0 and 360 degrees.`, null, [new LibraryFunctionParameter("angle", `An angle.`, true)], true, true, `new_angle = AbsAngleClamp360( boatAngles[2] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ACos", `Returns an angle corresponding to a particular cosine value`, null, [new LibraryFunctionParameter("cos value", `A cosine value`, true)], true, true, `upAngle = ACos( distanceratio )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AngleClamp180", `Returns angle value clamped between [-180,180].`, null, [new LibraryFunctionParameter("angles", `Angle to be clamped`, true)], true, true, `deltaAngle = AngleClamp180( currentAngle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AngleLerp", `Returns <angle> lerped angle value.`, null, [new LibraryFunctionParameter("from", `An angle.`, true), new LibraryFunctionParameter("to", `An angle.`, true), new LibraryFunctionParameter("fraction", `A float from 0-1.`, true)], true, true, `180 = AngleLerp( 0, 360, 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnglesToForward", `Returns the forward vector corresponding to a set of angles.`, null, [new LibraryFunctionParameter("angles", `A set of angles`, true)], true, true, `forward = AnglesToForward( forward )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnglesToRight", `Returns the right vector corresponding to a set of angles.`, null, [new LibraryFunctionParameter("angles", `A set of angles`, true)], true, true, `right = AnglesToRight(angles)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnglesToUp", `Returns the up vector corresponding to a set of angles.`, null, [new LibraryFunctionParameter("angles", `A set of angles`, true)], true, true, `up = AnglesToUp(angles)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ASin", `Returns an angle corresponding to a particular sin value`, null, [new LibraryFunctionParameter("sin value", `A sin value`, true)], true, true, `upAngle = ASin( upAmount )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ATan", `Returns an angle corresponding to a particular tangential value`, null, [new LibraryFunctionParameter("tan value", `A tangential value`, true)], true, true, `upAngle = ATan( height/distance )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Ceil", `Returns the ceiling of floating point value <a>. This effectively rounds up Ceil(2.7) == 3, Ceil(3.9) == 4.`, null, [new LibraryFunctionParameter("a", `A float or integer value.`, true)], true, true, `rounded_down = Floor( val )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Closer", `Tests which of two points is the closest. Returns true if point a is closer to the reference than point b`, null, [new LibraryFunctionParameter("reference", `The base position`, true), new LibraryFunctionParameter("point a", `The first point`, true), new LibraryFunctionParameter("point b", `The second point`, true)], true, true, `if( Closer( center, models[j].origin , models[i].origin ))...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CombineAngles", `Returns angles b reoriented by angles a.`, null, [new LibraryFunctionParameter("angles a", `Angles representing the orientation in which to place <angles b>`, true), new LibraryFunctionParameter("angles b", `Angles which will be reoriented`, true)], true, true, `crateAnglesInWorld = CombineAngles( boatAngles, crateAnglesInBoat )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Cos", `Returns the cos of an angle`, null, [new LibraryFunctionParameter("angle", `An angle in degrees`, true)], true, true, `frac = Cos( degrees )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DiffTrack", `Returns a lagged value between <from> and <to> based on <rate> and <deltaTime>`, null, [new LibraryFunctionParameter("to", `Float, start of the range`, true), new LibraryFunctionParameter("from", `Float, end of the range`, true), new LibraryFunctionParameter("rate", `Floating point`, true), new LibraryFunctionParameter("deltaTime", `Time elapsed`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DiffTrackAngle", `Returns a lagged angle between <from> and <to> based on <rate> and <deltaTime>. Properly accounts for wrapping 2pi`, null, [new LibraryFunctionParameter("to", `Float, start of the range`, true), new LibraryFunctionParameter("from", `Float, end of the range`, true), new LibraryFunctionParameter("rate", `Floating point`, true), new LibraryFunctionParameter("deltaTime", `Time elapsed`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Distance", `Returns the distance between two points`, null, [new LibraryFunctionParameter("point1", `The first point`, true), new LibraryFunctionParameter("point2", `The second point`, true)], true, true, `dist = Distance( org, ai[i].origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Distance2D", `Returns the distance between two points, ignores height difference.`, null, [new LibraryFunctionParameter("point1", `The first point`, true), new LibraryFunctionParameter("point2", `The second point`, true)], true, true, `dist = Distance2D( org, ai[i].origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Distance2DSquared", `Returns the squared distance between two points, ignores height difference.`, null, [new LibraryFunctionParameter("point1", `The first point`, true), new LibraryFunctionParameter("point2", `The second point`, true)], true, true, `distsq = Distance2DSquared( org, ai[i].origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DistanceSquared", `Returns the squared distance between two points - this is cheaper than the actual distance as it doesn't involve a square root`, null, [new LibraryFunctionParameter("point1", `The first point`, true), new LibraryFunctionParameter("point2", `The second point`, true)], true, true, `dist2 = DistanceSquared(models[j].origin, center)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Float", `Casts a string or an integer to a float`, null, [new LibraryFunctionParameter("value", `A string or integer number to cast to a float`, true)], true, true, `x = Float( floatValString )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Floor", `Returns the floor of floating point value <a>. This effectively rounds down Floor(2.7) == 2, Floor(3.9) == 3.`, null, [new LibraryFunctionParameter("a", `A float or integer value.`, true)], true, true, `rounded_down = Floor( val )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForwardRotateAroundUpByAngle", `returns a vector that is the result of angles1 forward vector rotated around its up by degrees`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, true, `v=ForwardRotateByAngles( player_angles, frustum_edge_angle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMinBitCountForNum", `Returns the minimum number of bits needed to express the provided integer`, null, [new LibraryFunctionParameter("uint", `The integer a minimum bit count is needed for`, true)], true, true, `GetMinBitCountForNum( 15 ) returns 4`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Int", `Casts a floating point number or a string to an integer`, null, [new LibraryFunctionParameter("value", `A string or floating point number to cast to an integer`, true)], true, true, `x = Int( self.HUDHealthHeight )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Length", `Returns the length of the given vector`, null, [new LibraryFunctionParameter("vector", `A vector`, true)], true, true, `dist = Length(models[j].origin - center)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LengthSquared", `Returns the squared vector length for the given vector - this is cheaper than the actual vector length as it doesn't involve a square root`, null, [new LibraryFunctionParameter("vector", `A vector`, true)], true, true, `dist2 = LengthSquared(models[j].origin - center)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LerpFloat", `Returns a lerped value between <from> and <to> based on <time>`, null, [new LibraryFunctionParameter("from", `Floating point value, start of the range`, true), new LibraryFunctionParameter("to", `Floating point value, end of the range`, true), new LibraryFunctionParameter("time", `Floating point value in the range of 0 - 1`, true)], true, true, `val = LerpFloat( 0, 10, 0.5);	// would return 5.0`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LerpVector", `Returns a lerped vector value between <from> and <to> based on <time>`, null, [new LibraryFunctionParameter("from", `Vector, start of the range`, true), new LibraryFunctionParameter("to", `Vector, end of the range`, true), new LibraryFunctionParameter("time", `Floating point value in the range of 0 - 1`, true)], true, true, `val = LerpVector( (0,0,0), (5,5,5), 0.5);	// would return (2.5, 2.5, 2.5)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Log", `Returns the logarithm of a number to base 10`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, true, `y = Log( x )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MapFloat", `Returns a lerped value between <from> and <to> based on <time>. <time> is a value between <timeMin> and <timeMax>.`, null, [new LibraryFunctionParameter("timeMin", `Floating point value, min time value`, true), new LibraryFunctionParameter("timeMax", `Floating point value, max time value`, true), new LibraryFunctionParameter("from", `Floating point value, start of the result range`, true), new LibraryFunctionParameter("to", `Floating point value, end of the result range`, true), new LibraryFunctionParameter("time", `Floating point value in the range from <timeMin> to <timeMax>`, true)], true, true, `val = MapFloat( 1, 2, 0, 10, 1.5); // would return 5.0`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Max", `Returns whichever of <a> or <b> is larger.`, null, [new LibraryFunctionParameter("a", `A float or integer value.`, true), new LibraryFunctionParameter("b", `A float or integer value.`, true)], true, true, `largest = Max( val1, val2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Min", `Returns whichever of <a> or <b> is smallest.`, null, [new LibraryFunctionParameter("a", `A float or integer value.`, true), new LibraryFunctionParameter("b", `A float or integer value.`, true)], true, true, `smallest = Min( val1, val2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PackRgba", `Packs rgba into a single int.`, null, [new LibraryFunctionParameter("red", `as a float 0.0-1.0`, true), new LibraryFunctionParameter("green", `as a float 0.0-1.0`, true), new LibraryFunctionParameter("blue", `as a float 0.0-1.0`, true), new LibraryFunctionParameter("alpha", `as a float 0.0-1.0`, true)], true, true, `Byte4PackRgba( 1.0, 1.0, 1.0, 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PointOnSegmentNearestToPoint", `Given a line segment and a point P, this returns the point on the segment that is closest to P.`, null, [new LibraryFunctionParameter("SegmentA", `One endpoint of the line segment`, true), new LibraryFunctionParameter("SegmentB", `Other endpoint of the line segment`, true), new LibraryFunctionParameter("P", `The point`, true)], true, true, `nearestPoint = PointOnSegmentNearestToPoint( A, B, P )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Pow", `Return the value of base raised to exp power.`, null, [new LibraryFunctionParameter("exp", `A float or integer value, <b>."`, true)], true, true, `c = pow( 2, 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Project2Dto3D", `returns a world coordinate that projects to the given 2d coordinate ((-1,1),(-1,1))`, null, [new LibraryFunctionParameter("clientnum", `clientnumber - needed for viewport selection.`, true), new LibraryFunctionParameter("x", `screen space x coord (-1,1)`, true), new LibraryFunctionParameter("y", `screen space y coord (-1,1)`, true), new LibraryFunctionParameter("depth", `depth to assume near clip is at (at this depth the screen will be edge to edge)`, true)], false, true, `v=Project2DTo3D( 0, -1, -1, 5)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Project3Dto2D", `returns a screen coordinate vector (virtual UI coord) of a 3d coordinate `, null, [new LibraryFunctionParameter("clientnum", `client number - needed for viewport selection.`, true), new LibraryFunctionParameter("world_coordinate", `world space vector`, true)], false, true, `hudPosition = Project3DTo2D( 0, target_pos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RandomFloat", `Returns a random floating point number r, where 0 <= r < max`, null, [new LibraryFunctionParameter("max", `The maximum floating point size`, true)], true, false, `if ( RandomFloat( 100 ) > 50 ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RandomFloatRange", `Returns a random floating point number r, where min <= r < max`, null, [new LibraryFunctionParameter("min", `The minimum result`, true), new LibraryFunctionParameter("max", `The maximum result`, true)], true, false, `rand = RandomFloatRange( 3.0, 5.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RandomInt", `Returns a random integer between 0 and max-1 inclusive`, null, [new LibraryFunctionParameter("max", `The maximum integer size`, true)], true, false, `if ( RandomInt( 100 ) > 50 ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RandomIntRange", `Returns a random integer r, where min <= r < max`, null, [new LibraryFunctionParameter("min", `The minimum result`, true), new LibraryFunctionParameter("max", `The maximum result + 1`, true)], true, false, `rand = RandomIntRange( 3, 5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotatePoint", `Returns <angle> lerped angle value.`, null, [new LibraryFunctionParameter("point", `A point.`, true), new LibraryFunctionParameter("angles", `An angle.`, true)], true, true, `rotatedPoint = RotatePoint(point, angle )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RotatePointAroundAxis", `returns a vector that is the result of point rotated around the axis vector by num degrees`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, true, `v = RotatePointAroundAxis( point, up, degrees )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Sin", `Returns the sin of an angle`, null, [new LibraryFunctionParameter("angle", `An angle in degrees`, true)], true, true, `frac = Sin( degrees )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Sqrt", `Returns the square-root of floating point value <a>.`, null, [new LibraryFunctionParameter("a", `A float or integer value.`, true)], true, true, `c = sqrt( (a*a) + (b*b) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Tan", `Returns the tan of an angle`, null, [new LibraryFunctionParameter("angle", `An angle in degrees`, true)], true, true, `frac = Tan( degrees )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorCross", `Returns the cross product of two vectors`, null, [new LibraryFunctionParameter("vector a", `The first vector`, true), new LibraryFunctionParameter("vector b", `The second vector`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorDot", `Returns the dot product of two vectors`, null, [new LibraryFunctionParameter("vector a", `The first vector`, true), new LibraryFunctionParameter("vector b", `The second vector`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorFromLineToPoint", `Given a line and a point P, this returns a vector perpendicular to the line and pointing from the line to P.`, null, [new LibraryFunctionParameter("SegmentA", `One point on the line`, true), new LibraryFunctionParameter("SegmentB", `Another point on the line`, true), new LibraryFunctionParameter("P", `The point`, true)], true, true, `myvector = VectorFromLineToPoint( A, B, P )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorLerp", `Linear interpolates between two vectors.`, null, [new LibraryFunctionParameter("from", `The vector whose value is used when fraction is 0`, true), new LibraryFunctionParameter("to", `The vector whose value is used when fraction is 1`, true), new LibraryFunctionParameter("fraction", `The fraction of the way between vectors.  Values less than 0 or greater than 1 do linear extrapolation.`, true)], true, true, `color = VectorLerp(oldColor, newColor, timeElapsed / timeTotal)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorNormalize", `Returns a normalized copy of this vector`, null, [new LibraryFunctionParameter("vector", `The vector to normalize`, true)], true, true, `difference = VectorNormalize(end - start)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectorProjection", `Returns the vector projection of vector a onto vector b`, null, [new LibraryFunctionParameter("vector a", `The first vector`, true), new LibraryFunctionParameter("vector b", `The second vector`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VectortoAngles", `Returns a set of angles corresponding to the given vector.`, null, [new LibraryFunctionParameter("vector", `The vector to convert to angles`, true)], true, true, `angles = VectortoAngles(end - start)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ViewAspect", `returns the horizontal screen aspect `, null, [new LibraryFunctionParameter("clientnum", `client number - needed for viewport selection.`, true)], false, true, `viewAspect = ViewAspect( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActionButtonPressed", `Check if the player is pressing the 'action' button. Use this for when the player might be in a scripted sequence but might still press the jump button.`, "player", [], true, false, `while( self ActionButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActionSlotFourButtonPressed", `Check if the player is pressing the action slot 4 button`, "player", [], true, false, `if ( self ActionSlotFourButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActionSlotOneButtonPressed", `Check if the player is pressing the action slot 1 button`, "player", [], true, false, `if ( self ActionSlotOneButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActionSlotThreeButtonPressed", `Check if the player is pressing the action slot 3 button`, "player", [], true, false, `if ( self ActionSlotThreeButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ActionSlotTwoButtonPressed", `Check if the player is pressing the action slot 2 button`, "player", [], true, false, `if ( self ActionSlotTwoButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AddToDamageIndicator", `Add damage to damage indicator`, "client", [new LibraryFunctionParameter("dmg", `The damage`, true), new LibraryFunctionParameter("direction", `The direction of hit`, false)], true, false, `self AddToDamageIndicator( int( armor_damage ), vDir)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AdsButtonPressed", `Check if the player is pressing the 'ads' button.`, "player", [], true, false, `while( self AdsButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowAds", `Sets whether the player can switch to ADS`, "player", [new LibraryFunctionParameter("player ads", `: A boolean. true if the player can switch to ADS, and false otherwise.`, true)], true, false, `player AllowAds( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowCrouch", `Sets whether the player can crouch`, "player", [new LibraryFunctionParameter("player crouch", `: A boolean. true if the player can crouch, and false otherwise`, true)], true, false, `player AllowCrouch( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowDoubleJump", `Sets whether the player can double jump`, "player", [new LibraryFunctionParameter("on off", `: A boolean. true if the player can double jump, and false otherwise`, true)], true, false, `player AllowDoubleJump( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowJump", `Sets whether the player can jump`, "player", [new LibraryFunctionParameter("player jump", `: A boolean. True if the player can jump, and false otherwise`, true)], true, false, `player AllowJump(false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowLean", `Sets whether the player can lean`, "player", [new LibraryFunctionParameter("player lean", `: A boolean. true if the player can lean, and false otherwise`, true)], true, false, `player AllowLean( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowMelee", `Sets whether the player can melee`, "player", [new LibraryFunctionParameter("melee", `: A boolean. True if the player can melee, and false otherwise`, true)], true, false, `player AllowMelee(false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowMeleePowerLeft", `Sets whether the player can melee power left`, "player", [new LibraryFunctionParameter("melee", `: A boolean. True if the player can melee power left, and false otherwise`, true)], true, false, `player AllowMeleePowerLeft(false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowProne", `Sets whether the player can go prone`, "player", [new LibraryFunctionParameter("player prone", `: A boolean. true if the player can go prone, and false otherwise`, true)], true, false, `player AllowProne( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowSlide", `Sets whether the player can slide`, "player", [new LibraryFunctionParameter("on off", `: A boolean. true if the player can slide, and false otherwise`, true)], true, false, `player AllowSlide( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowSpectateTeam", `Set whether the player can spectate the given team.`, "player", [new LibraryFunctionParameter("team", `A string description of the team. Valid teams are 'axis', 'allies', 'none' or 'freelook'`, true), new LibraryFunctionParameter("spectate", `A boolean value describing whether this player can spectate on this team.`, true)], true, false, `self AllowSpectateTeam( "axis", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowSprint", `Sets whether the player can sprint`, "player", [new LibraryFunctionParameter("player sprint", `: A boolean. True if the player can sprint, and false otherwise`, true)], true, false, `player AllowSprint(false)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowStand", `Sets whether the player can stand up`, "player", [new LibraryFunctionParameter("player stand", `: A boolean. true if the player can stand, and false otherwise`, true)], true, false, `player AllowStand( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AllowWallRun", `Sets whether the player can wall run`, "player", [new LibraryFunctionParameter("on off", `: A boolean. true if the player can wallrun, and false otherwise`, true)], true, false, `player AllowWallRun( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AnyAmmoForWeaponModes", `Returns true if the weapon has any ammo left`, "player", [new LibraryFunctionParameter("weapon", `The weapon to check`, true)], true, false, `if ( !(self AnyAmmoForWeaponModes( weapon )) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ApplyKnockBack", `Applies a knockback on a player.`, "player", [new LibraryFunctionParameter("amount", `the amount of knockback to apply`, true), new LibraryFunctionParameter("dir", `the direction of knockback to apply`, false)], true, false, `player ApplyKnockBack( 10, dir )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AreControlsFrozen", `Returns true if the controls are frozen`, "player", [], true, false, `if( player AreControlsFrozen() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AttackButtonPressed", `Check if the player is pressing the fire button`, "player", [], true, false, `if ( self AttackButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationAirstrikeSelection", `Begin a location air strike selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationAirstrikeSelection( LOCATION_SELECTOR )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationArtillerySelection", `Begin a location artillery selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationArtillerySelection( LOCATION_SELECTOR )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationComlinkSelection", `Begin a location com link selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationComlinkSelection( LOCATION_SELECTOR, 1000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationMortarSelection", `Begin a location mortar selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationMortarSelection( LOCATION_SELECTOR, 1500 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationNapalmSelection", `Begin a location napalm selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationNapalmSelection( LOCATION_SELECTOR )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BeginLocationSelection", `Begin a location selection`, "player", [new LibraryFunctionParameter("selection name", `The selection name`, true), new LibraryFunctionParameter("radius", `The radius of the selection`, false)], true, false, `self BeginLocationSelection( LOCATION_SELECTOR )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BoostButtonPressed", `Check if the player is pressing the change seat (Y) button`, "player", [], true, false, `if ( self BoostButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("BotSetRandomCharacterCustomization", `Equips this class number with the default class`, "bot", [], true, false, `self BotSetRandomCharacterCustomization()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ButtonBitState", `Return true if the button_bit(s) indicated are pressed (note:  there is no way to know exactly which buttons are pressed on the client, since everything is remapped into these bit values)`, "player", [new LibraryFunctionParameter("button", `: name of button to check "BUTTON_BIT_ATTACK" for example, optionally can include as many button names as desired.  Returns true if all buttons indicated are true.`, true)], true, false, `if ( self ButtonBitState( "BUTTON_BIT_ATTACK") ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ButtonPressed", `Check if the host is pressing the button/key, "BUTTON_A", "BUTTON_B", "K", etc...`, "player", [], true, false, `while( self ButtonPressed( "BUTTON_A" ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CalcPlayerOptions", `Calculate player options`, "player", [new LibraryFunctionParameter("custom class slot", `The custom class slot`, true)], true, false, `playerRenderOptions = self CalcPlayerOptions( class_num )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CalcWeaponOptions", `Calculates weapon options`, "player", [new LibraryFunctionParameter("custom class slot", `The custom class slot`, true), new LibraryFunctionParameter("weapon slot", `primary weapon=0 or secondary weapon=1 or knife weapon=2`, true)], true, false, `primaryWeaponOptions = self CalcWeaponOptions( class_num, 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraActivate", `Turns the script camera on or off.`, "player", [new LibraryFunctionParameter("active", `True to activate the camera, false to turn it off and return to 1st person view`, true)], true, false, `get_players()[0] CameraActivate( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraSetAngles", `Sets the focus point of the script camera.`, "player", [new LibraryFunctionParameter("position", `Either an entity to focus the camera on or a vector defining the camera's focus point`, false)], true, false, `get_players()[0] CameraSetAngles( ( 1100, -23, 644 ) )get_players()[0] CameraSetAngles( my_entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraSetLookAt", `Sets the focus point of the script camera.`, "player", [new LibraryFunctionParameter("position", `Either an entity to focus the camera on or a vector defining the camera's focus point`, false)], true, false, `get_players()[0] CameraSetLookAt( ( 1100, -23, 644 ) )get_players()[0] CameraSetLookAt( my_entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CameraSetPosition", `Sets the position of the script camera.`, "player", [new LibraryFunctionParameter("position", `Either an entity to link the camera to or a vector defining the world position`, true), new LibraryFunctionParameter("angles", `The angles to set for the camera`, false)], true, false, `get_players()[0] CameraSetPosition( ( 1100, -23, 644 ) )get_players()[0] CameraSetPosition( my_entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanPlaceRiotshield", `Try to place riotshield where the player is standing.  return an array containing placement "result", "origin", and "angles`, "player", [], true, false, `placement = level.player CanPlaceRiotshield()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanPlayerPlaceTurret", `Try to place a Turret where the player is looking.  It'll return an array containing the placement "result", "origin", and "angles".`, "player", [], true, false, `placement = level.player CanPlayerPlaceTurret()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CanPlayerPlaceVehicle", `Try to place a vehicle in front of the player.  It'll return an array containing the placement "result", "origin", and "angles".`, "player", [new LibraryFunctionParameter("radius", `Radius of the bounds check`, true), new LibraryFunctionParameter("height", `Height of the bounds check`, true), new LibraryFunctionParameter("forward Distance", `Distance away from player origin.`, true), new LibraryFunctionParameter("up Distance", `Distance up from player origin.`, true), new LibraryFunctionParameter("sweep Distance", `Distance to sweep downwards.`, true), new LibraryFunctionParameter("min normal", `Minimum hit normal needed to be pass.`, true)], true, false, `placement = level.player CanPlayerPlaceVehicle( 25, 45, 50, 40, 80, 0.7 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CantSeeEntities", `Returns the set of entities that a player cannot see within a given angle, given a set of entities`, "player", [new LibraryFunctionParameter("entArray", `The entities to check against`, true), new LibraryFunctionParameter("dotRange", `The cosine of the angle representing your fov`, true), new LibraryFunctionParameter("trace", `Perform a trace for entities`, true)], true, false, `if( isplayer( self.enemy ) && self.enemy CantSeeEntities( entArray, 67 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CarryTurret", `Links the auto turret to the player to carry around.`, "player", [new LibraryFunctionParameter("turret", `The turret entity`, true), new LibraryFunctionParameter("offset", `the offset from the player to place the turret`, true), new LibraryFunctionParameter("angleOffset", `the angle offset of the turret`, true)], true, false, `player CarryTurret( turret, offset, angleOffset )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ChangeSeatButtonPressed", `Check if the player is pressing the change seat (Y) button`, "player", [], true, false, `if ( self ChangeSeatButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearDamageIndicator", `Clear damage indicator`, "client", [], true, false, `self ClearDamageIndicator()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearPerks", `removes all perks for a player`, "player", [], true, false, `player ClearPerks()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClonePlayer", `clone the player's model for death animations.`, "client", [new LibraryFunctionParameter("deathAnimationDuration", `the duration of the death animation`, true), new LibraryFunctionParameter("killing weapon", `weapon that killed the player`, true), new LibraryFunctionParameter("attacker", `attacker that killed the player`, false)], true, false, `body = self ClonePlayer(deathAnimDuration)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CloseInGameMenu", `close the in game menu for this client.`, "client", [], true, false, `player CloseInGameMenu()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CloseLUIMenu", `Closes the given lui menu and returns true if it finds the menu and succeeds in closing it, false otherwise.`, "player", [new LibraryFunctionParameter("lui menu handle", `handle to the lui menu.`, true)], true, false, `player CloseLUIMenu( menu )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CloseMenu", `close the specified menu for this client.`, "client", [new LibraryFunctionParameter("menu index", `The precached menu index of type "menu"`, true)], true, false, `player CloseMenu( game[ "menu_changeclass" ] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateFlashbackClone", `clone the player's model for temporary flashback model`, "client", [], true, false, `body = self CreateFlashbackClone()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DamageRiotShield", `Apply damage to a player riot shield or other weapon that supports damage states.`, "player", [], true, false, `newhealth = player DamageRiotShield( 100 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DeathStreakActive", `Returns true if player's death streak is active`, "player", [], true, false, `if( player DeathStreakActive() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableDeathStreak", `Disable player's death streak`, "player", [], true, false, `player DisableDeathStreak()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableInvulnerability", `Makes player vulnerable to damage.  This is default behavior`, "player", [], true, false, `player DisableInvulnerability()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableOffhandWeapons", `Disable the player's offhand weapons`, "player", [], true, false, `player DisableOffhandWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableRoundStartDelay", `Enable players weapon after round start delay`, "player", [], true, false, `player DisableRoundStartDelay()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableUsability", `Disables usability for the player`, "player", [], true, false, `player DisableUsability()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableWeaponCycling", `Disable the player's weapon cycling`, "player", [], true, false, `player DisableWeaponCycling()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableWeaponFire", `Disable the player's weapon fire`, "player", [], true, false, `player DisableWeaponFire(()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableWeapons", `Disable the weapons of the player`, "player", [new LibraryFunctionParameter("quick", `Set the Disable weapons quick flag`, false)], true, false, `self DisableWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DropItem", `Drop an item with the given item name`, "player", [new LibraryFunctionParameter("item name", `the name of the item to drop`, true), new LibraryFunctionParameter("dropTag", `If specified drop and snap the weapon to this tag`, false)], true, false, `self DropItem( current )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DropScavengerItem", `Drop an item with the given item name. This item will be only available to those with the scavenger perk`, "player", [new LibraryFunctionParameter("item name", `the name of the item to drop`, true)], true, false, `self DropScavengerItem( "scavenger_item_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableDeathStreak", `Enable player's death streak`, "player", [], true, false, `player EnableDeathStreak()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableInvulnerability", `Makes player invulnerable to damage`, "player", [], true, false, `player EnableInvulnerability()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableOffhandWeapons", `Enable the player's offhand weapons`, "player", [], true, false, `player EnableOffhandWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableRoundStartDelay", `Disable the players weapon during round start`, "player", [], true, false, `player EnableRoundStartDelay()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableUsability", `Enables usability for the player`, "player", [], true, false, `player EnableUsability()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableWeaponCycling", `Enable the player's weapon cycling`, "player", [], true, false, `player EnableWeaponCycling()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableWeaponFire", `Enable the player's weapon fire`, "player", [], true, false, `player EnableWeaponFire()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnableWeapons", `Enables the weapons of the player`, "player", [], true, false, `self EnableWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EndLocationSelection", `Ends location selection`, "player", [], true, false, `self endLocationSelection()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FakeDamageFrom", `Make the player take damage from the given direction`, "player", [new LibraryFunctionParameter("dir", `The direction to take damage from`, true)], true, false, `self FakeDamageFrom(vDir)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("finishMeleeHit", `Notifies the clients of the melee hit or miss`, "client", [new LibraryFunctionParameter("Attacker", `The entity that is attacking.`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true), new LibraryFunctionParameter("Origin", `(vector) The origin of the damage`, true), new LibraryFunctionParameter("Direction", `(vector) The direction of the damage`, true), new LibraryFunctionParameter("bone index", `Which bone was the closest to the hit`, true), new LibraryFunctionParameter("shieldHit", `Was the hit delivered against a shield`, true), new LibraryFunctionParameter("hit", `Was the hit successful or a swipe`, true), new LibraryFunctionParameter("fromBehind", `Was the hit from behind the victim`, true)], true, false, `self finishMeleeHit( eAttacker, sWeapon, vPoint, vDir, iBoneIndex, bHit )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FinishPlayerDamage", `Does damage to a player - usually as part of the damage callback`, "client", [new LibraryFunctionParameter("Inflictor", `The entity that causes the damage.(e.g. a turret)`, true), new LibraryFunctionParameter("Attacker", `The entity that is attacking.`, true), new LibraryFunctionParameter("Damage", `Integer specifying the amount of damage done`, true), new LibraryFunctionParameter("Damage Flags", `Integer specifying flags that are to be applied to the damage`, true), new LibraryFunctionParameter("Means Of Death", `Integer specifying the method of death`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true), new LibraryFunctionParameter("Point", `Damage point`, true), new LibraryFunctionParameter("Direction", `(vector) The direction of the damage`, true), new LibraryFunctionParameter("Hit Loc", `The location of the hit`, true), new LibraryFunctionParameter("Damage Origin", `Where the damage originated from.`, true), new LibraryFunctionParameter("Offset Time", `The time offset for the damage`, true), new LibraryFunctionParameter("bone index", `Which bone was the closest to the hit`, true), new LibraryFunctionParameter("Surface Normal", `The normal of the surface impacted.`, true)], true, false, `self FinishPlayerDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, iBone, vDamageOrigin, psOffsetTime, vSurfaceNormal )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceGrenadeThrow", `Forces the player to throw a held grenade`, "player", [], true, false, `player ForceGrenadeThrow()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceOffHandEnd", `Force the player to not use offhand weapon`, "player", [], true, false, `self forceoffhandend()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ForceSlick", `Sets whether the player is forced to be on a slick surface`, "player", [new LibraryFunctionParameter("slick", `: A boolean. True if the player is on a slick surface, and false otherwise`, true)], true, false, `player ForceSlick(true)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FragButtonPressed", `Check if the player is pressing the frag button`, "player", [], true, false, `if ( self FragButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FreezeControls", `Blocks or unblocks control input from this player`, "player", [new LibraryFunctionParameter("freeze state", `: true if the player's controls are frozen, false otherwise.`, true)], true, false, `player FreezeControls( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FreezeControlsAllowLook", `Blocks or unblocks control input from this player, but allows the player to look around`, "player", [new LibraryFunctionParameter("freeze state", `: true if the player's controls are frozen, false otherwise.`, true)], true, false, `level.player FreezeControlsAllowLook( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GamepadUsedLast", `Check if the player is playing with a gamepad.`, "player", [], true, false, `if( player GamepadUsedLast() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyModel", `Gets the body model for this player as selected in character customization`, "player", [new LibraryFunctionParameter("modelType", `The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON`, false)], true, false, `self GetCharacterBodyModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyRenderOptions", `Gets the body render options for this player`, "player", [], true, false, `self GetCharacterBodyRenderOptions()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterBodyType", `Gets the character body type for the player.`, "player", [], true, false, `bodyIndex = self GetCharacterBodyType( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHeadModel", `Gets the head model for this player`, "player", [], true, false, `self GetCharacterHelmetModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCharacterHelmetModel", `Gets the helmet model for this player as selected in character customization`, "player", [new LibraryFunctionParameter("modelType", `The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON`, false)], true, false, `self GetCharacterHelmetModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetControllerUIModelValue", `Gets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.`, "player", [new LibraryFunctionParameter("ui model data path from controller", `precached name string for the data which we're trying to get.`, true)], true, false, `player GetControllerUIModelValue( "hudItems.regenDelayProgress")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentOffHand", `Get the current offhand weapon`, "player", [], true, false, `weapon = self GetCurrentOffhand()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentWeapon", `Gets the current player weapon`, "player", [], true, false, `currentweapon = player GetCurrentWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentWeaponAltWeapon", `Gets the alt weapon for the players current weapon.  Returns "none`, "player", [], true, false, `currentweapon = player GetCurrentWeaponAltWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetCurrentWeaponSpinLerp", `Gets the current weapon spin `, "player", [], true, false, `weapon_spin_lerp = self GetCurrentWeaponSpinLerp()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetEnemyDogTagModel", `Get the enemy of the dog tag model currently associated character body`, "entity", [], true, false, `friendly_model = player GetEnemyDogTagModel( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFractionMaxAmmo", `Get fraction of the max ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon to give max ammo to`, true)], true, false, `frac = players[i] GetFractionMaxAmmo( lethal_grenade )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFractionStartAmmo", `Give fraction of start ammo to the player for the weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon to give ammo to`, true)], true, false, `start = player GetFractionStartAmmo( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFriendlies", `Returns an array of friendly players. The player called on is not included in the array.`, "player", [new LibraryFunctionParameter("bool", `true, return only players that are alive, false return all players`, false)], true, false, `friends = self GetFriendlies()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFriendlyDogTagModel", `Get the friendly of the dog tag model currently associated character body`, "entity", [], true, false, `friendly_model = player GetFriendlyDogTagModel( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGunAngles", `Get the player's gun angles`, "player", [], true, false, `angles = player GetGunAngles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroAbilityName", `Returns the name of the weapon assigned to the currently selected body`, "player", [], true, false, `weaponName = self GetHeroAbilityName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeroWeaponName", `Returns the name of the weapon assigned to the currently selected body`, "player", [], true, false, `weaponName = self GetHeroWeaponName()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInventoryHeldWeapon", `Gets the player's inventory held weapon`, "player", [], true, false, `inventoryWeapon = player GetInventoryHeldWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetInventoryWeapon", `Get the inventory weapon`, "player", [], true, false, `inventoryWeapon = self GetInventoryWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetIpAddress", `Gets the ip address of the player`, "player", [], true, false, `ipAddress = self GetIpAddress()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLeagueTeamID", `Get the league team ID`, "player", [], true, false, `id = player GetLeagueTeamID()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLightingState", `Gets the current lighting state for the player`, "player", [], true, false, `ls = player GetLightingState()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLockOnLossRadius", `Returns the lock on loss radius for the currently equipped heatseeking launcher.`, "player", [], true, false, `radius = player GetLockOnRadius()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLockOnOrigin", `gets the origin to use for the replay gun lockon on the entity`, "player", [new LibraryFunctionParameter("bool", `: true or false.`, true)], true, false, `player GetLockOnOrigin( entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLockOnRadius", `Returns the lock on radius for the currently equipped heatseeking launcher.`, "player", [], true, false, `radius = player GetLockOnRadius()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLockOnSpeed", `Returns the lock on speed in miliseconds for the currently equipped heatseeking launcher.`, "player", [], true, false, `speed = player GetLockOnSpeed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLUIMenu", `Returns a handle to a lui menu.`, "player", [new LibraryFunctionParameter("lui menu name", `name of the menu.`, true)], true, false, `player GetLUIMenu( "myMenu" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLUIMenuData", `Gets the current value for the given data name.`, "player", [new LibraryFunctionParameter("lui menu handle", `handle for the lui menu.`, true), new LibraryFunctionParameter("lui menu data name", `name of the data which had been set on the menu.`, true)], true, false, `player GetLUIMenuData( menu, "title" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMpDialogName", `Get the name of the mpdialog bundle of the currently associated character body`, "entity", [], true, false, `mpDialogBundleName = player GetMpDialogName( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNormalizedCameraMovement", `Get the player's camera movement normalized`, "player", [], true, false, `v_stick = player GetNormalizedCameraMovement()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNormalizedMovement", `Get the player's movement normalized`, "player", [], true, false, `norm_move = self GetNormalizedMovement()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOffHandSecondaryClass", `Get whether the player is using a flash or smoke`, "player", [], true, false, `offhand_secondary = self GetOffHandSecondaryClass()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPerks", `Returns an array of all player perks. The array is size 0 if the player has no perks.`, "player", [], true, false, `perks = player GetPerks()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerAngles", `Get the player view angles`, "player", [], true, false, `angles = player GetPlayerAngles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerAttachmentCosmeticVariantIndexes", `Get the player's held weapon acvi `, "player", [new LibraryFunctionParameter("weapon", `The weapon to get acvi from`, true)], true, false, `acvi = self GetPlayerAttachmentCosmeticVariantIndexes( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerCameraPos", `Get the player's camera position`, "player", [], true, false, `vieworg = player GetPlayerCameraPos()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerGenderType", `Returns the gender string of the player`, "player", [new LibraryFunctionParameter("mode", `SessionMode`, true)], true, false, `if ( self GetPlayerGenderType() == "male" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerMovementState", `Returns the player movement state for the match record.  `, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSelectedGesture", `Get the equipped gesture `, "player", [new LibraryFunctionParameter("gestureType", `The type of gesture to get`, true)], true, false, `gesture = player GetPlayerSelectedGesture( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerSelectedTaunt", `Get the equipped taunt `, "player", [new LibraryFunctionParameter("tauntType", `The type of taunt to get`, true)], true, false, `taunt = player GetPlayerSelectedTaunt( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerShowcaseWeapon", `Get the showcase weapon of the given player`, "player", [], true, false, `showcaseWeapon = player GetPlayerShowcaseWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPlayerViewHeight", `Get the player's view height`, "player", [], true, false, `height = player GetPlayerViewHeight()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getreplaygunlockonorigin", `gets the origin to use for the replay gun lockon on the entity`, "player", [new LibraryFunctionParameter("bool", `: true or false.`, true)], true, false, `player GetLockOnOrigin( entity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSnapshotAckIndex", `Get the snapshot acknowledgment index`, "player", [], true, false, `num = self getsnapshotackindex()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSunShadowSplitDistance", `Gets the current sun shadow split difference for the player`, "player", [], true, false, `distance = player GetSunShadowSplitDistance()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTargetScreenAngles", `Get target screen view angles`, "player", [new LibraryFunctionParameter("targetpos", `The position to get angles for.`, true)], true, false, `angles = self GetTargetScreenAngles( targetpos )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleBoostTime", `Gets the vehicle's max boost time`, "player", [], true, false, `boostTime = player GetVehicleBoostTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleBoostTimeLeft", `Gets the vehicle's remaining boost time`, "player", [], true, false, `boostTimeLeft = player GetVehicleBoostTimeLeft()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleFocusEntity", `Gets the current vehicle focus entity for the player`, "player", [], true, false, `focusEnt = player GetVehicleFocusEntity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleMinBoostTime", `Gets the vehicle's min boost time needed in order to boost`, "player", [], true, false, `minBoostTime = player GetVehicleMinBoostTime()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleOccupied", `Returns the vehicle entity that the player occupies.  If player isn't in a vehicle then this causes an error.`, "player", [], true, false, `self GetVehicleOccupied()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAcvi", `Gets weapon options from held weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon`, true)], true, false, `primaryWeaponAcvi = self GetWeaponAcvi( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAmmoClip", `Get the weapon's ammo count in clip`, "player", [new LibraryFunctionParameter("weapon", `The weapon to get ammo count from`, true)], true, false, `ammo = self GetWeaponAmmoClip( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAmmoFuel", `Get the weapon's fuel count `, "player", [new LibraryFunctionParameter("weapon", `The weapon to get fuel count from`, true)], true, false, `fuel = self GetWeaponAmmoFuel( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponAmmoStock", `Get the weapon's total ammo count `, "player", [new LibraryFunctionParameter("weapon", `The weapon to get ammo count from`, true)], true, false, `ammo = self GetWeaponAmmoStock( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponForWeaponRoot", `Returns a weapon that the player is holding that has the same weapon root.  Returns undefined if the player is not holding the weapon.`, "player", [new LibraryFunctionParameter("weapon", `The weapon to check`, true)], true, false, `weapon_with_attachments = player GetWeaponForWeaponRoot( <weapon> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponOptions", `Get the weapon's render options `, "player", [new LibraryFunctionParameter("weapon", `The weapon to get options from`, true)], true, false, `weaponOptions = self GetWeaponOptions( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponsList", `Gets an array of all weapons that the player has.  Alt-mode weapons by default are not included`, "player", [new LibraryFunctionParameter("include_alt_modes", `1/True to include alt-mode weapons`, false)], true, false, `weapList = player GetWeaponsList()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWeaponsListPrimaries", `undefined`, "player", [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveDedicatedShadow", `Sets the model lod bias`, "entity", [new LibraryFunctionParameter("entity", `The entity to enable the dedicated shadow on`, true)], true, false, `player GiveDedicatedShadow( 8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveMaxAmmo", `Give the weapon max ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon to give ammo to`, true)], true, false, `self GiveMaxAmmo( primary )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveNextBaseWeapon", `Give the player the next base weapon`, "player", [], true, false, `self GiveNextBaseWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveStartAmmo", `Give the weapon initial ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon to give ammo to`, true)], true, false, `self GiveStartAmmo( primary )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveWeapon", `Give a weapon to the player`, "player", [new LibraryFunctionParameter("weapon", `The weapon to give`, true), new LibraryFunctionParameter("options", `The weapon options`, false), new LibraryFunctionParameter("acvi", `The attachment cosmetic variant index`, false)], true, false, `e_player GiveWeapon( w_spike_launcher )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GiveWeaponNextAttachment", `Give the weapon the next attachment`, "player", [new LibraryFunctionParameter("attachment point", `The attachment point name`, true)], true, false, `self giveweaponnextattachment( "muzzle" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasAGrenadePulledBack", `check is a client has a grenade (any type including special) currently pulled back`, "player", [], true, false, `self HasAGrenadePulledBack( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasMaxPrimaryWeapons", `Returns true if the player has maximum primary weapons`, "player", [], true, false, `if( self HasMaxPrimaryWeapons() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasPerk", `test if player has a perk`, "player", [new LibraryFunctionParameter("perk name", `the perk to check`, true)], true, false, `player HasPerk( "specialty_gpsjammer" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasRiotShield", `Return true if player has a riot shield in their inventory.`, "player", [], true, false, `if ( player HasRiotShield() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HasWeapon", `Returns true if the player has the given weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon to check`, true), new LibraryFunctionParameter("ignore_attachments", `Only check the root weapon, ignore all the attachments.`, false)], true, false, `if( e_player HasWeapon( w_spike_launcher, true ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("HideViewModel", `Hide the player's current view model.`, "player", [], true, false, `player HideViewModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("InitialWeaponRaise", `Setup weaponstate to force first raise animation`, "player", [new LibraryFunctionParameter("weapon name", `The weapon to try first raise anim with`, true)], true, false, `self InitialWeaponRaise( "ak47" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("InventoryButtonPressed", `Check if the player is pressing the inventory button`, "player", [], true, false, `if ( self InventoryButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsCarryingTurret", `Check if player is carrying turret or not.`, "player", [], true, false, `player IsCarryingTurret()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsChargeShotPending", `Returns true if player has a charge shot pending with a charge shot weapon`, "player", [], true, false, `if( self IsChargeShotPending() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDroppingWeapon", `Returns true if the player is currently dropping their weapon`, "player", [], true, false, `player IsDroppingWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFiring", `Returns true if the player is currently meleeing`, "player", [], true, false, `player IsFiring()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGrappling", `Returns true if the player is currently grappling`, "player", [], true, false, `player IsGrappling()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsHost", `Returns true if the player is the host`, "player", [], true, false, `player IsHost()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsHostForBots", `Returns true if the passed in entity is the host for bots`, "player", [], true, false, `player IsHostForBots()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInMoveMode", `Returns true if the player is in either of the given move modes`, "player", [new LibraryFunctionParameter("move_mode_1", `The move mode to check`, true), new LibraryFunctionParameter("move_mode_2", `The move mode to check`, false)], true, false, `if ( player IsInMoveMode( "ufo", "noclip" ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInVehicle", `Returns whether or not this player is currently occupying a vehicle.`, "player", [], true, false, `self IsInVehicle()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLocalToHost", `Returns true if the player is on the same physical machine as the host`, "player", [], true, false, `player IsLocalToHost()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLookingAt", `Returns true if the player is looking at entity`, "player", [new LibraryFunctionParameter("entity", `The entity to check`, true)], true, false, `if( isplayer( self.enemy ) && self.enemy islookingat( self ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMeleeing", `Returns true if the player is currently meleeing`, "player", [], true, false, `player IsMeleeing()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsPlayerOnSameMachine", `Returns whether or not this player is on the same machine as the other player.`, "player", [new LibraryFunctionParameter("player", `The player to test against`, true)], true, false, `if ( self IsPlayerOnSameMachine( player ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsReloading", `Returns true if the player is currently reloading`, "player", [], true, false, `player IsReloading()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsRemoteControlling", `Returns whether or not this player is currently occupying a remote controlled entity.`, "player", [], true, false, `self IsRemoteControlling()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSwitchingWeapons", `Returns true if the player is currently switching weapons`, "player", [], true, false, `player IsSwitchingWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTalking", `Returns true if the player is talking via voice chat`, "player", [], true, false, `if( player IsTalking() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsThrowingGrenade", `Returns true if the player is currently throwing a grenade`, "player", [], true, false, `player IsThrowingGrenade()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsUsingOffHand", `Returns true if player is using offhand weapon`, "player", [], true, false, `if( self IsUsingOffHand() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWeaponViewOnlyLinked", `Returns whether or not this player is linked to an enity with weapon view only linking.`, "player", [], true, false, `self IsWeaponViewOnlyLinked()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("JumpButtonPressed", `Check if the player is pressing the 'jump' button.`, "player", [], true, false, `while( self JumpButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkGuidedMissileCamera", `set player eflags for the guided missile`, "player", [], true, false, `player LinkGuidedMissileCamera()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LinkToMissile", `Links a player camera and controls to a missile`, "player", [new LibraryFunctionParameter("undefined", `undefined`, undefined), new LibraryFunctionParameter("boost_enabled", `: If true, the player can trigger missile boost`, false), new LibraryFunctionParameter("brake_enabled", `: If true, the player can trigger missile brake`, false)], true, false, `player LinkToMissile( rocket, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MeleeButtonPressed", `Check if the player is pressing the melee button`, "player", [], true, false, `if ( self MeleeButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MurderLine", `Get all the enemy players on the line between given points and murder them to death`, "player", [new LibraryFunctionParameter("from", `The from position`, true), new LibraryFunctionParameter("to", `The to position`, true), new LibraryFunctionParameter("weapon", `The weapon used`, true)], true, false, `player MurderLine( origin, endpos, "kniferang_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NextPlayerRenderOption", `Set the next player render option`, "player", [new LibraryFunctionParameter("optionName", `The tag of the next option`, true), new LibraryFunctionParameter("forward", `The delta`, true)], true, false, `level.dev_cac_player NextPlayerRenderOption( tag, forward )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OffhandSpecialButtonPressed", `Check if the player is pressing the gadget button`, "player", [], true, false, `if ( self OffhandSpecialButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OpenLUIMenu", `Opens a lui menu( has to be precahced ) and returns a handle to it.`, "player", [new LibraryFunctionParameter("lui menu name", `name of the menu.`, true), new LibraryFunctionParameter("persistent", `the menu will remain open even if the player dies.`, false)], true, false, `player OpenLUIMenu( "myMenu", true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OpenMenu", `Open the menu with the given menu index`, "player", [new LibraryFunctionParameter("menu index", `The menu index`, true)], true, false, `self openMenu( game[ "menu_changeclass" ] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OpenMenuNoMouse", `Open the menu with the given menu index`, "player", [new LibraryFunctionParameter("menu index", `The menu index`, true)], true, false, `self OpenMenuNoMouse( game[ "menu_changeclass" ] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PickupAmmoEvent", `Lets the client know a weapon was picked up`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self PickupAmmoEvent( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PickupWeaponEvent", `Lets the client know a weapon was picked up`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, true)], true, false, `self PickupWeaponEvent( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PingPlayer", `Flashes a player on their teammate's compasses`, "player", [], true, false, `self PingPlayer()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayBombDefuse", `Play the players bomb defuse animation`, "player", [], true, false, `self PlayBombDefuse()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayBombPlant", `Play the players bomb plant animation`, "player", [], true, false, `self PlayBombPlant()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayClientAirstrike", `Plays the client sided part of the airstrike/bombrun`, null, [new LibraryFunctionParameter("position", `The position of airstrike`, true), new LibraryFunctionParameter("yaw", `The yaw`, true), new LibraryFunctionParameter("teamFaction", `The team faction`, true), new LibraryFunctionParameter("team", `The team`, true), new LibraryFunctionParameter("owner", `The owner of airstike`, true), new LibraryFunctionParameter("exittype", `The exit type`, true), new LibraryFunctionParameter("height", `The height`, true)], true, false, `PlayClientAirstrike( pos, yaw, "marines", "axis", owner, "left", height )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayClientNapalm", `Plays the client sided part of the Napalm`, null, [new LibraryFunctionParameter("position", `The position of Napalm`, true), new LibraryFunctionParameter("yaw", `The yaw`, true), new LibraryFunctionParameter("teamFaction", `The team faction`, true), new LibraryFunctionParameter("team", `The team`, true), new LibraryFunctionParameter("owner", `The owner of Napalm`, true), new LibraryFunctionParameter("exittype", `The exit type`, true), new LibraryFunctionParameter("height", `The height`, true)], true, false, `PlayClientNapalm( startPos, plane.yaw, "vietcong", "axis", plane.owner, "left", height )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerADS", `Gets the player weapon position fraction`, "player", [], true, false, `if ( self PlayerADS() > 0.3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayerKnockback", `Turn knockback on and off for a player`, "actor", [new LibraryFunctionParameter("true/false", `if true, client affected by knockback`, true)], true, false, `self PlayerKnockback( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayHitMarker", `Plays a hit marker event`, "player", [new LibraryFunctionParameter("sound name", `The name of the sound or hash`, true), new LibraryFunctionParameter("damage state", `How damaged the victim is`, false), new LibraryFunctionParameter("perk feedback", `If the victim had any perks active that modified the hit marker`, false), new LibraryFunctionParameter("is dead", `If the victim has died from this hit marker and needs a red flash`, false)], true, false, `self PlayHitMarker( "evt_squad_activate", 3, "flakjacket" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PlayLocalSound", `Plays a sound locally`, "player", [new LibraryFunctionParameter("sound name", `The name of the sound or hash`, true)], true, false, `self playlocalsound( "evt_squad_activate" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PrimaryButtonPressedLocal", `Check if the local player is pressing the primary button (BUTTON_A)`, "player", [], true, false, `if ( self PrimaryButtonPressedLocal() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PrimeMovie", `Starts priming the cinematic movie to be played.`, "player", [new LibraryFunctionParameter("moviename", `movie name`, true)], true, false, `self PrimeMovie( "mymovie" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReloadButtonPressed", `Check if the player is pressing the 'usereload' button.`, "player", [], true, false, `while( self reloadButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReloadWeaponAmmo", `Set the weapon's ammoclip from the ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon to be reloaded`, true)], true, false, `self ReloadWeaponAmmo( <weapon> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoteControlTurret", `Remote control into a turret`, "player", [new LibraryFunctionParameter("turret", `the remote controlled turret.`, true)], true, false, `player RemoteControlTurret( turret )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RemoteControlTurretOff", `Stops remote controlling a turret`, "player", [new LibraryFunctionParameter("turret", `the remote controlled turret.`, true)], true, false, `player RemoteControlTurretOff( turret )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetAnimations", `Reset player animations after a body type change`, "player", [], true, false, `self ResetAnimations())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetCharacterCustomization", `Resets all of the character customization to what is in the player stats`, "player", [], true, false, `self ResetCharacterCustomization()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetFlashBack", `Resets the players flashback history`, "player", [], true, false, `self resetflashback()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetSpreadOverride", `Reset the player's aim spread to 255`, "player", [], true, false, `self ResetSpreadOverride()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Revive", `Revive the player`, "player", [], true, false, `self Revive())`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RevivePlayer", `Callback from script to get player out of last stand, increases health, removes damage timer, should clear screen of damageFX`, "client", [], true, false, `self RevivePlayer()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SayAll", `Write a client chat message from this client to everybody`, "player", [new LibraryFunctionParameter("message", `A localizable message to send to all players`, true)], true, false, `self SayAll( saytext )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SayTeam", `Write a client chat message from this client to everybody on their team`, "player", [new LibraryFunctionParameter("message", `A localizable message to send to all players on the player's team.`, true)], true, false, `self SayTeam( sayText )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SecondaryButtonPressedLocal", `Check if the local player is pressing the secondary button (BUTTON_B)`, "player", [], true, false, `if ( self SecondaryButtonPressedLocal() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SecondaryOffhandButtonPressed", `Check if the player is pressing the secondary offhand button`, "player", [], true, false, `if ( self SecondaryOffhandButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetActionSlot", `Sets action slot for the player`, "player", [new LibraryFunctionParameter("slot", `The action slot`, true), new LibraryFunctionParameter("action slot type", `The type of slot. can be "weapon"/"altMode"/""`, true), new LibraryFunctionParameter("weapon", `The weapon to set`, false)], true, false, `self SetActionSlot( 4, "weapon", level.DEAD_CONTROL_WEAPON )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetArenaPoints", `Sets the player's arena points`, "player", [new LibraryFunctionParameter("point", `points`, true)], true, false, `player SetArenaPoints( 19 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBlockWeaponPickup", `Blocks the player from picking up other weapons while using this weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon to set block for`, true), new LibraryFunctionParameter("enabled", `True if weapon pickup should be blocked`, true)], true, false, `self setBlockWeaponPickup( killstreakWeapon, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCarryingObject", `Enable or disable the player carrying object flag. Disables doublejump and juke`, "player", [new LibraryFunctionParameter("onoff", `True to enable, false otherwise`, true)], true, false, `self SetCarryingObject( true );  // disables doublejump and juke`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCharacterBodyStyle", `Sets the character body style for the current body type.  Resets all colors for the body style to default.`, "player", [new LibraryFunctionParameter("character body type index", `The index of the character body type`, true)], true, false, `self SetCharacterBodyStyle( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCharacterBodyType", `Sets the character body type for the player.  Resets all other customization to default for the new body type.`, "player", [new LibraryFunctionParameter("character body type index", `The index of the character body type`, true), new LibraryFunctionParameter("character head type index", `The index of the character head type`, false)], true, false, `self SetCharacterBodyType( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCharacterHelmetStyle", `Sets the character body style for the current helmet type.  Resets all colors for the helmet style to default.`, "player", [new LibraryFunctionParameter("character body type index", `The index of the character body type`, true)], true, false, `self SetCharacterHelmetStyle( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientCGObjectiveText", `Sets the objective text only on this client`, "player", [new LibraryFunctionParameter("text", `The text to set`, true)], true, false, `self SetClientCGObjectiveText( util::getObjectiveScoreText( self.pers["team"] ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientCompass", `Sets compass dvar only on this client`, "player", [new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `self SetClientCompass( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientDrawTalk", `Sets cg_drawTalk dvar only on this client`, "player", [new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `self SetClientDrawTalk( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientFocalLength", `Sets cg_focalLength dvar only on this client`, "player", [new LibraryFunctionParameter("value", `The focal length value to set (float)`, true)], true, false, `self SetClientFocalLength( 23.3622 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientHUDHardcore", `Sets ui_hud_hardcore dvar only on this client`, "player", [new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `self SetClientHUDHardcore( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientMiniScoreboardHide", `Sets miniscoreboardhide dvar only on this client`, "player", [new LibraryFunctionParameter("enable", `True/1 to hide, false/0 otherwise`, true)], true, false, `players[i] SetClientMiniScoreboardHide( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientNumLives", `Sets scr_numLives dvar only on this client`, "player", [new LibraryFunctionParameter("numLives", `The numlives to set`, true)], true, false, `self SetClientNumLives( level.numLives )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientPlayerPushAmount", `Sets playerPushAmount dvar only on this client`, "player", [new LibraryFunctionParameter("amount", `The push amount`, true)], true, false, `self SetClientPlayerPushAmount( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientPlayerSprintTime", `Sets player_sprintTime dvar only on this client`, "player", [new LibraryFunctionParameter("time", `The spring time`, true)], true, false, `self SetClientPlayerSprintTime( level.playerSprintTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientScriptMainMenu", `Sets g_scriptMainMenu dvar only on this client`, "player", [new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `self SetClientScriptMainMenu( game["menu_class"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientThirdPerson", `Set the client to be third person`, "player", [new LibraryFunctionParameter("onoff", `1 to set, 0 otherwise`, true)], true, false, `self SetClientThirdPerson( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientThirdPersonAngle", `Sets cg_thirdPerson dvar only on this client`, "player", [new LibraryFunctionParameter("angle", `The angle to set`, true)], true, false, `self SetClientThirdPersonAngle( 354 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClientUIVisibilityFlag", `Sets a HUD visibility flag only on this client`, "player", [new LibraryFunctionParameter("flagName", `The name of the flag`, true), new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `e_player SetClientUIVisibilityFlag( "hud_visible", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetControllerUIModelValue", `Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.`, "player", [new LibraryFunctionParameter("ui model data path from controller", `precached name string for the data which we're trying to set.`, true), new LibraryFunctionParameter("ui model value", `value for the data which we're trying to set on the controller.`, true)], true, false, `player SetControllerUIModelValue( "hudItems.regenDelayProgress", 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCurrentSpectatorClient", `Set the given client as a spectator`, "player", [new LibraryFunctionParameter("client", `The client to set spectator`, true)], true, false, `self SetCurrentSpectatorClient( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCurrentWeaponSpinLerp", `Set the current weapon's spin `, "player", [new LibraryFunctionParameter("spin", `The spin value`, true)], true, false, `self SetCurrentWeaponSpinLerp( 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDisabledTargetHint", `Set target not selected hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetDisabledTargetHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetElectrifiedState", `Sets the player into the electrified state for 3rd person anim purposes. Different from SetElectrified() which plays the postfx`, "player", [new LibraryFunctionParameter("electrified", `: bool whether the player should be in this state.`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEnterTime", `Sets the player's session enter time`, "player", [new LibraryFunctionParameter("time", `The time to set`, true)], true, false, `self setEnterTime( getTime() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetEverHadWeaponAll", `Set the EverHadAllPlayerHeldWeapons flag of the player`, "player", [new LibraryFunctionParameter("flag", `True to set the flag`, true)], true, false, `self SetEverHadWeaponAll( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHighlighted", `Highlight the player`, "player", [new LibraryFunctionParameter("onoff", `True to highlight, false otherwise`, true)], true, false, `self SetHighlighted( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInventoryHeldWeapon", `Sets the player's inventoryHeldWeapon.`, "player", [new LibraryFunctionParameter("weapon", `The held weapon to be set as inventoryHeldWeapon. Use undefined to clear the inventoryHeldWeapon.`, true)], true, false, `player SetInventoryHeldWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetInventoryWeapon", `Set the inventory weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon to set`, true)], true, false, `self SetInventoryWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLowReady", `set the player into low ready weapon state. `, null, [new LibraryFunctionParameter("enable", `true to set this state`, true)], true, false, `self SetLowReady(true)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLUIMenuData", `Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.`, "player", [new LibraryFunctionParameter("lui menu handle", `handle to the lui menu opened.`, true), new LibraryFunctionParameter("lui menu data name", `precached name string for the data which we're trying to set.`, true), new LibraryFunctionParameter("lui menu data value", `value for the data which we're trying to set on the menu.`, true)], true, false, `player SetLUIMenuData( menu, "title", "Some Title" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetModelLodBias", `Sets the model lod bias`, "player", [new LibraryFunctionParameter("bias", `bias. Setting of 0 reverts to the model lod bias.`, true)], true, false, `player SetModelLodBias( 8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNoLOSOnTargetsHint", `Set target not selected hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetNoLOSOnTargetsHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNoTargetsHint", `Set target not selected hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetNoTargetsHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("setOffhandPrimaryClass", `Set whether the player is using a grenade or gear.`, "player", [new LibraryFunctionParameter("name", `the weapon name`, true)], true, false, `player setOffhandPrimaryClass( "claymore_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOffhandSecondaryClass", `Set whether the player is using a flash or smoke grenade.`, "player", [new LibraryFunctionParameter("name", `the weapon name`, true)], true, false, `player SetOffhandSecondaryClass( "concussion_grenade_mp" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOffhandVisible", `Enable or disable visibility of the offhand weapon`, "player", [new LibraryFunctionParameter("onoff", `True/1 to enable, false otherwise`, true)], true, false, `self SetOffhandVisible( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetOrigin", `Set the player's origin`, "player", [new LibraryFunctionParameter("origin", `The origin to set`, true)], true, false, `player SetOrigin( v_origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetParagonIconId", `Sets the player's paragon icon id`, "player", [new LibraryFunctionParameter("paragon icon id", `the paragon rank id`, true)], true, false, `player SetParagonIconId( 1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetParagonRank", `Sets the player's paragon rank`, "player", [new LibraryFunctionParameter("paragon rank id", `the paragon rank id`, true)], true, false, `player SetParagonRank( 1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPerk", `give the specified perk`, "player", [new LibraryFunctionParameter("perk name", `the perk to give`, true)], true, false, `player SetPerk( "specialty_gpsjammer" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlacementHint", `Sets the placement hint string that will be displayed for this player.`, "player", [new LibraryFunctionParameter("onoff", `true if the hint should say that the weapon can be placed, false if not`, true)], true, false, `player SetPlacementHint( turret.canBePlaced )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerAngles", `Set the player's view angles`, "player", [new LibraryFunctionParameter("angles", `The view angles to set`, true)], true, false, `player SetPlayerAngles( v_angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerRenderOptions", `Sets the player render options`, "player", [new LibraryFunctionParameter("options", `The player render options`, true)], true, false, `self SetPlayerRenderOptions( playerRenderOptions );	`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRank", `Sets the player's rank and prestige level`, "player", [new LibraryFunctionParameter("rank id", `the rank id`, true), new LibraryFunctionParameter("prestige level", `The prestige level`, false)], true, false, `player SetRank( 1, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRiotshieldFailHint", `Set riot shield fail hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetRiotshieldFailHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpawnWeapon", `Set the weapon that this player will spawn with`, "player", [new LibraryFunctionParameter("weapon name", `The name of the weapon to spawn with`, true)], true, false, `self SetSpawnWeapon( "ak47" )during prematch period or grace period in mp)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpreadOverride", `Set the player's aim spread `, "player", [new LibraryFunctionParameter("value", `The value to set`, true)], true, false, `self SetSpreadOverride( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSprintCooldown", `Set the player's sprint cooldown duration`, "player", [new LibraryFunctionParameter("duration", `The duration to set`, true)], true, false, `self SetSprintCooldown( 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSprintDuration", `Set the player's sprint duration`, "player", [new LibraryFunctionParameter("duration", `The duration to set`, true)], true, false, `self SetSprintDuration( 4 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSunShadowSplitDistance", `Sets the sun shadow split distance for the player`, "player", [new LibraryFunctionParameter("distance", `split distance. Setting of 0 reverts to the default split distance.`, true)], true, false, `player SetSunShadowSplitDistance( 200 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTacticalWheel", `Sets whether this player will be able to use the cybercom tactical wheel or not`, "player", [new LibraryFunctionParameter("enabled", `turn on or off`, true)], true, false, `player SetTacticalWheel( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetAlreadyInUseHint", `Set  target already in use failure hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetTargetAlreadyInUseHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetAlreadyTargetedHint", `Set target already being targeted hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetTargetAlreadyTargetedHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetedEntityEndTime", `Set targeted entity end time, for use on the client side in the UI. `, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("endtime", `The end time of the targeted entity`, true)], true, false, `self SetTargetedEntityEndTime( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetedMissilesRemaining", `Set targeted entity missiles remaining, for use on the client side in the UI. `, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("missilesRemaining", `The amount of missiles remaining to destroy the target`, true)], true, false, `self SetTargetedMissilesRemaining( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetingAbortedHint", `Set targeting aborted hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetDisabledTargetHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetOORHint", `Set out of range failure hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetTargetOORHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetWrongTypeHint", `Set target validity failure hint`, "player", [new LibraryFunctionParameter("weapon", `: Weapon to use for the event`, false)], true, false, `self SetTargetWrongTypeHint()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleDamageMeter", `Sets the vehicle damage meter`, "player", [new LibraryFunctionParameter("damage", `the amount of damage normalized 0..1`, true)], true, false, `player SetRefEndTime( killstreaEndTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleDrivableDuration", `Sets the drivable duration for the players vehicle (intended for use with client side display purposes)`, "player", [new LibraryFunctionParameter("duration", `the drivable duration in milliseconds`, true)], true, false, `player SetVehicleDrivableDuration( killstreakDuration )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleDrivableEndTime", `Sets the vehicle drivable end time.`, "player", [new LibraryFunctionParameter("end time", `the drivable end time in milliseconds`, true)], true, false, `player SetVehicleDrivableEndTime( killstreakEndTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleFocusEntity", `Sets the focus entity for a player driven vehicle (currently only supported by helicopters).  This will attempt to make the vehicle orient towards the focus target.`, "player", [new LibraryFunctionParameter("focus entity", `The entity to focus on`, true)], true, false, `player SetVehicleFocusEntity( focusEntity )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleLockedOnByEnt", `Sets the vehicle locked on by entity`, "player", [new LibraryFunctionParameter("entity", `an entity that acquired a missile lock on the player's vehicle`, true)], true, false, `player SetVehicleLockedOnByEnt( mostDangerousEnemyWithLockOn )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleWeaponWaitDuration", `Sets the weapon wait duration for the players vehicle (intended for use with client side display purposes)`, "player", [new LibraryFunctionParameter("duration", `the weapon reload (or recharge) duration in milliseconds`, true)], true, false, `player SetVehicleWeaponWaitDuration( reloadDuration )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleWeaponWaitEndTime", `Sets the vehicle weapon wait end time.`, "player", [new LibraryFunctionParameter("end time", `the weapon wait end time in milliseconds`, true)], true, false, `player SetVehicleWeaponWaitEndTime( weaponReloadEndTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVelocity", `Set the velocity of the player`, "player", [new LibraryFunctionParameter("velocity", `The velocity to set`, true)], true, false, `self setvelocity(force)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetViewClamp", `Set the view clamp for the player, only works during animscripted for now.  Ranges are relative to tag_camera.  Left, Right, Top, Bottom`, "player", [], true, false, `player SetViewClamp( 50, 50, 30, 30 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponAmmoClip", `Set the weapon's ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon`, true), new LibraryFunctionParameter("ammo", `The ammo count`, true)], true, false, `self SetWeaponAmmoClip( weapon, weapon.clipSize )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponAmmoFuel", `Set the weapon ammo fuel`, "player", [new LibraryFunctionParameter("weapon", `The weapon`, true), new LibraryFunctionParameter("fuel", `The ammo fuel amount`, true)], true, false, `self SetWeaponAmmoFuel( weapon, weapondata["fuel"] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponAmmoStock", `Set the weapon's ammo`, "player", [new LibraryFunctionParameter("weapon", `The weapon`, true), new LibraryFunctionParameter("ammo", `The new ammo count`, true)], true, false, `reviver SetWeaponAmmoStock( level.weaponReviveTool, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponFriendlyHacking", `Set the weapon lockon completion percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("isFriendlyHacking", `Set to true if a friendly is hacking the target`, true)], true, false, `self SetWeaponFriendlyTargetLocked( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponFriendlyTargeting", `Set the weapon lockon completion percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("isFriendlyTargeting", `Set to true if a friendly is targetting`, true)], true, false, `self SetWeaponFriendlyTargeting( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponFriendlyTargetLocked", `Set the weapon lockon completion percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("isFriendlyTargetLocked", `Set to true if a friendly is target locked`, true)], true, false, `self SetWeaponFriendlyTargetLocked( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponHackPercent", `Set the weapon hack completion percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("heat", `The heat percent to set`, true)], true, false, `self SetWeaponHackPercent( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponHeatPercent", `Set the weapon heat percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("heat", `The heat percent to set`, true)], true, false, `self SetWeaponHeatPercent( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponLockOnPercent", `Set the weapon lockon completion percentage`, "player", [new LibraryFunctionParameter("weapon", `The weapon (player should have this weapon)`, true), new LibraryFunctionParameter("heat", `The heat percent to set`, true)], true, false, `self SetWeaponLockOnPercent( weapon, 0.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWeaponOverheating", `Set the players Weapon Overheating value`, "player", [new LibraryFunctionParameter("overheat", `Whether the weapon is overheating.`, true), new LibraryFunctionParameter("heatval", `The new heatval of the weapon (0 to 100).`, true), new LibraryFunctionParameter("weapon", `If present set this specific weapon otherwise set the player's current weapon.`, false)], true, false, `self SetWeaponOverheating( weapondata["overheat"], weapondata["heat"], weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ShowViewModel", `Show the player's current view model.`, "player", [], true, false, `player ShowViewModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SortHeldWeapons", `Sort the playerState heldWeapons to remove empty spaces`, "player", [], true, false, `e_player SortHeldWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SpawnSpectator", `Spawns the player, does not send any notifies`, "player", [new LibraryFunctionParameter("origin", `origin to spawn`, true), new LibraryFunctionParameter("angles", `angles to spawn`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SprintButtonPressed", `Check if the player is pressing the 'sprint' button.`, "player", [], true, false, `while( self SprintButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SprintUpRequired", `Force the player to release the sprint button before sprinting.`, "player", [], true, false, `self SprintUpRequired()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StanceButtonPressed", `Check if the player is pressing the 'stance' button.`, "player", [], true, false, `while( self StanceButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartCameraTween", `Start a camera tween, call this right before a camera pop to do a blend.`, null, [new LibraryFunctionParameter("time", `How long to do the blend."`, true)], true, false, `player StartCameraTween( 0.5 );`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartRevive", `Starts the revive sequence on a player. <reviver> is the one administering aid to the player this is called on.`, "player", [new LibraryFunctionParameter("reviver", `the player reviving the player this is called on`, true)], true, false, `playerInLastStand StartRevive( rescuer )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopCarryTurret", `UnLinks the auto turret from the player and sets it on the ground.`, "player", [new LibraryFunctionParameter("turret", `turret entity`, true), new LibraryFunctionParameter("origin", `The new origin of turret`, false), new LibraryFunctionParameter("angles", `The new angles of turret`, false)], true, false, `player StopCarryTurret( turret, origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopLocalSound", `Stops the local sound`, "player", [new LibraryFunctionParameter("sound name", `The name of the sound`, true)], true, false, `targetent StopLocalSound( level.missileDroneSoundStart )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopRevive", `Stops the revive behavior on a player when the revive did not complete. <reviver> is the one administering aid to the player this is called on.`, "player", [new LibraryFunctionParameter("reviver", `the player reviving the player this is called on`, true)], true, false, `playerInLastStand StopRevive( rescuer )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Suicide", `Kills the player immediately as a suicide`, "player", [], true, false, `self suicide()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchToOffHand", `Switch to the offhand weapon`, "player", [new LibraryFunctionParameter("weapon", `Weapon to switch to`, true)], true, false, `self SwitchToOffhand( primaryOffhand )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchToWeapon", `Switch to a different weapon or cycle weapons if no weapon is given`, "player", [new LibraryFunctionParameter("weapon object", `The weapon to switch to`, false)], true, false, `level.player SwitchToWeapon( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchToWeaponImmediate", `Switch to a different weapon or cycle weapons if no weapon is given without playing the dropping animation for current weapon`, "player", [new LibraryFunctionParameter("weapon object", `The weapon to switch to`, false)], true, false, `level.player SwitchToWeaponImmediate( weapon )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TakeAllWeapons", `Makes the player take all weapons`, "player", [], true, false, `player TakeAllWeapons()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TakeWeapon", `Take the weapon`, "player", [new LibraryFunctionParameter("weapon", `The weapon to take`, true), new LibraryFunctionParameter("ignore_attachments", `Only check the root weapon, ignore all the attachments.`, false)], true, false, `e_player TakeWeapon( w_spike_launcher )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ThrowButtonPressed", `Check if the player is pressing the 'throw' button.`, "player", [], true, false, `while( self ThrowButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TurnedHuman", `Called when client is turned back to human`, "client", [], true, false, `self TurnedHuman()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UndoLastStand", `Undo the last stand for the client`, "client", [], true, false, `self UndoLastStand()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnlinkFromMissile", `Unlinks a player camera from a missile`, "player", [], true, false, `player UnlinkFromMissile()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnlinkGuidedMissileCamera", `clear player eflags for the guided missile`, "player", [], true, false, `player UnlinkGuidedMissileCamera()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UnSetPerk", `takes the specified perk from the player`, "player", [new LibraryFunctionParameter("perk name", `the perk to unset`, true)], true, false, `player UnSetPerk( "specialty_gpsjammer" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UpdateWeaponOptions", `Update weapon options for a weapon that the player has`, "player", [new LibraryFunctionParameter("weapon name", `The weapon name to give to the player`, true), new LibraryFunctionParameter("weapon options", `options value computed using calcweaponoptions call`, false)], true, false, `player UpdateWeaponOptions( "m1garand", player calcWeaponOptions() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseButtonPressed", `Check if the player is pressing the use button`, "player", [], true, false, `if ( self UseButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VehicleMoveUpButtonPressed", `Check if the player is pressing the 'stance' button.`, "player", [], true, false, `while( self StanceButtonPressed() )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockCount", `returns the number of active lock objects (i.e. those with at least lock started or lock set active)`, "player", [], true, false, `player WeaponLockCount()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockDetect", `Sets the tartget as detected.  Will clear any existing hard lock.  Use WeaponLockStart() to start lock.`, "player", [new LibraryFunctionParameter("entity", `: An entity.`, true), new LibraryFunctionParameter("slot", `:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)`, false)], true, false, `player WeaponLockDetect( enemyGuy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockFinalize", `Locks player's weapon onto an entity.  Implies WeaponLockStart(), so this may be called to jump to a hard lock.`, "player", [new LibraryFunctionParameter("entity", `: An entity.`, true), new LibraryFunctionParameter("slot", `:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)`, false)], true, false, `player WeaponLockFinalize( enemyGuy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockFree", `Clears player's weapon lock.`, "player", [new LibraryFunctionParameter("slot", `The weapon slot. Default is 0`, false)], true, false, `player WeaponLockClear()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockNoClearance", `When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that there is an obstruction.`, "player", [new LibraryFunctionParameter("bool", `: true or false.`, true), new LibraryFunctionParameter("slot", `The weapon slot. Default is 0`, false)], true, false, `player WeaponLockNoClearance( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockRemoveSlot", `removes the given slot values and compresses the remaining slots  (i.e. 1,2,3 with 2 removed becomes 1,3,blank)`, "player", [new LibraryFunctionParameter("slot", `The weapon slot. Default is 0`, true)], true, false, `player WeaponLockGetFlags()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockStart", `Begins player's weapon lockon sequence (hud effects, etc).  Will clear any existing hard lock.  Use WeaponLockFinalize() to complete lock.`, "player", [new LibraryFunctionParameter("entity", `: An entity.`, true), new LibraryFunctionParameter("slot", `:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)`, false)], true, false, `player WeaponLockStart( enemyGuy )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponLockTargetTooClose", `When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that they are too close.`, "player", [new LibraryFunctionParameter("bool", `: true or false.`, true), new LibraryFunctionParameter("slot", `The weapon slot. Default is 0`, false)], true, false, `player WeaponLockTargetTooClose( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponPlayEjectBrass", `Play the eject brass FX for a weapon.`, "player", [], true, false, `player WeaponPlayEjectBrass()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("WeaponSwitchButtonPressed", `Check if the player is pressing the weapon switch button`, "player", [], true, false, `if ( self WeaponSwitchButtonPressed() ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ChangeFontScaleOverTime", `Set a hud element to transition in fontScale over time.  Normally setting the fontScale of an element causes an immediate visual change. However, if the fontScale gets set within <time> after calling ChangeFontScaleOverTime, then the hud element will transition to the new fontScale over the remaining <time>.`, "hud_element", [new LibraryFunctionParameter("time", `The time to scale the element font in seconds`, true)], true, false, `level.introstring1 ChangeFontScaleOverTime( 1.2 );  level.introstring1.fontScale = 0.3;  // This will transition the fontScale from whatever it was before to the new value of 0.3 over 1.2 seconds.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearTargetEnt", `Clear this waypoint from targetting an entity.`, "hud_element", [], true, false, `waypoint ClearTargetEnt()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CloseLUIMenu", `Close the LUI menu specified.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("menuIndex", `Menu ID received from CreateLUIMenu.`, true)], false, true, `CloseLUIMenu( localClientNum, menuIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateLUIMenu", `Creates a LUI menu to be opened later with OpenLUIMenu.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("name", `Name of the menu to create.`, true)], false, true, `CreateLUIMenu( localClientNum, "ScriptDebugMenu")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateUIModel", `Creates and returns a UIModel from a parent model.`, null, [new LibraryFunctionParameter("parentModel", `The parent model of the model to retrieve.`, true), new LibraryFunctionParameter("newPathName", `The name/path of the new model to create.`, true)], false, true, `CreateUIModel( gameScoreModel, "enZemeyScore" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Destroy", `Remove this Hud element altogether.`, "hud_element", [], true, false, `self.bombstopwatch Destroy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FadeOverTime", `Set a hud element to transition in color (or alpha) over time.  Normally setting the color (or alpha) of an element causes an immediate visual change. However, if the color (or alpha) gets set within <time> after calling fadeOverTime, then the hud element will transition to the new color over the remaining <time>.`, "hud_element", [new LibraryFunctionParameter("time", `The time to fade the element in seconds`, true)], true, false, `level.introstring1 FadeOverTime( 1.2 );  level.introstring1.alpha = 0.3;  // This will transition the alpha from whatever it was before to the new value of 0.3 over 1.2 seconds.`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FreeUIModel", `Frees a UIModel.`, null, [new LibraryFunctionParameter("modelToFree", `The model to free.`, true)], false, true, `FreeUIModel( gameScoreModel )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGlobalUIModel", `Returns the gloabl UIModel.`, null, [], false, true, `GetGlobalModel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLUIMenu", `Gets the first instance found of a given menu name active for the given client (undefined if not found)`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("menuName", `Menu name`, true)], false, true, `menuIndex = GetLUIMenu( localClientNum, "HudElementImage" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLUIMenuData", `Gets data from a LUI menu.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("menuIndex", `Menu ID received from CreateLUIMenu.`, true), new LibraryFunctionParameter("menuDataName", `Menu Data Name linked to the UIModel.`, true)], false, true, `modelValue = GetLUIMenuData( localClientNum, menuIndex, "title" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTextWidth", `Returned the width of the text in the hudelem.`, "hud_element", [], true, false, `width = elem GetTextWidth()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetUIModel", `Returns a UIModel from the parent model passed in and the name of the model to retrieve.`, null, [new LibraryFunctionParameter("parentModel", `The parent model of the model to retrieve.`, true), new LibraryFunctionParameter("lookupModelName", `The name of the model to retrieve.`, true)], false, true, `GetUIModel( gameScoreModel, "enemeyScore" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetUIModelForController", `Returns the UIModel from the controller root.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true)], false, true, `GetUIModelForController( localClientNum )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetUIModelValue", `Returns the value of the UIModel passed in.`, null, [new LibraryFunctionParameter("model", `Model of the value to retrieve.`, true)], false, true, `GetUIModelValue( gameScoreModel )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsLuiEnabled", `true if lui system has the input focus`, null, [], false, true, `if( IsLuiEnabled() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LuiDisable", `user input is removed from lui system`, null, [new LibraryFunctionParameter("localclientnum", `The local client`, true)], false, true, `LuiDisable( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LuiEnable", `user input is handed to lui system until returned`, null, [new LibraryFunctionParameter("localclientnum", `The local client`, true), new LibraryFunctionParameter("menuname", `The name of the menu to enable`, true)], false, true, `LuiEnable("overlay")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("LuiLoad", `Loads a lui file, making the menus available for addition`, null, [], false, true, `LuiLoad("overlay")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MoveOverTime", `Set a hud element to move over time.`, "hud_element", [new LibraryFunctionParameter("time", `The time to move the element in seconds`, true)], true, false, `newStr MoveOverTime( timer )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewClientHudElem", `Create a new hud element for a particular client`, null, [new LibraryFunctionParameter("client", `The client for whom the hud element is created.`, true)], true, false, `self.kc_topbar = NewClientHudElem(self)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewDamageIndicatorHudElem", `Create a new hud element for a particular client`, null, [new LibraryFunctionParameter("client", `The client for whom the hud element is created.`, true)], true, false, `self.kc_topbar = NewClientHudElem(self)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewDebugHudElem", `undefined`, null, [], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewHudElem", `Create a new hud element`, null, [], true, false, `overlay = NewHudElem()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewScoreHudElem", `Create a new score hud element for a particular client`, null, [new LibraryFunctionParameter("client", `The client for whom the hud element is created.`, true)], true, false, `self.hud_rankscroreupdate = NewScoreHudElem(self)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("NewTeamHudElem", `Create a new hud element for a particular team`, null, [new LibraryFunctionParameter("team", `The team for whom the hud element is created. Must be 'axis', 'allies' or 'spectator'`, true)], true, false, `level.progressbar_allies_neutralize = NewTeamHudElem( "axis" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OpenLUIMenu", `Opens a loaded LUI menu.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("menuIndex", `Menu ID received from CreateLUIMenu.`, true)], false, true, `OpenLUIMenu( localClientNum, menuIndex )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("OpenLUIPopup", `Opens a loaded LUI menu.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("name", `Name of the popup menu to open.`, true)], false, true, `OpenLUIPopup( localClientNum, "SomePopup")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PopulateScriptDebugMenu", `Sets a UIModel from the model being passed in.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("array", `Array of menu item names for the debug menu.`, true)], false, true, `PopulateScriptDebugMenu( localClientNum, menu_items_array )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Reset", `Reset a HUD element to its default state.`, "hud_element", [], true, false, `element Reset()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ScaleOverTime", `Set a hud element to scale over time.`, "hud_element", [new LibraryFunctionParameter("time", `The time to scale the element in seconds`, true), new LibraryFunctionParameter("width", `The new width of the material.`, true), new LibraryFunctionParameter("height", `The new height of the material.`, true)], true, false, `other.progressbar ScaleOverTime( level.planttime, level.barsize, 8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClock", `Set a clock HUD element to count down over a time period.`, "hud_clock_element", [new LibraryFunctionParameter("time", `The new timer time in seconds to count down`, true), new LibraryFunctionParameter("time", `The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.`, true), new LibraryFunctionParameter("material", `The material for the hud clock`, true), new LibraryFunctionParameter("width", `The width of the material.`, false), new LibraryFunctionParameter("height", `The height of the material.`, false)], true, false, `level.bombstopwatch SetClock( 5, 60, "hudStopwatch", 64, 64 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetClockUp", `Set a clock HUD element to count up over a time period.`, "hud_clock_element", [new LibraryFunctionParameter("time", `The new timer time in seconds to count up`, true), new LibraryFunctionParameter("full time", `The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.`, true), new LibraryFunctionParameter("material", `The material for the hud clock`, true), new LibraryFunctionParameter("width", `The width of the material.`, false), new LibraryFunctionParameter("height", `The height of the material.`, false)], true, false, `level.bombstopwatch SetClockUp( 5, 60, "hudStopwatch", 64, 64 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetCOD7DecodeFX", `Set the hudelem string to display with a decode effect.`, "hud_element", [new LibraryFunctionParameter("decodeTime", `Time for each letter to decode.`, true), new LibraryFunctionParameter("decayStart", `Time to wait before starting the text decay effect.`, true), new LibraryFunctionParameter("decayDuration", `How long to spend decaying.`, true)], true, false, `elem SetCOD7DecodeFX( 2000, 600 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetExtraCamRenderReady", `Sets an extra cam render job to start processing`, null, [new LibraryFunctionParameter("jobIdx", `Extra Cam Render job index.`, true)], false, true, `StartExtraCamRender( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGameTypeString", `Set the game type string for the game`, "hud_element", [new LibraryFunctionParameter("game type", `A string containing the game type`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLUIMenuData", `Set data for LUI menu.`, null, [new LibraryFunctionParameter("localClientNum", `Number of the local client on the machine.`, true), new LibraryFunctionParameter("menuIndex", `Menu ID received from CreateLUIMenu.`, true), new LibraryFunctionParameter("menuDataName", `Menu Data Name linked to the UIModel.`, true), new LibraryFunctionParameter("menuDataValue", `Value for that piece of menu data.`, true)], false, true, `SetLUIMenuData( localClientNum, menuIndex, "title", "Some Title" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMapNameString", `Set the map name string`, "hud_element", [new LibraryFunctionParameter("map name", `A string containing the map name`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPerks", `Sets a hud element to be a perks element.`, "hud_element", [new LibraryFunctionParameter("client", `client we should be showing the perks of`, true)], true, false, `hudelement SetPerks( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlayerNameString", `Set the player name string for a HUD element`, "hud_element", [new LibraryFunctionParameter("player", `A player entity`, true)], true, false, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPulseFX", `Set the hudelem string to display with a "Pulse" effect.`, "hud_element", [new LibraryFunctionParameter("speed", `Time (in milliseconds) each letter takes to type out.`, true), new LibraryFunctionParameter("decayStart", `Time to wait before starting the string's decay effect.`, true), new LibraryFunctionParameter("decayDuration", `How long to spend decaying.`, true)], true, false, `elem SetPulseFX( 40, 2000, 600 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRedactFX", `Set the hudelem string to display with a redact effect.`, "hud_element", [new LibraryFunctionParameter("decayStart", `Time to wait before starting the text decay effect.`, true), new LibraryFunctionParameter("decayDuration", `How long to spend decaying.`, true), new LibraryFunctionParameter("redactDecayStart", `Time to wait before starting the redact decay effect.`, true), new LibraryFunctionParameter("redactDecayDuration", `How long to spend decaying.`, true)], true, false, `elem SetRedactFX( 2000, 600, 3000, 400 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetShader", `Set the material for this Hud Element`, "hud_element", [new LibraryFunctionParameter("materialname", `A the name of the material to set`, true), new LibraryFunctionParameter("width", `The width of the material.`, false), new LibraryFunctionParameter("height", `The height of the material.`, false)], true, false, `waypoint SetShader( "playbook_objective_stop", 15, 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetEnt", `Set the entity that this waypoint should target.  In MP, entity should already be a broadcasting entity, as with Objective_OnEntity().`, "hud_element", [new LibraryFunctionParameter("entity", `Entity to Target`, true)], true, false, `waypoint SetTargetEnt( level.axis.bombcarrier )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTenthsTimer", `Set a timer HUD element to count down in tenths of a second`, "hud_timer_element", [new LibraryFunctionParameter("time", `The new timer time`, true)], true, false, `self.kc_timer SetTenthsTimer( self.archivetime - delay )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTenthsTimerUp", `Set a timer HUD element to count up in tenths of a second`, "hud_timer_element", [new LibraryFunctionParameter("time", `The new timer time`, true)], true, false, `self.kc_timer SetTenthsTimerUp( self.archivetime - delay )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetText", `Set HUD text for this element.`, "hud_element", [new LibraryFunctionParameter("text", `A localized text reference`, true)], true, false, `level.introstring1 SetText(string1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTimer", `Set a timer HUD element to count down`, "hud_timer_element", [new LibraryFunctionParameter("time", `The new timer time`, true)], true, false, `level.reinforcement_hud SetTimer( level.counter )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTimerUp", `Set a timer HUD element to count up`, "hud_timer_element", [new LibraryFunctionParameter("time", `The new timer time`, true)], true, false, `level.reinforcement_hud SetTimerUp( level.counter )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTypewriterFX", `Set the hudelem string to display with a redact effect.`, "hud_element", [new LibraryFunctionParameter("letterTime", `Time it take for each letter to type in.`, true), new LibraryFunctionParameter("decayStart", `Time to wait before starting the text decay effect.`, true), new LibraryFunctionParameter("decayDuration", `How long to spend decaying.`, true)], true, false, `elem SetTypewriterFX( 100, 600, 3000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetUIModelValue", `Sets a UIModel from the model being passed in.`, null, [new LibraryFunctionParameter("model", `Model of the value to set.`, true), new LibraryFunctionParameter("value", `Value to set.`, true)], false, true, `SetUIModelValue( gameScoreModel )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetValue", `Set a value HUD element to a given value.`, "hud_value_element", [new LibraryFunctionParameter("value", `The value to set the element to`, true)], true, false, `level.reinforcement_hud SetValue( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWarGameData", `Creates a WAR specific HUD progress element`, "hud_element", [new LibraryFunctionParameter("momentumProgress", `, <momentumMultiplier>, <momentumBlitzkriegTime>`, true)], true, false, `hudelement SetWarGameData( 0, 1, 30 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetWayPoint", `Sets a hud element to be a waypoint.`, "hud_element", [new LibraryFunctionParameter("constantSize", `boolean describing whether the hud element remains the same size`, true), new LibraryFunctionParameter("offscreenMaterialName", `Material to draw when waypoint is offscreen.`, false), new LibraryFunctionParameter("isDistanceShown", `boolean turning on/off player distance to waypoint display above the waypoint.`, false), new LibraryFunctionParameter("no offscreen", `boolean turning on/off arrow indicators when element is offscreen.`, false)], true, false, `newdeathicon SetWayPoint( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("array", `create an array`, null, [new LibraryFunctionParameter("args", `one or more args to add to the array`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayCombine", `combine two arrays into and returns one new array`, null, [new LibraryFunctionParameter("array1", `array to operate on`, true), new LibraryFunctionParameter("array2", `array to operate on`, true), new LibraryFunctionParameter("allowdupes", `if true then allow duplicate entries, otherwise prune them out when combining`, true), new LibraryFunctionParameter("preserve_keys", `if true then preserve the keys (only for string keys) otherwise renumber when combining`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayCopy", `returns a copy of an array`, null, [new LibraryFunctionParameter("array1", `array to operate on`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayGetClosest", `Returns the entity/vector that is closest to the <origin> from the <array>.`, null, [new LibraryFunctionParameter("origin", `The origin to get closest from`, true), new LibraryFunctionParameter("array", `The array to search in`, true), new LibraryFunctionParameter("dist", `The minimum distance to check when finding closest (has to be positive)`, false)], true, true, `ent = ArrayGetClosest( player.origin, a_enemies )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayGetFarthest", `Returns the entity/vector that is farthest to the <origin> from the <array>.`, null, [new LibraryFunctionParameter("origin", `The origin to get farthest from`, true), new LibraryFunctionParameter("array", `The array to search in`, true), new LibraryFunctionParameter("dist", `The maximum distance when finding farthest (has to be positive)`, false)], true, true, `ent = ArrayGetFarthest( player.origin, a_enemies )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayInsert", `insert a value into an array at a given index`, null, [new LibraryFunctionParameter("array", `array to operate on`, true), new LibraryFunctionParameter("value", `value to insert`, true), new LibraryFunctionParameter("index", `index at which to insert the value (must be an integer) - moves existing entries as required`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayIntersect", `Returns an array of values that are present in both arrays.`, null, [new LibraryFunctionParameter("array1", `An Array`, true), new LibraryFunctionParameter("array2", `An Array`, true), new LibraryFunctionParameter("matchKeys", `Optionally returns an array of matching key/value pairs from the two input arrays (preserving the keys).`, false)], true, true, `newArray = ArrayIntersect( array1, array2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayRemoveIndex", `Remove a value from an array at a given index`, null, [new LibraryFunctionParameter("array", `array to operate on`, true), new LibraryFunctionParameter("index", `index of value to remove`, true), new LibraryFunctionParameter("preserve_keys", `defaults to false, if true then it preserves the keys - otherwise creates integer keys`, false)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ArrayRemoveValue", `Remove a value from an array (may affect multiple indexes)`, null, [new LibraryFunctionParameter("array", `array to operate on`, true), new LibraryFunctionParameter("value", `value to remove (may be undefined)`, true), new LibraryFunctionParameter("preserve_keys", `defaults to false, if true then it preserves the keys - otherwise creates integer keys`, false)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Assert", `Assert that the given statement is correct. The function will throw a script error if this is false.`, null, [new LibraryFunctionParameter("value", `statement that is asserted to be correct`, true), new LibraryFunctionParameter("desc", `string describing the nature of the assert`, false)], true, true, `Assert( enemyInSight == true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AssertMsg", `Throws a script error with the given message.`, null, [new LibraryFunctionParameter("message", `error message`, true)], true, true, `AssertMsg( "Unhandled enemy type." )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("associativeArray", `creates an associativeArray`, null, [new LibraryFunctionParameter("key_i", `the string key for the next value`, false), new LibraryFunctionParameter("value_i", `the value for the previous key`, false)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClientHasSnapshot", `Returns true if client has recieved a snapshot from the server`, null, [new LibraryFunctionParameter("local client", `the desired Local Client number.`, true)], false, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ErrorMsg", `Throws a non-fatal script error with the given message.`, null, [new LibraryFunctionParameter("message", `error message`, true)], true, true, `ErrorMsg( "Unhandled enemy type." )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetArrayKeys", `Returns an array consisting of the keys of the input array.`, null, [new LibraryFunctionParameter("array", `Input array`, true)], true, true, `result = GetArrayKeys( array )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachmentTableIndex", `Returns the attachment table index for the attachment name`, null, [new LibraryFunctionParameter("attachmentRef", `Attachment Reference`, true)], true, true, `attachmentIndex = GetAttachmentTableIndex( "reflex" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDvarFloat", `Gets the value of a dvar.`, null, [new LibraryFunctionParameter("dvar", `The dvar name as a string or hash.`, true), new LibraryFunctionParameter("default_value", `The value to be returned if the dvar doesn't exist, must be an float.`, false)], true, true, `GetDvarFloat( "r_eyesAdjust", 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDvarInt", `Gets the value of a dvar.`, null, [new LibraryFunctionParameter("dvar", `The dvar name as a string or hash.`, true), new LibraryFunctionParameter("default_value", `The value to be returned if the dvar doesn't exist, must be an integer.`, false)], true, true, `GetDvarInt( "r_eyesAdjust", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDvarString", `Gets the value of a dvar.`, null, [new LibraryFunctionParameter("dvar", `The dvar name as a string or hash.`, true), new LibraryFunctionParameter("default_value", `The value to be returned if the dvar doesn't exist, must be a string.`, false)], true, true, `GetDvarString( "r_eyesAdjust", "yes" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDvarVector", `Gets the value of a dvar.`, null, [new LibraryFunctionParameter("dvar", `The dvar name as a string or hash.`, true), new LibraryFunctionParameter("default_value", `The value to be returned if the dvar doesn't exist, must be an vector.`, false)], true, true, `GetDvarVector( "r_eyesAdjust", (1,0,0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetFirstArrayKey", `Returns the first key of the input array.`, null, [new LibraryFunctionParameter("array", `Input array`, true)], true, true, `key = GetFirstArrayKey( array )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetItemIndexFromRef", `Returns the item index for the specified item reference`, null, [new LibraryFunctionParameter("itemRef", `Item Reference`, true)], true, true, `itemIndex = GetItemIndexFromRef( <itemRef> )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetLastArrayKey", `Returns the last key of the input array.`, null, [new LibraryFunctionParameter("array", `Input array`, true)], true, true, `key = GetLastArrayKey( array )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMapCenter", `Returns the map center`, null, [], false, true, `center = GetMapCenter()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNextArrayKey", `Returns the next key of the input array, after the specified key.`, null, [new LibraryFunctionParameter("array", `Input array`, true), new LibraryFunctionParameter("key", `The given key`, true)], true, true, `key = GetNextArrayKey( array, key )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPrevArrayKey", `Returns the prev key of the input array, before the specified key.`, null, [new LibraryFunctionParameter("array", `Input array`, true), new LibraryFunctionParameter("key", `The given key`, true)], true, true, `key = GetPrevArrayKey( array, key )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetServerTime", `Returns the time according to the server`, null, [new LibraryFunctionParameter("localClientNum", `The local client`, true)], false, true, `GetServerTime(localClientNum)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSubStr", `Returns the substring of characters >= <start index> and < <end index>. <end index> is optional.`, null, [new LibraryFunctionParameter("string", `The input string`, true), new LibraryFunctionParameter("start index", `The start index of the substring`, true), new LibraryFunctionParameter("end index", `The end index of the substring`, false)], true, true, `name = getSubStr( playerwarp_string, 8 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSystemTime", `Returns the time of the system in a vector where the 0 index is hours (in 24hr time), 1 is minutes, and 2 is seconds`, null, [new LibraryFunctionParameter("ignore timezone", `Set to non-zero to ignore the timezone information`, false)], false, true, `GetSystemTime(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsArray", `Checks whether this entity/variable is an array`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a array`, true)], true, true, `if ( isarray ( gun_owner )) ... `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsClass", `Checks whether this entity/variable is a class object`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a class`, true)], true, true, `if ( isclass(self)) ... `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFloat", `Checks whether this entity/variable is a float`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a float`, true)], true, true, `if ( IsFloat( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsFunctionPtr", `Checks whether given variable is of type Function Pointer in script, useful to differentiate between Var and FuncPtr in Script.`, null, [new LibraryFunctionParameter("variable", `variable to test`, true)], true, true, `if ( IsFunctionPtr( myFuncPtr ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInArray", `searches an array to determine if a given value is present in that array`, null, [new LibraryFunctionParameter("array", `array to search`, true), new LibraryFunctionParameter("value", `value to search for`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInt", `Checks whether this entity/variable is an int`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be an int`, true)], true, true, `if ( IsInt( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsMatureContentEnabled", `Returns true if mature content is enabled`, null, [], false, true, `if( IsMatureContentEnabled() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsShowBloodEnabled", `Returns true if blood is enabled`, null, [], false, true, `if( IsShowBloodEnabled() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsShowGibsEnabled", `Returns true if gibs is enabled`, null, [], false, true, `if( IsShowGibsEnabled() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsString", `Checks whether this entity/variable is a string`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a string`, true)], true, true, `if ( isstring ( gun_owner )) ... `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsStruct", `Checks whether this variable is a struct object`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a struct`, true)], true, true, `if ( isstruct(self)) ... `, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsSubStr", `Returns true/false if <substring> is a substring of <string>. Case sensitive.`, null, [], true, true, `has_str = IsSubStr( "my_string", "str" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("istring", `Casts a string to an istring`, null, [new LibraryFunctionParameter("value", `A string to cast to an istring`, true)], true, true, `x = istring( String )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVec", `Checks whether this entity/variable is a vector`, null, [new LibraryFunctionParameter("variable", `variable that may or may not be a vector`, true)], true, true, `if ( IsVec( gun_owner ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsWeapon", `Checks whether this is a weapon object`, null, [new LibraryFunctionParameter("weapon_object", `An parameter that may be a weapon object`, true)], true, true, `if ( IsWeapon( current_weapon ) ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeLocalizedString", `Make a localized string of the given string`, null, [new LibraryFunctionParameter("string", `The string to translate`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SplitArgs", `Splits a space seperated string, returning an array of each word in the string.`, null, [new LibraryFunctionParameter("arg string", `space seperated string.`, true)], false, true, `args = SplitArgs("First second third fourth")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("sprintf", `Replaces field specifiers in a string with values passed in, returns result string format specifiers take the form of {[n]} in the source string where [n] indicates which value to print, e.g. 0 is the first user arg`, null, [new LibraryFunctionParameter("string", `The string to translate`, true), new LibraryFunctionParameter("args", `zero or more arguments`, false)], true, true, `sprintf("{0} is the first string","first")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrEndsWith", `Returns true/false if <string> ends with <substring>. Case sensitive.`, null, [new LibraryFunctionParameter("string", `String to search`, true), new LibraryFunctionParameter("substring", `Substring to search with.`, true)], true, true, `ends_with = StrEndsWith( "my_string", "_string" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrIsFloat", `Check if a string is a float.`, null, [new LibraryFunctionParameter("string", `: The string to check.`, true)], true, true, `StrIsFloat( "1.2" ); // true`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrIsInt", `Check if a string is an int.`, null, [new LibraryFunctionParameter("string", `: The string to check.`, true)], true, true, `StrIsInt( "1" ); // true`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrIsNumber", `Check if a string is a number.`, null, [new LibraryFunctionParameter("string", `: The string to check.`, true)], true, true, `StrIsNumber( "1.2" ); // true`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrStartsWith", `Returns true/false if <string> starts with <substring>. Case sensitive.`, null, [new LibraryFunctionParameter("string", `String to search`, true), new LibraryFunctionParameter("substring", `Substring to search with.`, true)], true, true, `starts_with = StrStartsWith( "my_string", "my_" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrStrip", `Strip whitespace from right and left side of string.`, null, [new LibraryFunctionParameter("string", `: The string to strip.`, true)], true, true, `StrStrip( "    hq_cleared   " ); // 'hq_cleared'`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrTok", `Tokenizes <string> by the delimiters <delim>. Returns the array of string tokens.`, null, [new LibraryFunctionParameter("string", `The input string`, true), new LibraryFunctionParameter("delim", `The delimiter to tokenize by`, true)], true, true, `my_string_array = StrTok( "my_string; my_string_2", "; " )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StrTok2", `Tokenizes <string> by a single delimiter string.  doesn't treat the delimiter string as a series of characters, but as a string`, null, [new LibraryFunctionParameter("string", `The input string`, true), new LibraryFunctionParameter("delim", `The delimiter to tokenize by`, true), new LibraryFunctionParameter("case_sensitive", `true if test is case sensitive`, false)], true, true, `my_string_array = StrTok2( "my_string foo; my_string_2", "foo; " )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookup", `look up a row in a table and pull out a particular column from that row`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true), new LibraryFunctionParameter("search column num", `The column number of the stats table to search through`, true), new LibraryFunctionParameter("search value", `The value to use when searching the <search column num>`, true), new LibraryFunctionParameter("return value column num", `The column number value to return after we find the correct row`, true)], true, true, `TableLookup( "mp/statstable.csv", 0, "INDEX_KILLS", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupColumnCount", `look up the number of columns in a table`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true)], true, true, `TableLookup( "mp/statstable.csv" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupColumnForRow", `look up a particular row and column in a table`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true), new LibraryFunctionParameter("search row num", `The row number of the string table to search through`, true), new LibraryFunctionParameter("search column num", `The column number of the string table to search through`, true)], true, true, `TableLookupColumnForRow( "gamedata/tables/mp/exampleStringTable.csv", 101, 7 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupFindCoreAsset", `Find core asset index for a stringtable`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true)], true, true, `TableLookupRowNum( "mp/statstable.csv" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupIString", `look up a row in a table and pull out a particular column from that row`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true), new LibraryFunctionParameter("search column num", `The column number of the stats table to search through`, true), new LibraryFunctionParameter("search value", `The value to use when searching the <search column num>`, true), new LibraryFunctionParameter("return value column num", `The column number value to return after we find the correct row`, true)], true, true, `TableLookupIString( "mp/statstable.csv", 0, "INDEX_KILLS", 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupRow", `Return an array of strings for the columns in that row`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true), new LibraryFunctionParameter("row num", `The row num of the row in table to return`, true)], true, true, `undefined`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupRowCount", `look up the number of rows in a table`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true)], true, true, `TableLookup( "mp/statstable.csv" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TableLookupRowNum", `look up a row number in a table`, null, [new LibraryFunctionParameter("filename", `The table to look up`, true), new LibraryFunctionParameter("search column num", `The column number of the stats table to search through`, true), new LibraryFunctionParameter("search value", `The value to use when searching the <search column num>`, true)], true, true, `TableLookupRowNum( "mp/statstable.csv", 0, "INDEX_KILLS" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Throw", `force a script exception (from a builtin call)`, null, [], true, true, `throw( )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ToLower", `Converts <string> to a lower case string which is returned.`, null, [new LibraryFunctionParameter("string", `(string) Base string`, true)], true, true, `my_string = ToLower( "MY_STRING" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ToUpper", `Converts <string> to a upper case string which is returned.`, null, [new LibraryFunctionParameter("string", `(string) Base string`, true)], true, true, `my_string = ToUpper( "lower" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("AttachPath", `Attaches this vehicle to the given path.`, "vehicle", [new LibraryFunctionParameter("node", `A node on the path to attach.`, true)], true, false, `bomber AttachPath( aBomberPaths[i] )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CancelAIMove", `Tell the vehicle to stop moving towards its current goal position.`, "vehicle", [], true, false, `eTank CancelAIMove()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearDefaultPitch", `Clears the desired default pitch for a vehicle.`, "vehicle", [], true, false, `level.heli cleardefaultpitch()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearGoalYaw", `Clear the goal yaw direction for this vehicle.`, "vehicle", [], true, false, `level.flak1 ClearGoalYaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearGunnerTarget", `Clear the target for the vehicle turret.`, "vehicle", [new LibraryFunctionParameter("gunner index", `Which gun, 0-3.`, false)], true, false, `eTank ClearGunnerTarget(0)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearLookAtEnt", `Clear the entity or origin the vehicle is orienting towards.`, "vehicle", [], true, false, `heli clearLookAtEnt()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearTargetYaw", `Clear the target yaw direction for this vehicle.`, "vehicle", [], true, false, `level.flak1 cleartargetyaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearTurretTarget", `Clear the target for the vehicle turret.`, "vehicle", [new LibraryFunctionParameter("turret index", `0 for turret, 1-4 for gunners`, false)], true, false, `eTank ClearTurretTarget()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ClearVehGoalPos", `Clears the target position for this vehicle.`, "vehicle", [], true, false, `tank ClearVehGoalPos()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("CreateTrack", `Set the node enabled or disabled for vehicle pathfinding.  SetVehGoalPos will now return true or false if it can find a path.`, null, [new LibraryFunctionParameter("undefined", `undefined`, undefined)], true, false, `CreateTrack( track_node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableDriverFiring", `Enables or disables the driver's vehicle turret`, "vehicle", [], true, false, `tank DisableDriverFiring( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DisableGunnerFiring", `Enable or disable gunner firing`, "vehicle", [new LibraryFunctionParameter("gunner index", `The gunner to disable/enable`, true), new LibraryFunctionParameter("onoff", `true to disable, false otherwise`, true)], true, false, `tank DisableGunnerFiring( 1, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DrawTrajectory", `Draws the vehicles trajectory.`, "vehicle", [new LibraryFunctionParameter("show", `Whether to draw trajectory or not`, true)], true, false, `plane DrawTrajectory( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("DrivePath", `Starts the vehicle driving this path and uses the vehicle physics, not locked to the spline, can only achieve turns that the physics can handle.`, "vehicle", [new LibraryFunctionParameter("node index", `A node on the path to attach.`, false), new LibraryFunctionParameter("allow free drive", `This give the player free driving but script notifies when passing nodes on a vehcile spline`, false)], true, false, `huey DrivePath( start_node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FinishVehicleDamage", `Does damage to an vehicle - usually as part of the damage callback`, "vehicle", [new LibraryFunctionParameter("Inflictor", `The entity that causes the damage.(e.g. a turret)`, true), new LibraryFunctionParameter("Attacker", `The entity that is attacking.`, true), new LibraryFunctionParameter("Damage", `Integer specifying the amount of damage done`, true), new LibraryFunctionParameter("Damage Flags", `Integer specifying flags that are to be applied to the damage`, true), new LibraryFunctionParameter("Means Of Death", `Integer specifying the method of death`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true), new LibraryFunctionParameter("Point", `Point of damage`, true), new LibraryFunctionParameter("Direction", `(vector) The direction of the damage`, true), new LibraryFunctionParameter("Hit Loc", `The location of the hit`, true), new LibraryFunctionParameter("Offset Time", `The time offset for the damage`, true), new LibraryFunctionParameter("DamageFromUnderneath", `If the hit is underneath the vehicle`, true), new LibraryFunctionParameter("modelIndex", `which model in the dobj was hit`, true), new LibraryFunctionParameter("partIndex", `which bone was hit`, true), new LibraryFunctionParameter("damageteammates", `Whether to damage teammates or not`, true)], true, false, `self FinishVehicleDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, psOffsetTime, damageUnderneathVehicle, modelindex, partname, damageteammates )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FinishVehicleRadiusDamage", `Does damage to an vehicle - usually as part of the damage callback`, "vehicle", [new LibraryFunctionParameter("Inflictor", `The entity that causes the damage.(e.g. a turret)`, true), new LibraryFunctionParameter("Attacker", `The entity that is attacking.`, true), new LibraryFunctionParameter("Damage", `Integer specifying the amount of damage done`, true), new LibraryFunctionParameter("Inner Damage", `Integer specifying the amount of inner damage done`, true), new LibraryFunctionParameter("Outer Damage", `Integer specifying the amount of outer damage done`, true), new LibraryFunctionParameter("Damage Flags", `Integer specifying flags that are to be applied to the damage`, true), new LibraryFunctionParameter("Means Of Death", `Integer specifying the method of death`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true), new LibraryFunctionParameter("Point", `(vector) The Point of the damage`, true), new LibraryFunctionParameter("Radius", `(float) The radius of the damage`, true), new LibraryFunctionParameter("ConeRadius", `(float) The radius of the cone damage`, true), new LibraryFunctionParameter("ConeDirection", `(vector) The direction of the cone damage`, true), new LibraryFunctionParameter("Offset Time", `The time offset for the damage`, true)], true, false, `self FinishVehicleRadiusDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, fRadius, fConeRadius, fConeDir, psOffsetTime )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FireWeapon", `Fire the vehicle's weapon`, "vehicle", [new LibraryFunctionParameter("turret_index", `turret index, 0 being main turret, 1~4 being gunners`, false), new LibraryFunctionParameter("target ent", `A target entity for guided missiles`, false), new LibraryFunctionParameter("target offset", `Only used for projectile and bomb weapons`, false), new LibraryFunctionParameter("attacker", `real attacker who should take credit of this shot`, false)], true, false, `m_vehicle FireWeapon( 0, m_e_target, v_target_offset )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Flip180", `Flips this vehicle 180 (for going forwards / backwards along a path)`, "vehicle", [], true, false, `huey Flip180()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("FreeVehicle", `Frees this vehicle instance.  It will unlink any players occupying the vehicle. It will change the vehicle into a vehicle corpse.  It will send a death notify on the vehicle.  Once called the vehicle cannot move anymore.`, "vehicle", [], true, false, `self FreeVehicle()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAllVehicleNodes", `Gets all of the vehicle nodes in a level`, null, [], true, false, `nodes = GetAllVehicleNodes()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAngularVelocity", `Gets the current angular velocity.`, "vehicle", [], true, false, `self GetAngularVelocity()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetAttachPos", `Returns the origin and angles if the vehicle were to be attached to the path.  The origin and angles are returned as a vector array of size 2.  Origin is 1st and angles is 2nd.`, "vehicle", [new LibraryFunctionParameter("node index", `A node on the path to attach.`, true)], true, false, `pos = self GetAttachPos( node )origin = pos[0]angles = pos[1]`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetBrake", `Gets the brake value of a nitrous physics vehicle.`, "vehicle", [], true, false, `jeep getbrake()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetDefaultAcceleration", `Gets the acceleration value set in GDT.`, "vehicle", [], true, false, `accel = self GetDefaultAcceleration()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("getgoalspeedMPH", `Gets the goal speed in miles per hour.`, "vehicle", [], true, false, `self GetGoalSpeedMPH()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGoalYaw", `Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw`, "vehicle", [], true, false, `level.flak1 GetGoalYaw()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGunnerTargetEnt", `Gets the target entity for this gunner position.`, "vehicle", [new LibraryFunctionParameter("gunner index", `Which gun, 0-3.`, true)], true, false, `target = huey GetGunnerTurretEnt( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetGunnerTargetVec", `Get the target position for this vehicle turret gunner.`, "vehicle", [new LibraryFunctionParameter("gunner index", `which gun 0-3`, true)], true, false, `endpt = GetGunnerTargetVec( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHandBrake", `Gets the hand brake value of a nitrous physics vehicle.`, "vehicle", [], true, false, `jeep gethandbrake()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeliHeightLock", `Locks the heli to the height mesh`, "vehicle", [], true, false, `if ( vehicle GetHeliHeightLock( ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetHeliHeightLockHeight", `Gets the mesh height at a given point.`, "vehicle", [new LibraryFunctionParameter("point", `The point to check at`, true)], true, false, `maxheight = GetHeliHeightLockHeight( point )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetMaxSpeed", `Get the max speed of a vehicle. By default gets the script setting`, "vehicle", [new LibraryFunctionParameter("get gdt", `true to get the gdt setting and not the script set.`, false)], true, false, `heli GetMaxSpeed( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetNumVehicles", `Gets the number of vehicles entities in the level`, null, [], true, false, `vehicleCount = GetNumVehicles()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetOccupantSeat", `Get the seat index occupied by the given player.  -1 if player isn't in vehicle.`, "vehicle", [new LibraryFunctionParameter("player", `The player to get the seat index for`, true)], true, false, `isDriver = 0 == vehicle GetOccupantSeat( player )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathFixedOffset", `Gets a fixed offset from the path for a specific vehicle.`, "vehicle", [], true, false, `offset = huey GetPathFixedOffset()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPathVariableOffset", `Gets a variable offset from the path for a specific vehicle.`, "vehicle", [], true, false, `offset = huey GetPathVariableOffset()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetPhysAcceleration", `Gets the vehicles acceleration vector.`, "vehicle", [], true, false, `accel = plane GetPhysAccel()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetScriptBrake", `Gets the script brake value of a nitrous physics vehicle.`, "vehicle", [], true, false, `jeep getscriptbrake()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSeatFiringAngles", `Retrieve the angles specifying the direction in which bullets, projectiles, etc. will be emitted from the weapon when it is fired.`, "vehicle", [new LibraryFunctionParameter("seat index", `The seat to firing angles for`, true)], true, false, `turretBarrelAngles = tank GetSeatFiringAngles( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSeatFiringOrigin", `Retrieve the location at the end of the barrel where bullets, projectiles, etc. are emitted when the gun is fired.`, "vehicle", [new LibraryFunctionParameter("seat index", `The seat to firing origin for`, true)], true, false, `turretBarrelOrigin = tank GetSeatFiringOrigin( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSeatOccupant", `Get the entity occupying the given seat index.  Undefined if the seat is empty.`, "vehicle", [new LibraryFunctionParameter("seat", `0 driver, 1-4 gunners, 5-10 passengers`, true)], true, false, `driver = vehicle GetSeatOccupant( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpeed", `Gets the current speed in inches per second.`, "vehicle", [], true, false, `self GetSpeed()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSpeedMPH", `Gets the current speed in miles per hour.`, "vehicle", [], true, false, `self GetSpeedMPH()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetSteering", `Returns the steer factor of the vehicle.`, "vehicle", [], true, false, `self GetSteering()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetThrottle", `Returns the throttle factor of the vehicle.`, "vehicle", [], true, false, `self GetThrottle()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTimeFromVehicleNodeToNode", `The time it would take to go from start node to end node if traveling the spline speed.`, null, [new LibraryFunctionParameter("start_node", `The start node of the path`, true), new LibraryFunctionParameter("end_node", `The end node of the path`, true)], true, false, `time = GetTimeFromVehicleNodeToNode( start_node, end_node )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretHeatValue", `Get the current heat value for a vehicle weapon.`, "vehicle", [new LibraryFunctionParameter("gunner index", `which gun 0-3`, true)], true, false, `heat = self GetTurretHeatValue( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretLimitsYaw", `Get the furthest relative yaw angles the turret can aim, all numbers are positive`, "vehicle", [new LibraryFunctionParameter("turret index", `0 for turret, 1-4 for gunners`, false)], true, false, `limit = veh GetTurretLimits( 1 ); limitMin = -limit[0]; limitMax = limit[1]`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetTurretTargetVec", `Get the target position for this vehicle turret or gunner.`, "vehicle", [new LibraryFunctionParameter("turret index", `0 for turret, 1-4 for gunners`, false)], true, false, `endpt = GetTurretTargetVec( 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehDamageMultiplier", `Gets the damage multiplier that applies to the damage type.`, "vehicle", [new LibraryFunctionParameter("damageType", `The type of damage being applied to the vehicle`, true)], true, false, `vehicle GetVehDamageMultiplier( damgType )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleAvoidance", `Locks the heli to the height mesh`, "vehicle", [], true, false, `if ( vehicle GetVehicleAvoidance() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleAvoidanceNodes", `Get the positions for nearby avoidance nodes.`, "vehicle", [new LibraryFunctionParameter("radius", `A radius to filter out nodes returned.`, true)], true, false, `nodes = plane GetVehicleAvoidanceNodes( radius )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleNode", `Gets a vehicle node with the given name, key pair`, null, [new LibraryFunctionParameter("name", `(string) The name to search for`, true), new LibraryFunctionParameter("key", `(string) The key that name goes with`, true)], true, false, `node = getvehiclenode(self.target, "targetname")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleNodeArray", `Gets an array of vehicle nodes that have the given name, key pair`, null, [new LibraryFunctionParameter("name", `(string) The name to search for`, true), new LibraryFunctionParameter("key", `(string) The key that name goes with`, true)], true, false, `nodes = GetVehicleNodeArray(self.target, "targetname")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehicleOwner", `Returns the owner of this particular vehicle.`, "vehicle", [], true, false, `eFlak88user = eFlak88 GetVehicleOwner()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetVehOccupants", `Get the occupants of this vehicle in an entity array.`, "vehicle", [], true, false, `ridersarray = vehicle getvehoccupants()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("GetWheelSurface", `Returns the surface type of the given wheel as a string.`, "vehicle", [new LibraryFunctionParameter("wheel", `The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'`, true)], true, false, `surface = self GetWheelSurface( side )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsDriverFiring", `Checks if this driver is firing the vehicle turret`, "vehicle", [], true, false, `if( tank IsDriverFiring() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsGunnerFiring", `Checks if this gun is currently firing.`, "vehicle", [new LibraryFunctionParameter("gunner index", `The gunner to check`, true)], true, false, `if( tank IsGunnerFiring( 1 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsInsideHeliHeightLock", `Returns true if Helicopter is inside height mesh`, null, [], true, false, `if ( IsInsideHeliHeightLock() )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("isremotecontrol", `Query whether this vehicle is usable by players`, "vehicle", [], true, false, `if ( vehicle isvehicleusable(  ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsTurretReady", `Query whether this vehicle's turret is ready for firing`, "vehicle", [], true, false, `while ( level.playertank IsTurretReady() != true ) ...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleImmuneToDamage", `This checks the vehicle GDT settings related to bulletdamage, grenadedamage, etc.`, "vehicle", [new LibraryFunctionParameter("Damage Flags", `Integer specifying flags that are to be applied to the damage`, true), new LibraryFunctionParameter("Means Of Death", `Integer specifying the method of death`, true), new LibraryFunctionParameter("Weapon", `The weapon number of the weapon used to inflict the damage`, true)], true, false, `if ( vehicle IsVehicleImmuneToDamage( flags, mod, weapon ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleManualControl", `check if vehicle hkai behavior is enabled. Not to be confused with UseVehicle()`, "vehicle", [], true, false, `vehicle IsVehicleManualControl()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleSeatOccupied", `same as useby except you can specify a seat, 0 driver, 1-4 gunners, 5-10 passengers`, "vehicle", [new LibraryFunctionParameter("seat", `0 driver, 1-4 gunners, 5-10 passengers`, true)], true, false, `lvt IsVehicleSeatOccupied( 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleTurretOverheating", `Returns true if the vehicle turret weapon is overheating, else returns false.`, "vehicle", [new LibraryFunctionParameter("gunner index", `which gun 0-3`, true)], true, false, `if( self IsVehicleTurretOverheating( 1 ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("IsVehicleUsable", `Query whether this vehicle is usable by players`, "vehicle", [], true, false, `if ( vehicle isvehicleusable(  ) )...`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("JoltBody", `Jolts the vehicle.`, "vehicle", [new LibraryFunctionParameter("jolt position", `The position of the jolt`, true), new LibraryFunctionParameter("intensity", `The intensity of the jolt`, true), new LibraryFunctionParameter("speedFrac", `A speed fraction to apply to the jolt. Most be betweeon 0 and 1.`, false), new LibraryFunctionParameter("deceleration", `The deceleration to apply to this vehicle in miles per hour per second.`, false)], true, false, `self JoltBody( (self.origin + (0,0,64)), 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeVehicleUnusable", `Sets this vehicle to be not usable by the player`, "vehicle", [], true, false, `car MakeVehicleUnusable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("MakeVehicleUsable", `Sets this vehicle to be usable by the player`, "vehicle", [], true, false, `nFlak makeVehicleUsable()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathFixedOffset", `Sets a fixed offset for this vehicle to travel on a vehicle path.`, "vehicle", [new LibraryFunctionParameter("offset", `The offset to apply. A vector in the form (forward, right, up)`, true)], true, false, `huey PathFixedOffset( (0, -200, 0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathFixedOffsetClear", `Clears the vehicles fixed offset.`, "vehicle", [], true, false, `huey PathFixedOffsetClear()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathMove", `Moves the entire path for this vehicle to the specific origin and angles.`, "vehicle", [new LibraryFunctionParameter("node index", `Which node to move to the new location (it moves the whole path not just this node).`, true), new LibraryFunctionParameter("new origin", `The new position`, true), new LibraryFunctionParameter("new angles", `The new angles`, true)], true, false, `huey PathMove( node, origin, angles )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathMoveClear", `Clears the moved path for this vehicle.  If not cleared then all paths taken will be moved.`, "vehicle", [], true, false, `huey PathMoveClear()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathVariableOffset", `Sets a variable offset for this vehicle to travel on a vehicle path.`, "vehicle", [new LibraryFunctionParameter("offset", `The offset to apply. A vector in the form (forward, right, up)`, true), new LibraryFunctionParameter("time", `, The interval at which to choose new offsets`, true)], true, false, `huey PathVariableOffset( (0, 50, 0), 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("PathVariableOffsetClear", `Clears the vehicles variable offset.`, "vehicle", [], true, false, `huey PathVariableOffsetClear()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("RecalcSplinePaths", `Recalcs all the nodes int the map`, "vehicle", [], true, false, `tank2 RecalcSplinePaths()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReconnectVehicleNodes", `Reconnect vehicle nodes`, null, [], true, false, `ReconnectVehicleNodes()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResetVehicleFromDropDeploy", `Reset vehicle properties from drop deploy so that it may behave as normal.`, "vehicle", [], true, false, `raps ResetVehicleFromDropDeploy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ResumeSpeed", `Sets the vehicle to resume its path speed.`, "vehicle", [new LibraryFunctionParameter("acceleration", `The acceleration to apply to this vehicle in miles per hour per second.`, false)], true, false, `level.tank ResumeSpeed( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("ReturnPlayerControl", `After controlling a vehicle from script using something like setvehgoalpos(), if the vehicle is being driven by a player, you call this function to return control of the vehicle to the player.`, "vehicle", [], true, false, `cobra returnplayercontrol()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SeatGetWeapon", `Returns the weapon name for the specified seat.  Undefined if there isn't a weapon. Only driver and gunner seats can have weapons.`, "vehicle", [new LibraryFunctionParameter("seat index", `The seat to get weapon for`, true)], true, false, `weaponname = vehicle SeatGetWeapon( 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAcceleration", `Sets the acceleration for this vehicle.`, "vehicle", [new LibraryFunctionParameter("acceleration", `The acceleration of the vehicle in miles per hour per second`, true)], true, false, `self SetAcceleration( 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAirResistance", `Sets the speed at which air resistance maxes out.`, "vehicle", [new LibraryFunctionParameter("max air resistance speed", `speed at which air resistance maxes out (MPH)`, true)], true, false, `self SetAirResistance( 60 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetAngularVelocity", `Sets the angular velocity of a vehicle in degs/s.`, "vehicle", [new LibraryFunctionParameter("angular velocity", `The angular velocity to set`, true)], true, false, `self SetAngularVelocity( (0, 90, 0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBrake", `Turns off/on the hand brake of a nitrous physics vehicle.`, "vehicle", [new LibraryFunctionParameter("bool", `True or 1 to turn on the brake, false or 0 otherwise`, true)], true, false, `jeep setbrake(1)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetBuoyancyOffset", `set buoyancy offset that changes the height an individual vehicle floats in water`, "vehicle", [new LibraryFunctionParameter("offset", `A height offset from water surface.`, true)], true, false, `crocodile SetBuoyancyOffset( 20 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDamageStage", `Set the damage stage of the helicopter`, null, [new LibraryFunctionParameter("stage", `the damage stage to set`, true)], true, false, `self setdamagestage( 3 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDeceleration", `Sets the deceleration for this vehicle.`, "vehicle", [new LibraryFunctionParameter("deceleration", `The deceleration of the vehicle in miles per hour per second`, true)], true, false, `self SetDeceleration( 5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDefaultPitch", `Set the desired default pitch for a vehicle.`, "vehicle", [new LibraryFunctionParameter("pitch", `Set the default pitch`, true)], true, false, `level.heli setdefaultpitch(10)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetDrivePathPhysicsScale", `This scales all of the necessary parameters that will help a vehicle drive a path better.`, "vehicle", [new LibraryFunctionParameter("scale", `The scale to set`, false)], true, false, `boat SetDrivePathPhysicsScale( 3.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGoalYaw", `Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw`, "vehicle", [new LibraryFunctionParameter("integer", `The yaw direction of the target: 0 to 360 integer value`, true)], true, false, `level.flak1 SetGoalYaw( int_value )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGunnerTargetEnt", `Set the target entity for this vehicle gunner.`, "vehicle", [new LibraryFunctionParameter("target entity", `The target.`, true), new LibraryFunctionParameter("target offset", `The target offset.`, false), new LibraryFunctionParameter("gunner index", `Which gun, 0-3.`, false)], true, false, `eLiberator SetGunnerTargetEnt( eFlaktarget, (0,0,0), 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGunnerTargetVec", `Set the target position for this vehicle turret gunner.`, "vehicle", [new LibraryFunctionParameter("target position", `vecter to aim at/ the position of the target`, true), new LibraryFunctionParameter("gunner index", `which gun 0-3`, false)], true, false, `level.flak1 SetGunnerTargetVec( vec1, 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetGunnerTurretOnTargetRange", `Set the range at which the gunner_turret_on_target notify will occur.`, "vehicle", [new LibraryFunctionParameter("gunner index", `Which gun, 0-3.`, true), new LibraryFunctionParameter("range", `In degrees`, false)], true, false, `boat SetGunnerTurretOnTargetRange( 0, 15 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHeliDogfighting", `Sets the vehicle (intended for VTOLs only) to be in dogfighting mode (dogfights with the vehicle's focus entity)`, "vehicle", [new LibraryFunctionParameter("enabled", `true to enable dogfighting, false otherwise`, true)], true, false, `vehicle SetHeliDogfighting( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHeliHeightCap", `Pulls the heli back down below the height mesh`, "vehicle", [new LibraryFunctionParameter("enabled", `true to enable, false otherwise`, true)], true, false, `vehicle SetHeliHeightCap( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHeliHeightLock", `Locks the heli to the height mesh`, "vehicle", [new LibraryFunctionParameter("enabled", `true to enable lock, false otherwise`, true)], true, false, `vehicle SetHeliHeightLock( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHeliHeightPatchEnabled", `Enabled or disables the specified heli height lock path`, null, [new LibraryFunctionParameter("targetname", `All heli height lock patches with this target name`, true), new LibraryFunctionParameter("enabled", `Turn it on or off`, true), new LibraryFunctionParameter("player", `If defined, only modify the setting for that player`, false)], true, false, `SetHeliHeightPatchEnabled( "area51", 0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetHoverParams", `Set the hovering parameters.`, "vehicle", [new LibraryFunctionParameter("radius", `The hovering range.`, true), new LibraryFunctionParameter("speed", `Speed to hover at (MPH)`, false), new LibraryFunctionParameter("accel", `Acceleration to hover at (MPH/s)`, false)], true, false, `self SetHoverParams( 50, 1, 0.5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetJitterParams", `Set the jitter parameters. Set everything to 0 to stop jittering. Vehicle ignores jitter parameters when on ground`, "vehicle", [new LibraryFunctionParameter("range vector", `The jitter range vector.`, true), new LibraryFunctionParameter("min period", `Minimum time in seconds to switch jitter direction. Default 0.5 sec`, false), new LibraryFunctionParameter("max period", `Maximum time in seconds to switch jitter direction. Default 1.0 sec`, false)], true, false, `self SetJitterParams( (0,0,20), 0.5, 1.5 ); // Jitter up or down randomly within 20 units, switching every 0.5 to 1.5 seconds`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLookAtEnt", `Set the entity this vehicle will orient towards.`, "vehicle", [new LibraryFunctionParameter("entity", `The target.`, true)], true, false, `eFlak88 setLookAtEnt( eFlaktarget )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetLookAtOrigin", `Set the origin this vehicle will orient towards.`, "vehicle", [new LibraryFunctionParameter("entity", `The target.`, true)], true, false, `heli setLookAtOrigin( org )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMantleEnabled", `Sets the mantle enabled flag on the vehicle`, "vehicle", [new LibraryFunctionParameter("enabled", `True to set the mantle enabled, false otherwise`, true)], true, false, `vehicle SetMantleEnabled( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMaxAccelerationScale", `Sets the max acceleration scale for this physics vehicle.`, "vehicle", [new LibraryFunctionParameter("scale", `The acceleration scale of the physics vehicle`, true)], true, false, `self SetMaxAccelerationScale( 2.6 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMaxPitchRoll", `Sets max pitch and roll angle for this vehicle.`, "vehicle", [new LibraryFunctionParameter("pitch", `Max pitch angle`, true), new LibraryFunctionParameter("roll", `Max roll angle`, true)], true, false, `self SetMaxPitchRoll( 30, 30 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMaxSpeedScale", `Sets the max speed scale for this physics vehicle.`, "vehicle", [new LibraryFunctionParameter("scale", `The max speed scale of the physics vehicle`, true)], true, false, `self SetMaxSpeedScale( 2.6 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetMinDesiredTurnYaw", `The vehicle will not update its desired yaw until the min turn yaw is reached. Set it to 0 to clear it.`, "vehicle", [new LibraryFunctionParameter("yaw", `The min desired turn yaw to set`, true)], true, false, `quadtank SetMinDesiredTurnYaw( 45 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetNearGoalNotifyDist", `Set distance near goal at which near_goal notification should be sent once.`, "vehicle", [new LibraryFunctionParameter("dist", `Distance to goal position`, true)], true, false, `tank setNearGoalNotifyDist( 50 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPathTransitionTime", `Set the time it takes for a vehicle to lerp on to a spline.`, "vehicle", [new LibraryFunctionParameter("time", `The transition time`, true)], true, false, `boat SetPathTransitionTime( 1.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPhysAcceleration", `Sets the vehicles acceleration vector.`, "vehicle", [new LibraryFunctionParameter("acceleration", `The vehicle acceleration`, true)], true, false, `plane SetPhysAcceleration( ( 0, 0, -1600) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPhysAngles", `Sets the angles on the phys structure`, "vehicle", [new LibraryFunctionParameter("angles vector", `The desired angles.`, true)], true, false, `self SetPhysAngles( VectorToAngles( desired_forward ) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlaneBarrelRoll", `Set the goal Roll direction for this plane. PLANE_ON_CURVE has priority over ROLL if this is not set.`, "plane", [new LibraryFunctionParameter("number", `The number of rolls`, true), new LibraryFunctionParameter("time", `The goal roll time`, false)], true, false, `level.plane SetPlaneBarrelRoll( 1, 5.0f )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetPlaneGoalPos", `Set the target position, speed, angles for this vehicle.`, "plane", [new LibraryFunctionParameter("goal position", `The goal position`, true)], true, false, `plane Setplanegoalpos( ( 200, 200, 200 ), ( 30, 0, 90 ), 170.0 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetRotorSpeed", `Sets the helicopters rotor speed.`, "vehicle", [new LibraryFunctionParameter("speed", `The rotor speed, 0 is stopped 1 is full speed.`, true)], true, false, `heli SetRotorSpeed( 0.2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSeatOccupied", `Sets this seat to be occupied/disabled (for players.`, "vehicle", [new LibraryFunctionParameter("seat", `0 driver, 1-4 gunners, 5-10 passengers`, true), new LibraryFunctionParameter("onoff", `true to enable, false otherwise`, false)], true, false, `vehicle SetSeatOccupied( 2, true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpeed", `Sets the speed and acceleration for this vehicle.`, "vehicle", [new LibraryFunctionParameter("speed", `The speed of the vehicle in miles per hour`, true), new LibraryFunctionParameter("acceleration", `The acceleration of the vehicle in miles per hour per second`, false), new LibraryFunctionParameter("deceleration", `Deceleration. If not specified, set to be equal to half of accleration`, false)], true, false, `self SetSpeed( 60, 15, 5 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSpeedImmediate", `Sets the speed and acceleration for this vehicle instantaneously. Direction will be toward the goal direction if there is a goal, otherwise the current direction.`, "vehicle", [new LibraryFunctionParameter("speed", `The speed of the vehicle in miles per hour`, true), new LibraryFunctionParameter("acceleration", `The acceleration of the vehicle in miles per hour per second`, false), new LibraryFunctionParameter("deceleration", `Deceleration. If not specified, set to be equal to half of accleration`, false)], true, false, `self setspeedimmediate(60, 15, 5)`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetSwitchNode", `Sets a switch node for this vehicle.`, "vehicle", [new LibraryFunctionParameter("source node", `The switch source node`, true), new LibraryFunctionParameter("dest node", `The switch destination node.`, true)], true, false, `tank2 SetSwitchNode( tank2snode1, tank2snode2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTargetYaw", `Set the target yaw direction for this vehicle. Goal yaw has priority over target yaw.`, "vehicle", [new LibraryFunctionParameter("yaw", `The yaw direction of the target`, true)], true, false, `level.flak1 SetTargetYaw( vec1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurningAbility", `If this is higher, helicopters can make sharper turns to match goal positions better.`, "vehicle", [new LibraryFunctionParameter("turning ability", `Between 0.001 and 1.0. Defaults to 0.5`, true)], true, false, `self SetTurningAbility( 0.9 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretTargetEnt", `Set the target entity for this vehicle turret.`, "vehicle", [new LibraryFunctionParameter("target entity", `The target.`, true), new LibraryFunctionParameter("target offset", `The target offset.`, false)], true, false, `eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretTargetRelativeAngles", `Set the target entity for this vehicle turret.`, "vehicle", [new LibraryFunctionParameter("relative angles", `The target angle`, true), new LibraryFunctionParameter("turret index", `0 for turret, 1-4 for gunners`, false)], true, false, `eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetTurretTargetVec", `Set the target position for this vehicle turret.`, "vehicle", [new LibraryFunctionParameter("target position", `The position of the target`, true)], true, false, `level.flak1 SetTurretTargetVec( vec1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehGoalPos", `Set the target position for this vehicle. Returns true if it can find a path.  If it fails to find a path the vehicle will be stopped.`, "vehicle", [new LibraryFunctionParameter("goalpos", `The goal position`, true), new LibraryFunctionParameter("stopAtGoal", `Whether the vehicle should slow down to stop at the goal position`, false), new LibraryFunctionParameter("usepath", `set to 1 to use pathfinding`, false)], true, false, `tank SetVehGoalPos( (0, 0, 0), 1 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleAvoidance", `Turns on and off vehicle avoidance`, "vehicle", [new LibraryFunctionParameter("enabled", `True to enable avoidance, false otherwise`, true), new LibraryFunctionParameter("radius", `The avoidance radius`, false), new LibraryFunctionParameter("priority", `Vehicles will avoid everything that is the same priority or higher.  Default priority is 1.`, false)], true, false, `vehicle SetVehicleAvoidance( true, 50 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleForDropDeploy", `Set vehicle properties so that it can be dropped into a map.`, "vehicle", [], true, false, `raps SetVehicleForDropDeploy()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleManualControl", `Turns on and off vehicle hkai behavior. Not to be confused with UseVehicle()`, "vehicle", [new LibraryFunctionParameter("enabled", `True to enable vehicle  hkai behavior, false otherwise`, true)], true, false, `vehicle SetVehicleManualControl( true )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehicleType", `Sets the vehicles type.`, "vehicle", [new LibraryFunctionParameter("type", `The type name`, true)], true, false, `plane SetVehicleType("f35_vtol")`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehMaxSpeed", `overrides the max speed for this vehicle.`, "vehicle", [new LibraryFunctionParameter("speed", `The speed to set`, true)], true, false, `self SetVehMaxSpeed( 45 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehVelocity", `Sets the linear velocity on a vehicle/s.`, "vehicle", [new LibraryFunctionParameter("velocity", `The vehicle velocity`, true)], true, false, `self SetVehVelocity( (45, 0, 0) )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetVehWeapon", `Set the vehicle's weapon`, "vehicle", [new LibraryFunctionParameter("weapon name", `The name of the weapon`, true)], true, false, `chopper setVehWeapon( "AGM_114" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SetYawSpeed", `Sets the yaw speed for this vehicle.`, "vehicle", [new LibraryFunctionParameter("speed", `The speed of the vehicle in angles per second`, true), new LibraryFunctionParameter("acceleration", `The acceleration of the vehicle in angles per second^2`, true), new LibraryFunctionParameter("deceleration", `Deceleration. If not specified, set to be equal to acceleration`, false)], true, false, `self SetYawSpeed( 120, 60 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StartPath", `Starts the vehicle following this path.`, "vehicle", [], true, false, `bomber StartPath()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("StopFireWeapon", `Stop firing the vehicle's main weapon`, "vehicle", [], true, false, `nFlak StopFireWeapon()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("SwitchStartNode", `Swaps the start node for this vehicle.`, "vehicle", [new LibraryFunctionParameter("source node", `The start source node`, true), new LibraryFunctionParameter("dest node", `The start destination node.`, true)], true, false, `tank2 SwitchStartNode( tank2snode1, tank2snode2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("TakePlayerControl", `You call this function to take control away from a player.`, "vehicle", [], true, false, `cobra TakePlayerControl()`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("UseVehicle", `same as useby except you can specify a seat, 0 driver, 1-4 gunners`, "vehicle", [new LibraryFunctionParameter("user entity", `The player to use the vehicle`, true), new LibraryFunctionParameter("seat", `0 driver, 1-4 gunners, 5-10 passengers`, true)], true, false, `lvt usevehicle( player, 2 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("VehDriverAimAtCrosshairs", `Enables or disables the driver turret aiming at the crosshairs (aiming at the crosshairs overrides all other aim targets and is the default behavior)`, "vehicle", [new LibraryFunctionParameter("AimAtCrosshairs", `True to aim the turret at the crosshairs`, true)], true, false, `vehicle VehDriverAimAtCrosshairs( false )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("EnumerateWeapons", `Return an array of weapon names for the weapons of weapon type in fastfile`, null, [new LibraryFunctionParameter("weapon type", `The type of weapon to return(weapon or weaponfull)`, true)], true, true, `a_weapons = EnumerateWeapons( "weapon" )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_CreateAttractorEnt", `Creates a missile attractor at the origin of an entity`, null, [new LibraryFunctionParameter("entity", `The entity that is to be an attractor`, true), new LibraryFunctionParameter("strength", `The strength of the attractor (maximum acceleration it can apply to a missile)`, true), new LibraryFunctionParameter("affectdist", `The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.`, true), new LibraryFunctionParameter("affectAllProjectiles", `If set it will affect all projectiles inculding grenades and guided missiles.`, false), new LibraryFunctionParameter("alert range", `If set it send notify when missile breaches range(but will not repulse).`, false)], true, false, `attractor = Missile_CreateAttractorEnt( enemy_chopper, 10000, 6000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_CreateAttractorOrigin", `Creates a missile attractor at the given location`, null, [new LibraryFunctionParameter("origin", `The center of the attractor`, true), new LibraryFunctionParameter("strength", `The strength of the attractor (maximum acceleration it can apply to a missile)`, true), new LibraryFunctionParameter("affectDist", `The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.`, true), new LibraryFunctionParameter("affectAllProjectiles", `If set it will affect all projectiles inculding grenades and guided missiles.`, false), new LibraryFunctionParameter("alert range", `If set it send notify when missile breaches range(but will not repulse).`, false)], true, false, `attractor = Missile_CreateAttractorOrigin( (100, 350, 10), 10000, 6000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_CreateRepulsorEnt", `Creates a missile repulsor at the origin of an entity`, null, [new LibraryFunctionParameter("entity", `The entity that is to be a repulsor`, true), new LibraryFunctionParameter("strength", `The strength of the repulsor (maximum acceleration it can apply to a missile)`, true), new LibraryFunctionParameter("affectDist", `The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.`, true), new LibraryFunctionParameter("affectAllProjectiles", `If set it will affect all projectiles inculding grenades and guided missiles.`, false), new LibraryFunctionParameter("alert range", `If set it send notify when missile breaches range(but will not repulse).`, false)], true, false, `repulsor = Missile_CreateRepulsorEnt( enemy_chopper, 10000, 6000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_CreateRepulsorOrigin", `Creates a missile Repulsor at the given location`, null, [new LibraryFunctionParameter("origin", `The center of the Repulsor`, true), new LibraryFunctionParameter("strength", `The strength of the Repulsor (maximum acceleration it can apply to a missile)`, true), new LibraryFunctionParameter("affectDist", `The effective distance at which the missile can be affected.  The effect of the attractor falls off from <strength> to zero from the center to this distance away from the center.`, true), new LibraryFunctionParameter("affectAllProjectiles", `If set it will affect all projectiles inculding grenades and guided missiles.`, false), new LibraryFunctionParameter("alert range", `If set it send notify when missile breaches range(but will not repulse).`, false)], true, false, `repulsor = Missile_CreateRepulsorOrigin( (100, 350, 10), 10000, 6000 )`, FunctionFlag.AutoGenerated)); // auto generated
		this.addFunction(new LibraryFunction("Missile_DeleteAttractor", `Deletes a missile attractor or repulsor`, null, [new LibraryFunctionParameter("attractor", `The attractor or repulsor`, true)], true, false, `Missile_DeleteAttractor( attractor )`, FunctionFlag.AutoGenerated)); // auto generated
	}

	// Utility functions
	static addToLibrary(target: Array<vscode.CompletionItem>, entry: LibraryFunction, label: string): void {
		// Do not provide as a completion item if the function doesn't work
		if(entry.flag === FunctionFlag.Broken) {
			return;
		}

		let result = new vscode.CompletionItem(new LibraryCompletionItemLabel(entry.name, undefined, label), vscode.CompletionItemKind.Function);
		result.detail = entry.example;

		let insertText = "";
		if(entry.calledOn !== null) {
			insertText = `${entry.calledOn} `;
		}
		insertText += `${entry.name}(${entry.parameters.map(p => p.name).join(", ")});`;

		result.insertText = insertText;
		result.documentation = entry.toDocString();

		target[target.length] = result;
	}

	/**
	 * Adds the provided GSC or CSC function to one or both of the Maps. It also performs some validation
	 * @param entry The LibraryFunction entry for this function
	 */
	static addFunction(entry: LibraryFunction): void {
		// Validation
		if (!entry.isCSC && !entry.isGSC) {
			throw new Error("Attempt to add a library function that does not belong to either GSC or CSC: " + entry.name);
		}

		// TODO: Either make the map case-insensitive or provide a tolower key.
		if (entry.isGSC) {
			this.addToLibrary(this.gscFunctionArray, entry, "GSC API");
			this.gscFunctionMap.set(entry.name.toLowerCase(), entry);
		}
		if (entry.isCSC) {
			this.addToLibrary(this.cscFunctionArray, entry, "CSC API");
			this.cscFunctionMap.set(entry.name.toLowerCase(), entry);
		}
	}

	static getFunction(language: string, functionName: string) {
		switch(language) {
			case "gsc":
				return this.gscFunctionMap.get(functionName.toLowerCase());
			case "csc":
				return this.cscFunctionMap.get(functionName.toLowerCase());
			default: // Right now, use GSC as the default for GSH, until we can come up with a method for duplicates
				return this.gscFunctionMap.get(functionName.toLowerCase());
		}
	}
}

Library.init();